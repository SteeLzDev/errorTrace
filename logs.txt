        }
        if (externalItem.getAnticipatedOn() != null) {
            item.setAnticipatedOn(JsonNullable.of(externalItem.getAnticipatedOn().toString()));
        }
        if (externalItem.getPaymentDate() != null) {
            item.setPaymentDate(JsonNullable.of(externalItem.getPaymentDate()));
        }

Incompatible types. Found: 'org.openapitools.jackson.nullable.JsonNullable<java.lang.String>', required: 'java.time.LocalDateTime'
Incompatible types. Found: 'org.openapitools.jackson.nullable.JsonNullable<org.openapitools.jackson.nullable.JsonNullable<java.lang.String>>', required: 'java.time.LocalDateTime'




package br.com.experian.anticipation.domain.service.impl;

import br.com.experian.anticipation.domain.constant.HistoryStatusMapping;
import br.com.experian.anticipation.domain.exception.ConflictException;
import br.com.experian.anticipation.domain.model.Agreement;
import br.com.experian.anticipation.domain.repository.AgreementRepository;
import br.com.experian.anticipation.domain.service.HistoryService;
import br.com.experian.anticipation.infrastructure.integration.feign.client.antecipa.AntecipaClient;
import br.com.experian.observability.annotation.LogMethod;
import br.com.experian.swagger.antecipa.model.AntecipaAnticipationCardReceivableDto;
import br.com.experian.swagger.antecipa.model.AntecipaAnticipationCardReceivableListDto;
import br.com.experian.swagger.antecipa.model.AntecipaAnticipationCardReceivableListDtoPagedCollectionItems;
import br.com.experian.swagger.anticipation.model.*;
import lombok.extern.log4j.Log4j2;
import org.openapitools.jackson.nullable.JsonNullable;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Log4j2
public class HistoryServiceImpl implements HistoryService {


    private final AntecipaClient antecipaClient;
    private final AgreementRepository agreementRepository;
    private final String authToken;

    public HistoryServiceImpl(AntecipaClient antecipaClient,
                              AgreementRepository agreementRepository,
                              String authToken) {
        this.antecipaClient = antecipaClient;
        this.agreementRepository = agreementRepository;
        this.authToken = authToken;
    }


    @Override
    @LogMethod
    public Optional<AnticipationHistoryResponseTO> findHistoryPaginated(String capitalSourceDocument,
                                                String startAnticipationDate,
                                                String endAnticipationDate,
                                                String statusId,
                                                String pageId,
                                                Integer pageSize) {
        Agreement agreement = this.getUserAgreement();
        String supplierDocument = agreement.getNationalRegistrationId();

        log.info("Fetching paginated anticipation history for supplier: {}", supplierDocument);

        try {
            AntecipaAnticipationCardReceivableListDtoPagedCollectionItems externalHistory =
                    this.antecipaClient.getAnticipations("Bearer " + authToken,
                            supplierDocument,
                            capitalSourceDocument,
                            startAnticipationDate,
                            endAnticipationDate,
                            statusId,
                            pageId,
                            pageSize);
            if (externalHistory == null || externalHistory.getItems() == null || externalHistory.getItems().get().isEmpty()) {
                log.info("No anticipation history found for supplier: {}", supplierDocument);
                return Optional.empty();
            }

            List<AnticipationHistoryItemTO> historyItems = externalHistory.getItems().get().stream()
                    .map(this::convertToAnticipationHistoryItem)
                    .collect(Collectors.toList());

            AnticipationHistoryResponseTO response = new AnticipationHistoryResponseTO();
            for (AnticipationHistoryItemTO item : historyItems) {
                response.items(item);
            }
            if (externalHistory.getPageNextId() != null && externalHistory.getPageNextId().isPresent()) {
                response.setPageNexId(String.valueOf(externalHistory.getPageNextId().get()));
            }
            response.setPageSize(pageSize != null ? pageSize : 10);

            log.info("Successfully retieved {} anticipation records for supplier: {}",
                    historyItems.size(), supplierDocument);
            return Optional.of(response);

        } catch (Exception e) {
            log.error("Error retrieving paginated anticipation history for supplier: {}", supplierDocument, e);
            throw e;
        }
    }


    @Override
    @LogMethod
    public Optional<AnticipationDetailResponseTO> findHistoryDetailById(String supplierDocument, String id, Integer pageSize) {
        Agreement agreement = this.getUserAgreement();

        log.info("Fetching anticipation details for supplier: {} and ID: {}", supplierDocument, id);
        try {
            AntecipaAnticipationCardReceivableDto externalDetail =
                    this.antecipaClient.getAnticipationById("Bearer " + authToken, supplierDocument, id);

            if (externalDetail == null) {
                log.info("No anticipation found for supplier: {} and ID: {}", supplierDocument, id);
                return Optional.empty();
            }

            AnticipationDetailResponseTO detail = convertToAnticipationDetailResponse(externalDetail);
            log.info("Successfully retrieved anticipation details for supplier: {} and ID: {}", supplierDocument, id);
            return Optional.of(detail);
        } catch (Exception e) {
            log.error("Error retrieving anticipation details for supplier: {} and ID: {}", supplierDocument, id, e);
            throw e;
        }
    }

    private AnticipationHistoryItemTO convertToAnticipationHistoryItem(AntecipaAnticipationCardReceivableListDto externalItem) {
        AnticipationHistoryItemTO item = new AnticipationHistoryItemTO();

        if (externalItem.getId() != null && externalItem.getId().isPresent()) {
            item.setId(String.valueOf(externalItem.getId().get()));
        }

        if (externalItem.getCreatedAt() != null);{
            item.setCreatedAt(externalItem.getCreatedAt().toString());
        }
        if (externalItem.getStatusId() != null) {
            String mappedStatus = String.valueOf(HistoryStatusMapping.mapFromExternalStatusId(externalItem.getStatusId()));
            item.setStatus(mappedStatus);
            item.setStatusId(getStatusIdFromMappedStatus(mappedStatus));
        }
        if (externalItem.getReceivedAmount() != null) {
            item.setReceivedAmount(BigDecimal.valueOf(externalItem.getReceivedAmount()));
        }
        if (externalItem.getAnticipatedOn() != null) {
            item.setAnticipatedOn(JsonNullable.of(externalItem.getAnticipatedOn().toString()));
        }
        if (externalItem.getPaymentDate() != null) {
            item.setPaymentDate(JsonNullable.of(externalItem.getPaymentDate()));
        }
        if (externalItem.getEffectiveRate() != null) {
            item.setEffectiveRate(BigDecimal.valueOf(externalItem.getEffectiveRate()));
        }
        if (externalItem.getSelectedAmount() != null) {
            item.selectedAmount(BigDecimal.valueOf(externalItem.getSelectedAmount()));
        }
        if (externalItem.getAnticipatedDiscount() != null) {
            item.setAnticipatedDiscount(BigDecimal.valueOf(externalItem.getAnticipatedDiscount()));
        }

        item.setAccreditingInstitution(createAccreditingInstitution());
        item.setCapitalSource(createCapitalSource());
        item.setSupplier(createSupplier());

        return item;
    }

    private AnticipationDetailResponseTO convertToAnticipationDetailResponse (AntecipaAnticipationCardReceivableDto externalDetail) {
        AnticipationDetailResponseTO response = new AnticipationDetailResponseTO();

        if (externalDetail.getId() != null) {
            response.setId(String.valueOf(externalDetail.getId().get()));
        }
        if (externalDetail.getNumber() != null) {
            response.setNumber(externalDetail.getNumber());
        }
        if (externalDetail.getStatusId() != null) {
            String mappedStatus = String.valueOf(HistoryStatusMapping.mapFromExternalStatusId(externalDetail.getStatusId()));
            response.setStatus(mappedStatus);
            response.setStatusId(getStatusIdFromMappedStatus(mappedStatus));
        }
        if (externalDetail.getCreatedAt() != null) {
            response.setCreatedAt(externalDetail.getCreatedAt());
        }
        if (externalDetail.getCreatedAt() != null) {
            response.setCreatedAt(externalDetail.getCreatedAt());
        }
        if (externalDetail.getPaymentDate() != null) {
            response.setPaymentDate(externalDetail.getPaymentDate());
        }
        if (externalDetail.getAmount() != null) {
            response.setAmount(BigDecimal.valueOf(externalDetail.getAmount()));
        }
        if (externalDetail.getEffectiveRate() != null) {
            response.setEffectiveRate(BigDecimal.valueOf(externalDetail.getEffectiveRate()));
        }
        if (externalDetail.getSelectedAmount() != null) {
            response.setSelectedAmount(BigDecimal.valueOf(externalDetail.getSelectedAmount()));
        }
        if (externalDetail.getReceivedAmount() != null) {
            response.setReceivedAmount(BigDecimal.valueOf(externalDetail.getReceivedAmount()));
        }
            response.setAnticipatedItems(new ArrayList<>());
            response.setNoAnticipatedItems(new ArrayList<>());

        response.setAccreditingInstitution(createAccreditingInstitution());
        response.setCapitalSource(createCapitalSource());
        response.setSupplier(createSupplier());
        response.setBankAccount(createBankAccount());

        return response;
    }


    private AnticipatedItemTO convertToAnticipatedItem(Object receivable) {
        AnticipatedItemTO item = new AnticipatedItemTO();

        return item;
    }

    private InstitutionTO createAccreditingInstitution() {
        InstitutionTO institution = new InstitutionTO();
        institution.setId("1");
        institution.setDocument("12345678901234");
        institution.setFormattedDocument("12.345.678/0001-90");
        institution.setName("Cielo S.A");
        return institution;
    }

    private InstitutionTO createCapitalSource() {
        InstitutionTO capitalSource = new InstitutionTO();
        capitalSource.setId("2");
        capitalSource.setDocument("987654321000199");
        capitalSource.setFormattedDocument("98.765.432/0001-10");
        capitalSource.setDocument("Factoring company Ltda");
        return capitalSource;
    }

    private InstitutionTO createSupplier(){
        InstitutionTO supplier = new InstitutionTO();
        supplier.setId("3");
        supplier.setDocument("98765431000110");
        supplier.formattedDocument("11.222.333/0001-81");
        supplier.setName("Supplier company Ltda");
        return supplier;
    }

    private BankAccountTO createBankAccount() {
        BankAccountTO bankAccount = new BankAccountTO();
        bankAccount.setId("1");
        bankAccount.setExternalId("EXT123");
        bankAccount.setBankCode("001");
        bankAccount.setBankName("Banco do Brasil");
        bankAccount.setBranchNumber("1234");
        bankAccount.setBranchDigit("5");
        bankAccount.setAccountNumber("567890");
        bankAccount.accountDigit("1");
        return bankAccount;
    }

    private Integer getStatusIdFromMappedStatus(String status){
        switch (status){
            case "PENDING":
                return 1;
            case "CONCLUDED":
                return 2;
            case "PARTIALLY_APPROVED":
                return 3;
            case "ERROR":
                return 4;
            default:
                return 1;
        }
    }


    private Agreement getUserAgreement() {
        return this.agreementRepository.getUserAgreement()
                .orElseThrow(() -> new ConflictException("3"));
    }

}
