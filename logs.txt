package br.com.experian.buzz.config;

import br.com.experian.buzz.infrastructure.adapter.AntecipaAuthAdapterDebug;
import br.com.experian.buzz.domain.port.AuthenticationPort;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.HostnameVerifier;
import java.security.cert.X509Certificate;
import java.nio.charset.StandardCharsets;

import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.NoopHostnameVerifier;

/**
 * 🔍 Configuração para modo debug.
 * Configura RestTemplate com SSL desabilitado para desenvolvimento.
 */
@Configuration
@Profile("debug")
public class DebugConfig {

    private static final Logger log = LoggerFactory.getLogger(DebugConfig.class);

    /**
     * 🔍 RestTemplate configurado para debug com SSL desabilitado.
     */
    @Bean
    @Primary
    public RestTemplate debugRestTemplate() {
        log.info("🔍 DEBUG: Configurando RestTemplate com SSL desabilitado");
        
        try {
            // Criar SSLContext que aceita todos os certificados
            SSLContext sslContext = SSLContextBuilder
                .create()
                .loadTrustMaterial(null, new TrustSelfSignedStrategy())
                .build();

            // Criar SSLConnectionSocketFactory que aceita todos os hostnames
            SSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(
                sslContext, 
                NoopHostnameVerifier.INSTANCE
            );

            // Criar HttpClient com SSL desabilitado
            CloseableHttpClient httpClient = HttpClients.custom()
                .setSSLSocketFactory(sslSocketFactory)
                .build();

            // Configurar RestTemplate com HttpClient customizado
            HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();
            factory.setHttpClient(httpClient);
            factory.setConnectTimeout(30000);
            factory.setReadTimeout(30000);

            RestTemplate restTemplate = new RestTemplate(factory);
            
            // Adicionar interceptor para logs detalhados
            restTemplate.getInterceptors().add(debugInterceptor());
            
            log.info("🔍 DEBUG: RestTemplate configurado com SSL desabilitado usando Apache HttpClient 4.x");
            return restTemplate;
            
        } catch (Exception e) {
            log.error("🔍 DEBUG: Erro ao configurar RestTemplate com SSL desabilitado", e);
            
            // Fallback: RestTemplate simples com SSL global desabilitado
            disableSSLGlobally();
            RestTemplate restTemplate = new RestTemplate();
            restTemplate.getInterceptors().add(debugInterceptor());
            log.info("🔍 DEBUG: Usando fallback - RestTemplate simples com SSL global desabilitado");
            return restTemplate;
        }
    }

    /**
     * 🔍 Interceptor para logs detalhados das requisições HTTP.
     */
    private ClientHttpRequestInterceptor debugInterceptor() {
        return (request, body, execution) -> {
            log.info("🔍 DEBUG REST REQUEST: {} {}", request.getMethod(), request.getURI());
            log.info("🔍 DEBUG REST HEADERS: {}", request.getHeaders());
            
            if (body.length > 0) {
                String bodyStr = new String(body, StandardCharsets.UTF_8);
                log.info("🔍 DEBUG REST BODY: {}", bodyStr);
            }
            
            var response = execution.execute(request, body);
            
            log.info("🔍 DEBUG REST RESPONSE STATUS: {}", response.getStatusCode());
            log.info("🔍 DEBUG REST RESPONSE HEADERS: {}", response.getHeaders());
            
            return response;
        };
    }

    /**
     * 🔍 Desabilita SSL globalmente como fallback.
     */
    private void disableSSLGlobally() {
        try {
            log.info("🔍 DEBUG: Aplicando fallback - desabilitando SSL globalmente");
            
            // Criar TrustManager que aceita todos os certificados
            TrustManager[] trustAllCerts = new TrustManager[]{
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }
                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                    }
                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                    }
                }
            };

            // Instalar o TrustManager que aceita todos
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // Criar HostnameVerifier que aceita todos os hostnames
            HostnameVerifier allHostsValid = (hostname, session) -> true;
            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

            log.info("🔍 DEBUG: SSL desabilitado globalmente");

        } catch (Exception e) {
            log.error("🔍 DEBUG: Erro ao desabilitar SSL globalmente", e);
        }
    }

    /**
     * 🔍 Usar o adapter debug como primário.
     */
    @Bean
    @Primary
    public AuthenticationPort debugAuthenticationPort(AntecipaAuthAdapterDebug debugAdapter) {
        log.info("🔍 DEBUG: Usando AntecipaAuthAdapterDebug para debug detalhado");
        return debugAdapter;
    }
}
