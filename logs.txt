Quem Poderá ajudar sobre o Zenvia

Pessoal do SalaryFits ou o Nolasco, já que o Alexandre irá entrar de férias.


1 - Controle de envio vai continuar fazendo ele, só não vamos fazer o controle de envio contabilizando  .... Continuar registrando ocorrência para o servidor, o SMS Vamos enviar para o servidor (colaborador, o usuário que está usando o sistema, o destinatário dele). Como essa ocorrência de envio, vamos enviar só para o servidor 






Provavelmente vai ter que ter uma camada acima do SMSHelper e depois chamar ele:

Porque quando usa eConsig, temos mais de 1 (chamamos de papel) que é a consignatária = banco. usuário servidor = servidor público ou colaborador do sistema privado. consignante = gestor dos sistema (responsável pelo sistema). Temos esses papéis. Também tem o papel de suporte, que é o suporte de SMS. Temos o sistema de ocorrência para cada um deles. tb_ocorrencia_consignataria, tb_ocorrencia_consignante, tb_ocorrencia_servidor. Temos uma tabela de ocorrência para cada tipo de entidades. 

O Lugar correto para enviar SMS para o servidor, é na ocorrência de servidor "mandei sms para o servidor" e aí tenho o código que é a PK desse servidor (SER_CODIGO)que é da tabela de servidor, para eu saber quem é essa pessoa que recebeu o SMS e a mesma coisa para consignante, que é a PK MFK (CSE_CODIGO) e tem da consignatária (CSA_CODIGO)

O que podemos fazer, eu tenho uma ocorrência de usuário, a ocorrência de usuário é a ocorrência de qualquer usuário do sistema, independente do papel dele. a partir desse USU_CODIGO eu consigo saber quem é essa pessoa, se ele é consignante, qual usuário consignante ele é.

Sugestão: ao enviar SMS, vamos armazenar na tabela de ocorrência de usuário, falando que foi enviado um SMS para ele. Como saber esse USU_CODIGO, quem que é essa pessoa? 

a camada SMSHelper pode não me atender porque ela não tem quem é a pessoa que está usando o sistema, sem saber quem é, não conseguimos armazenar o USU_CODIGO dele (chave do usuário), temos um objeto que é o "AcessoSistema", ele tem tudas informações da pessoa  que está usando o sistema. 

Sugestão: Achar onde está usando o SMSHelper, antes de fazer o envio dele, no método chamar  AcessoSistema responsável, pegar o usuCodigo dentro do objeto tem um get.usuCodigo "responsavel.gtUsuCodigo();" ou seja, conseguimos criar uma tabela de ocorrência de usuário.

Tem um método no sistema que já cria ocorrência para o usuário "tb_ocorrencia_usuario"?  sim. no createOcorrenciaUsuario, podemos usar esse objeto.


No SMSHelper, mudar o método para ele receber o responsável, com isso vou precisar mudar a classe, colocando anotations para permitir que eu utilize as classes de implementação, fazer o @Autowired ou chamar a classe bean, usamos o ApplicationContextProvider.getApplicationContext().containsBean(conteudo) que chama direto a classe.

Apenas para entendimento:


final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
        ocorrencia.setUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setTocCodigo(CodedValues.TOC_AUT_CADASTRO_EMAIL_SERVIDOR_TOTEM);
        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.autorizacao.cadastro.email.servidor.host.a.host", usuarioSuporteResponsavel, protocoloCodigo.replace("_EMAIL", "")));
        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
        usuarioController.createOcorrenciaUsuario(null, null);

Esse objeto é a chave para conseguir as informações do usuário para ter referência 

Por que está sendo sugerido criar aqui, porque tem muitos locais que usam o SMSHelper, e teria que trocar em muitos locais, isso aumentaria a complexidade da tarefa podendo só trocar no send, só passar o responsavel no parâmetro que todo o sistema tem.

Outra coisa é se usasse o objeto AcessoSistema, colocar como parâmetro no método send do SMSHelper (padrão é chamar ele de responssavel)



A ocorrência vai ser registrada assim que o método send da classe SMSHelper terminar. 


Na minha tarefa, fala pra registrar a ocorrência, vai continuar registrando, mas registrando na tb_ocorrencia_usuario, so que o controle dessa ocorrência, vamos ter que fazer em outro local, pra não ter que toda que mandar um SMS ir no banco, fazer um count para descobrir se chegou no limite ou não. O que foi pensado, o controle é do sistema quando fazemos o controle do sistema, o consignante para nós ele representa um sistema. Existe no sistema uma tabela chamada tb_tipo_dado_adicional. 

Esta tb_tipo_dado_adicional é como se fosse uma tabela que as vezes querem criar campos para alguma entidade que ficaria de forma inviável liberar versão com alter table, por causa de um campo novo, por isso temos a tabela auxiliar.
Foi pensado: criar mais dois dados adicionais e esses dados adicionais, irão ser: 

SELECT * FROM tb_tipo_dado_adicional ttda ;
-- tb_tipo_dado_adicional
-- 1 Dado adicional com a data do mês corrente
-- 1 Dado adicional com o quantitativo de envios
-- CodedValues = TDA_ (criar 2 TDA com final "96" e "97")
-- tb_dados_consignante
-- Jan => Tem data no dado adicional? Não.
-- Jan = > 2026-01 - 1 dado adicional
-- Jan => 1 - outro dado adicional com quantitativo, ou seja 1 envio.

-- Jan => Tem data no dado adicional? Sim.
-- Jan => Data de envio é igual a data no dado adicional de data? Sim. Então contabiliza mais.
-- Jan = > 2026-01
-- Jan => 2

-- Fev => Tem data no dado adicional? Sim.
-- Fev => Data de envio é igual a data no dado adicional de data? Não. Então, atualiza o dado adicional para o mês corrente => 2026-02
-- Fev => 2026-02
-- Fev => 1

-- Quando for verificar, invés de dar um count para saber quantos tem, filtrando por data. No exemplo acima, em 1 SELECT vamos trazer os 2 campos, ai verifica se atingiu o limite ou não e atualiza as informações que devem ser atualizadas

Na tb_dados_consignante eu tenho CSE_CODIGO eo TDA_CODIGO (é o código do tipo dado) DAC_VALOR que é o valor do tipo dado, então 1 dado na tb_consignante vai ter a data e o outro dado vai ter o quantitativo que vai contando no mês.
Então ao mandar o primeiro SMS desse novo modelo, não tem dado adicional nem pra data e nem pelo quantitativo

OBS: Antes de enviar o SMS, a  tarefa pede para averiguar alguns limites, 
OBS2: A ocorrência do usuário vai ser criada lá, mas o quantitativo é aqui.
OBS3: pesquisa o dado adicional do consignante findDadoAdicionalConsignante
Criar o método de criar o dado adicional do consignante na ConsignanteControllerBean => Não chamamos a entidade home (DadosConsignanteHome) direto nas camadas, colocamos na camada de negócio no Bean e o nosso Bean é como se fosse o ServiceImpl da entidade. método create dentro do ConsignanteControllerBean . E dentro deste método create você irá chamar o DadosConsignanteHome 
 

Sobre onde guardar as informações da API do Zenvia, vamos guardar nos properties do projeto invés do banco
apiUrl: https://api.zenvia.com/v2/channels/sms/messages
apiToken: K8guNCbncrNofo62UjHeGWzMGEeiJhSSmXq3
fromNumber: econsign

Imputar dados no banco:
o eConsig tem um padrão para imputar dados no banco, econsig não tem o flyway nele porém tem um flyway modificado pela econsig. O que é feito: tem um controle de versionamento que fica em src/main/resources/db/0.0.0/onde colocamos todas alterações de modelo de dados, temos o ddl (quando tem alterações de modelo. CREATE, ALTER TABLE) e também tem o dml (quando tem alterações de modelo. INSERT, UPDATE). Então vai ser criado um dml com o padrão 

 o nome do arquivo fica como o modelo de data o nome do banco  a data e o número da tarefa. EX: dml_all_2026_01_28_DESENV_24832.sql


