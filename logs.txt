//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package br.com.experian.spring.security.config.service.impl;

import br.com.experian.spring.security.config.service.IamService;
import br.com.experian.spring.security.config.token.AbstractAuthentication;
import br.com.experian.spring.security.model.BearerToken;
import br.com.experian.spring.security.model.TokenKey;
import br.com.experian.spring.security.model.ValidateAuthorizationData;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Base64;
import java.util.Objects;
import java.util.Optional;
import lombok.Generated;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class IamServiceImpl implements IamService {
    @Generated
    private static final Logger log = LogManager.getLogger(IamServiceImpl.class);
    private static final String APPLICATION_JSON_CHARSET_UTF_8 = "application/json; charset=utf-8";
    private static final String AUTHORIZATION = "Authorization";
    private static final String CONTENT_TYPE = "Content-Type";
    private static final String VALIDATE_URL = "/product-accesses/validate-token";
    private static final String CLIENT_IDENTIFY = "/client-identities/identify";
    private static final String TOKEN_KEY = "/token-key";
    private static final String CLIENT_LOGIN = "/client-identities/login";
    private RestTemplate restTemplate = new RestTemplate();
    private final String iamUri;
    private final String clientId;
    private final String clientSecret;
    private BearerToken bearerToken;

    public IamServiceImpl(@Value("${api.iam.uri}") String iamUri, @Value("${api.iam.client.id}") String clientId, @Value("${api.iam.client.secret}") String clientSecret) {
        this.iamUri = iamUri;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
    }

    public Optional<TokenKey> findTokenKey(String clientId) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Content-Type", "application/json; charset=utf-8");
        HttpEntity<Void> entity = new HttpEntity(headers);
        String endpoint = "/token-key?clientId=" + clientId;

        try {
            ResponseEntity<TokenKey> response = this.restTemplate.exchange(new RequestEntity((Void)entity.getBody(), entity.getHeaders(), HttpMethod.GET, URI.create(String.format("%s%s", this.iamUri, endpoint))), TokenKey.class);
            return Optional.ofNullable((TokenKey)response.getBody());
        } catch (Exception e) {
            log.debug("An error occurred while finding token key:", e);
            return Optional.empty();
        }
    }

    public boolean validateToken(ValidateAuthorizationData validateAuthorizationData) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.set("Content-Type", "application/json; charset=utf-8");
            headers.set("Authorization", this.getAuthorizationHeader());
            HttpEntity<ValidateAuthorizationData> dataHttpEntity = new HttpEntity(validateAuthorizationData, headers);
            ResponseEntity<String> responseEntity = this.restTemplate.exchange(new RequestEntity((ValidateAuthorizationData)dataHttpEntity.getBody(), dataHttpEntity.getHeaders(), HttpMethod.POST, URI.create(String.format("%s%s", this.iamUri, "/product-accesses/validate-token"))), String.class);
            return responseEntity.getStatusCode().is2xxSuccessful();
        } catch (Exception var5) {
            return false;
        }
    }

    public BearerToken identifyClient(String clientId) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Content-Type", "application/json; charset=utf-8");
        HttpEntity<Void> entity = new HttpEntity((Object)null, headers);
        String endpoint = "/client-identities/identify?clientId=" + clientId;

        try {
            ResponseEntity<BearerToken> response = this.restTemplate.exchange(new RequestEntity((Void)entity.getBody(), entity.getHeaders(), HttpMethod.POST, URI.create(String.format("%s%s", this.iamUri, endpoint))), BearerToken.class);
            return (BearerToken)response.getBody();
        } catch (Exception var6) {
            return null;
        }
    }

    public Optional<String> getClientToken(String clientId, String clientSecret) {
        Optional<BearerToken> optionalBearerToken = this.loginClient(clientId, clientSecret);
        return optionalBearerToken.map((token) -> {
            String var10000 = token.getTokenType();
            return var10000 + " " + token.getAccessToken();
        });
    }

    public Optional<String> getClientToken() {
        if (!Objects.isNull(this.bearerToken) && !this.isLastTokenExpired()) {
            String var2 = this.bearerToken.getTokenType();
            return Optional.of(var2 + " " + this.bearerToken.getAccessToken());
        } else {
            Optional<BearerToken> optBearerToken = this.loginClient(this.clientId, this.clientSecret);
            if (optBearerToken.isPresent()) {
                this.bearerToken = (BearerToken)optBearerToken.get();
                String var10000 = this.bearerToken.getTokenType();
                return Optional.of(var10000 + " " + this.bearerToken.getAccessToken());
            } else {
                return Optional.empty();
            }
        }
    }

    public Optional<BearerToken> loginClient(String clientId, String clientSecret) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Content-Type", "application/json; charset=utf-8");
        headers.set("Authorization", this.generateBasicAuthentication(clientId, clientSecret));
        HttpEntity<Void> entity = new HttpEntity(headers);

        try {
            ResponseEntity<BearerToken> response = this.restTemplate.exchange(new RequestEntity((Void)entity.getBody(), entity.getHeaders(), HttpMethod.POST, URI.create(String.format("%s%s", this.iamUri, "/client-identities/login"))), BearerToken.class);
            return Optional.ofNullable((BearerToken)response.getBody());
        } catch (Exception var6) {
            return Optional.empty();
        }
    }

    private boolean isLastTokenExpired() {
        return Instant.now().isAfter(Instant.ofEpochSecond(Long.parseLong(this.bearerToken.getExpiresIn())).minusSeconds(120L));
    }

    private String generateBasicAuthentication(String clientId, String clientSecret) {
        String basicAuthenticationString = clientId + ":" + clientSecret;
        byte[] encode = Base64.getEncoder().encode(basicAuthenticationString.getBytes(StandardCharsets.UTF_8));
        String var10000 = new String(encode, StandardCharsets.UTF_8);
        return "Basic " + var10000;
    }

    private String getAuthorizationHeader() {
        return ((AbstractAuthentication)SecurityContextHolder.getContext().getAuthentication()).getAuthorizationHeader();
    }
}
