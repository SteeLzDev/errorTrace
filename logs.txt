@PostConstruct
    public void init() {
        log.info("ğŸ” DEBUG: AntecipaAuthAdapterDebug inicializado");
        log.info("ğŸ” DEBUG: Auth URL: {}", authUrl);
        log.info("ğŸ” DEBUG: Basic Auth Header: {}...", basicAuthHeader.substring(0, Math.min(20, basicAuthHeader.length())));
        log.info("ğŸ” DEBUG: RestTemplate class: {}", restTemplate.getClass().getSimpleName());
        log.info("ğŸ” DEBUG: RequestFactory class: {}", restTemplate.getRequestFactory().getClass().getSimpleName());
        
        // Decodificar e mostrar credenciais para debug
        try {
            String credentials = new String(java.util.Base64.getDecoder().decode(basicAuth));
            String[] parts = credentials.split(":");
            if (parts.length == 2) {
                log.info("ğŸ” DEBUG: Client ID: {}", parts[0]);
                log.info("ğŸ” DEBUG: Client Secret: {}...", parts[1].substring(0, Math.min(8, parts[1].length())));
            }
        } catch (Exception e) {
            log.warn("ğŸ” DEBUG: NÃ£o foi possÃ­vel decodificar credenciais para debug", e);
        }
    }

    @Override
    public String getValidToken() {
        log.info("ğŸ” DEBUG: Solicitando token vÃ¡lido...");
        
        if (isTokenValid()) {
            log.info("ğŸ” DEBUG: âœ… Token atual ainda Ã© vÃ¡lido atÃ©: {}", 
                tokenExpiry.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
            return currentToken;
        }
        
        log.info("ğŸ” DEBUG: Token invÃ¡lido ou expirado, renovando...");
        return refreshToken();
    }

    @Override
    public String refreshToken() {
        log.info("ğŸ” DEBUG: Renovando token de autenticaÃ§Ã£o...");
        
        try {
            AuthenticationResponseDto response = performAuthentication();
            
            this.currentToken = response.getAccessToken();
            // Token vÃ¡lido por 1 hora (padrÃ£o) menos 5 minutos de margem
            this.tokenExpiry = LocalDateTime.now().plusMinutes(55);
            
            log.info("ğŸ” DEBUG: âœ… Token renovado com sucesso!");
            log.info("ğŸ” DEBUG: Token expira em: {}", tokenExpiry.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
            log.info("ğŸ” DEBUG: Token (primeiros 20 chars): {}...", 
                currentToken.substring(0, Math.min(20, currentToken.length())));
            
            return currentToken;
            
        } catch (Exception e) {
            log.error("ğŸ” DEBUG: âŒ Erro ao renovar token de autenticaÃ§Ã£o", e);
            throw new AuthenticationException("Falha na autenticaÃ§Ã£o com API Antecipa", e);
        }
    }

    @Override
    public boolean isTokenValid() {
        return isCurrentTokenValid();
    }

    private AuthenticationResponseDto performAuthentication() {
        log.info("ğŸ” DEBUG: Realizando POST para: {}", authUrl);
        log.info("ğŸ” DEBUG: Verificando se Ã© HTTPS: {}", authUrl.startsWith("https"));
        log.info("ğŸ” DEBUG: Usando RestTemplate customizado com SSL bypass");
        
        // Preparar headers
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("Authorization", basicAuthHeader);
        headers.set("User-Agent", "Experian-BFM-Debug/1.0");
        headers.set("Accept", "application/json");
        headers.set("Cache-Control", "no-cache");
        
        log.info("ğŸ” DEBUG: Headers configurados:");
        log.info("ğŸ” DEBUG:   - Content-Type: {}", headers.getContentType());
        log.info("ğŸ” DEBUG:   - Authorization: {}...", basicAuthHeader.substring(0, Math.min(30, basicAuthHeader.length())));
        log.info("ğŸ” DEBUG:   - User-Agent: {}", headers.get("User-Agent"));
        
        // Preparar request entity (sem body para Basic Auth)
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        
        log.info("ğŸ” DEBUG: Enviando requisiÃ§Ã£o POST...");
        log.info("ğŸ” DEBUG: RequestFactory: {}", restTemplate.getRequestFactory().getClass().getSimpleName());
        
        try {
            long startTime = System.currentTimeMillis();
            
            ResponseEntity<String> response = restTemplate.exchange(
                authUrl,
                HttpMethod.POST,
                requestEntity,
                String.class
            );
            
            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;
            
            log.info("ğŸ” DEBUG: âœ… Resposta recebida em {}ms!", duration);
            log.info("ğŸ” DEBUG: Status: {}", response.getStatusCode());
            log.info("ğŸ” DEBUG: Headers de resposta: {}", response.getHeaders());
            
            String responseBody = response.getBody();
            log.info("ğŸ” DEBUG: Body length: {}", responseBody != null ? responseBody.length() : 0);
            log.info("ğŸ” DEBUG: Body content: {}", responseBody);
            
            if (responseBody == null || responseBody.trim().isEmpty()) {
                throw new AuthenticationException("Resposta vazia da API de autenticaÃ§Ã£o");
            }
            
            return parseAuthenticationResponse(responseBody);
            
        } catch (Exception e) {
            log.error("ğŸ” DEBUG: âŒ Erro na chamada de autenticaÃ§Ã£o", e);
            
            if (e.getMessage().contains("SSL") || e.getMessage().contains("certificate") || e.getMessage().contains("X509TrustManager")) {
                log.error("ğŸ” DEBUG: âŒ ERRO SSL DETECTADO - SSL nÃ£o foi desabilitado corretamente");
                log.error("ğŸ” DEBUG: âŒ Tipo do erro: {}", e.getClass().getSimpleName());
                log.error("ğŸ” DEBUG: âŒ Mensagem: {}", e.getMessage());
                log.error("ğŸ” DEBUG: âŒ Verificar se CustomHttpRequestFactory estÃ¡ sendo usada");
            }
            
            if (e.getMessage().contains("401") || e.getMessage().contains("403")) {
                log.error("ğŸ” DEBUG: âŒ ERRO DE CREDENCIAIS - Verificar Basic Auth");
                log.error("ğŸ” DEBUG: âŒ Basic Auth usado: {}...", basicAuthHeader.substring(0, Math.min(50, basicAuthHeader.length())));
            }
            
            if (e.getMessage().contains("timeout") || e.getMessage().contains("connect")) {
                log.error("ğŸ” DEBUG: âŒ ERRO DE CONECTIVIDADE - Verificar rede/firewall");
            }
            
            throw new AuthenticationException("Erro na comunicaÃ§Ã£o com serviÃ§o de autenticaÃ§Ã£o", e);
        }
    }

    private AuthenticationResponseDto parseAuthenticationResponse(String responseBody) {
        log.info("ğŸ” DEBUG: Fazendo parse da resposta de autenticaÃ§Ã£o...");
        
        try {
            JsonNode jsonNode = objectMapper.readTree(responseBody);
            log.info("ğŸ” DEBUG: JSON parseado com sucesso");
            
            // Listar todos os campos disponÃ­veis
            log.info("ğŸ” DEBUG: Campos disponÃ­veis na resposta:");
            jsonNode.fieldNames().forEachRemaining(field -> 
                log.info("ğŸ” DEBUG:   - {}: {}", field, jsonNode.get(field).asText())
            );
            
            // Tentar diferentes campos possÃ­veis para o token
            String accessToken = null;
            String tokenType = "Bearer";
            Integer expiresIn = 3600;
            
            if (jsonNode.has("access_token")) {
                accessToken = jsonNode.get("access_token").asText();
                log.info("ğŸ” DEBUG: Token encontrado no campo 'access_token'");
            } else if (jsonNode.has("accessToken")) {
                accessToken = jsonNode.get("accessToken").asText();
                log.info("ğŸ” DEBUG: Token encontrado no campo 'accessToken'");
            } else if (jsonNode.has("token")) {
                accessToken = jsonNode.get("token").asText();
                log.info("ğŸ” DEBUG: Token encontrado no campo 'token'");
            } else {
                log.error("ğŸ” DEBUG: âŒ Token nÃ£o encontrado na resposta");
                throw new AuthenticationException("Token nÃ£o encontrado na resposta da API");
            }
            
            if (jsonNode.has("token_type")) {
                tokenType = jsonNode.get("token_type").asText();
            } else if (jsonNode.has("tokenType")) {
                tokenType = jsonNode.get("tokenType").asText();
            }
            
            if (jsonNode.has("expires_in")) {
                expiresIn = jsonNode.get("expires_in").asInt();
            } else if (jsonNode.has("expiresIn")) {
                expiresIn = jsonNode.get("expiresIn").asInt();
            }
            
            if (accessToken == null || accessToken.trim().isEmpty()) {
                throw new AuthenticationException("Token vazio retornado pela API");
            }
            
            log.info("ğŸ” DEBUG: âœ… Token extraÃ­do com sucesso!");
            log.info("ğŸ” DEBUG: Token length: {}", accessToken.length());
            log.info("ğŸ” DEBUG: Token type: {}", tokenType);
            log.info("ğŸ” DEBUG: Expires in: {} segundos", expiresIn);
            log.info("ğŸ” DEBUG: Token preview: {}...", accessToken.substring(0, Math.min(30, accessToken.length())));
            
            return new AuthenticationResponseDto(accessToken, tokenType, expiresIn);
            
        } catch (Exception e) {
            log.error("ğŸ” DEBUG: âŒ Erro ao fazer parse da resposta", e);
            throw new AuthenticationException("Erro ao processar resposta de autenticaÃ§Ã£o", e);
        }
    }

    private boolean isCurrentTokenValid() {
        if (currentToken == null || currentToken.trim().isEmpty()) {
            log.debug("ğŸ” DEBUG: Token Ã© null ou vazio");
            return false;
        }
        
        if (tokenExpiry == null) {
            log.debug("ğŸ” DEBUG: Data de expiraÃ§Ã£o Ã© null");
            return false;
        }
        
        boolean valid = LocalDateTime.now().isBefore(tokenExpiry);
        log.debug("ğŸ” DEBUG: Token vÃ¡lido: {} (expira em: {})", valid, tokenExpiry);
        
        return valid;
    }
