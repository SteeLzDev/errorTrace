package com.zetra.econsig.helper.sms;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.zetra.econsig.dto.CustomTransferObject;
import com.zetra.econsig.dto.entidade.OcorrenciaUsuarioTransferObject;
import com.zetra.econsig.exception.FindException;
import com.zetra.econsig.exception.UpdateException;
import com.zetra.econsig.exception.ViewHelperException;
import com.zetra.econsig.exception.ZetraException;

import com.zetra.econsig.helper.email.MailHelper;
import com.zetra.econsig.helper.email.modelo.ModeloEmailInterpolator;
import com.zetra.econsig.helper.parametro.ParamSist;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.helper.sms.request.SmsRequest;
import com.zetra.econsig.helper.texto.DateHelper;
import com.zetra.econsig.helper.texto.TextHelper;
import com.zetra.econsig.persistence.entity.*;
import com.zetra.econsig.service.usuario.UsuarioController;
import com.zetra.econsig.values.CodedValues;
import com.zetra.econsig.values.ModeloEmailEnum;
import com.zetra.econsig.web.ApplicationContextProvider;
import jakarta.mail.MessagingException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.http.*;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * <p>Title: SMSHelper</p>
 * <p>Description: Classe auxiliar para envio de SMS (Migrado para Zenvia)</p>
 * Registra ocorrência em tb_ocorrencia_usuario (TOC_ENVIO_SMS = 261)
 * e controla quantitativo mensal em tb_dados_consignante (TDA = 96 e TDA = 97)
 * implementa verificacão de limites  (TPC 1017/1018)
 * <p>Copyright: Copyright (c) 2006</p>
 * <p>Company: Zetrasoft</p>
 * $Author$
 * $Revision$
 * $Date$
 */

public class SMSHelper {

    private static final Log LOG = LogFactory.getLog(SMSHelper.class);

    private static final String DATE_FORMAT_MES_ANO = "yyyy-MM";

    private final String apiUrl;
    private final String apiToken;
    private final String fromNumber;

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;

    /**
     * Construtor com injeção de configurações
     *
     * @param apiUrl     URL da API da Zenvia
     * @param apiToken   Token de Autenticação da API
     * @param fromNumber Remetente configurado
     */
    public SMSHelper(String apiUrl, String apiToken, String fromNumber) {
        this.apiUrl = apiUrl;
        this.apiToken = apiToken;
        this.fromNumber = fromNumber;

        //Configuracão do manual do RestTemplate com timeouts para evitar travamentos
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(5000); // 5 segundos
        factory.setReadTimeout(10000);    // 10 segundos
        this.restTemplate = new RestTemplate(factory);
        this.objectMapper = new ObjectMapper();
    }

    /**
     * Envia SMS utilizando o serviço da Zenvia
     * Verifica limites de envio antes de enviar, ocorrência para o usuário  e atualiza o controle de quantitativo mensal.
     *
     * @param to   Número do destino (telefone do servidor/destinatário)
     */

    public final void send (String to, String conteudo, AcessoSistema responsavel) throws ZetraException {
        LOG.debug("Iniciando envio SMS Zenvia: " + DateHelper.getSystemDatetime());

        try {
            if (responsavel == null || TextHelper.isNull(responsavel.getCseCodigo())) {
                LOG.warn("Responsável ou cseCodigo nulo - enviando SMS sem controle de limites");
                executarEnvioSms(to, conteudo);
                LOG.debug("FIm envio SMS Zenvia (sem controle): " + DateHelper.getSystemDatetime());
                return;
            }
            String cseCodigo = responsavel.getCseCodigo();
            ;
            int qtdEnviadosNoMes = getQuantidadeSmsNoMes(cseCodigo);
            int limiteInferior = getLimiteInferior(responsavel);
            int limiteSuperior = getLimiteSuperior(responsavel);

            if (qtdEnviadosNoMes >= limiteSuperior) {
                if (!jaEnviouAlerteLimiteSuperior(cseCodigo)) {
                    enviarEmailAlerteLimiteSuperior(qtdEnviadosNoMes, limiteSuperior, responsavel);

                    marcarAlertaLimiteSuperiorEnviado(cseCodigo);
                }
                throw ZetraException.byMessage("Limite de  envio de SMS atingido (" + limiteSuperior + ")." + "Envio bloqueado");
            }

            executarEnvioSms(to, conteudo);

            registrarOcorrenciaUsuario(to, conteudo, responsavel);

            atualizarQuantitativoSms(responsavel);

            int novaQtd = qtdEnviadosNoMes + 1;
            if (novaQtd >= limiteInferior && novaQtd < limiteSuperior) {
                if (!jaEnviouAlerteLimiteInferior(cseCodigo)) {
                    enviarEmailAlerteLimiteInferior(novaQtd, limiteInferior, limiteSuperior, responsavel);

                    marcarAlertaLimiteInferiorEnviado(cseCodigo);
                }
            }
        } catch (ZetraException ex) {
            throw  ex;

        } catch (Exception ex) {
            LOG.error("Erro no envio de SMS: " + ex.getMessage(), ex);
            throw ZetraException.byMessage(ex.getMessage(), ex);
        }

        LOG.debug("FIm envio SMS Zenvia: " + DateHelper.getSystemDatetime());
    }

    /**
     * Executa o envio do SMS via API Zenvia
     * Método extraído para reutilização (com e sem controle de limites)
     * @param to Número de destino
     * @param conteudo Texto da Mensagem
     * @throws Exception em caso de erro no envio
     */

    private void executarEnvioSms(String to, String conteudo) throws Exception {
        SmsRequest smsRequest =  new SmsRequest(this.fromNumber, to, conteudo);
        String jsonBody = objectMapper.writeValueAsString(smsRequest);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("X-API-TOKEN", this.apiToken);

        HttpEntity<String> entity = new HttpEntity<>(jsonBody, headers);

        ResponseEntity<String> response = restTemplate.exchange(
                this.apiUrl,
                HttpMethod.POST,
                entity,
                String.class
        );
        if (!response.getStatusCode().is2xxSuccessful()) {
            throw new Exception("Erro no envio de SMS. Código HTTP: " + response.getStatusCode() + " - Body: " +  response.getBody());
        }

    }

    /**
     * Obtém o limite inferior de envio de SMS por mês do parametro de sistema.
     *
     * @param responsavel Objeto AcessoSistema
     * @param return Limite inferior configurado, ou Integer.MAX_VALUE se não configurado
     */
    private int getLimiteInferior(AcessoSistema responsavel) {
        try {
            Object param = ParamSist.getInstance().getParam(CodedValues.TPC_LIMITE_INFERIOR_ENVIO_SMS_MES, responsavel);
            if (param != null && !TextHelper.isNull(param.toString())) {
                return Integer.parseInt(param.toString());
            }
        } catch (Exception ex) {
            LOG.warn("Erro ao obter limite inferior de SMS: " + ex.getMessage());
        }
         return Integer.MAX_VALUE;
    }

    /**
     * Obtém o limite superior de envio de SMS por mês do parametro de sistema.
     *
     * @param responsavel Objeto AcessoSistema
     * @param return Limite superior configurado, ou Integer.MAX_VALUE se não configurado
     */

    private int getLimiteSuperior(AcessoSistema responsavel) {
        try {
            Object param = ParamSist.getInstance().getParam(CodedValues.TPC_LIMITE_SUPERIOR_ENVIO_SMS_MES, responsavel);
            if (param != null && !TextHelper.isNull(param.toString())) {
                return Integer.parseInt(param.toString());
            }
        } catch (Exception ex) {
            LOG.warn("Erro ao obter limite superior de SMS: " + ex.getMessage());
        }
         return Integer.MAX_VALUE;
        }

    /**
     * Envia e-mail de alerta informando que o limite inferior de SMS foi atingido.
     * O e-mail é enviado para o endereço configurado no parametro de sistema TPC_EMAIL_SUPORTE_ZETRASOFT (207)
     * @param qtdEnviados Quantidade de SMS enviados no mês
     * @param limiteInferior Limite inferior configurado
     * @param limiteSuperior Limite superior configurado
     * @param responsavel Objeto AcessoSistema
     */
    private void enviarEmailAlerteLimiteInferior(int qtdEnviados, int limiteInferior, int limiteSuperior, AcessoSistema responsavel) {
        try {
            String emailSuporte = getEmailSuporte(responsavel);
            if (TextHelper.isNull(emailSuporte)) {
                LOG.warn("E-mail de suporte não configurado. Alerta de limite inferior não enviado.");
                return;
            }
            ModeloEmail modeloEmail = ModeloEmailHome.findByPrimaryKey(
                    ModeloEmailEnum.ENVIAR_EMAIL_LIMITE_INFERIOR_SMS_ATINGIDO.getCodigo());

            CustomTransferObject dados = new CustomTransferObject();
            dados.setAttribute("qtd_sms_enviados", String.valueOf(qtdEnviados));
            dados.setAttribute("limite_inferior", String.valueOf(limiteInferior));
            dados.setAttribute("limite_superior", String.valueOf(limiteSuperior));

            ModeloEmailInterpolator interpolator = new ModeloEmailInterpolator(modeloEmail, responsavel);
            interpolator.setDados(dados);

            String titulo = interpolator.interpolateTitulo();
            String corpo = interpolator.interpolateTexto();

            new MailHelper().send(emailSuporte, null, null, titulo, corpo, null);
            LOG.info("E-mail de alerta de limite inferior enviado para: " + emailSuporte);
        } catch (FindException | ViewHelperException | MessagingException ex) {
            LOG.error("Erro ao enviar e-mail de alerta de limite inferior: " + ex.getMessage(), ex);
        }

    }
    /**
     * Envia e-mail de alerta informando que o limite superiopr de SMS foi atingido (bloqueio de envios).
     * O E-mail é enviado para o endereço configurado no parametro de sistema TPC_EMAIL_SUPORTE_ZETRASOFT (207)
     *
     * @param qtdEnviados Quantidade de SMS enviados no mês
     * @param limiteSuperior Limite superior configurado
     * @param responsavel Objeto AcessoSistema
     */

    private void enviarEmailAlerteLimiteSuperior(int qtdEnviados, int limiteSuperior, AcessoSistema responsavel) {
        try {
            String emailSuporte = getEmailSuporte(responsavel);
            if (TextHelper.isNull(emailSuporte)) {
                LOG.warn("E-mail de suporte não configurado. Alerta de limite superior não enviado.");
                return;
            }
            ModeloEmail modeloEmail = ModeloEmailHome.findByPrimaryKey(
                    ModeloEmailEnum.ENVIAR_EMAIL_LIMITE_SUPERIOR_SMS_ATINGIDO.getCodigo());

            CustomTransferObject dados = new CustomTransferObject();
            dados.setAttribute("qtd_sms_enviados", String.valueOf(qtdEnviados));
            dados.setAttribute("limite_superior", String.valueOf(limiteSuperior));

            ModeloEmailInterpolator interpolator = new ModeloEmailInterpolator(modeloEmail, responsavel);
            interpolator.setDados(dados);

            String titulo = interpolator.interpolateTitulo();
            String corpo = interpolator.interpolateTexto();

            new MailHelper().send(emailSuporte, null, null, titulo, corpo, null);
            LOG.info("E-mail de alerta de limite superior enviado para: " + emailSuporte);
        } catch (FindException | ViewHelperException | MessagingException ex) {
            LOG.error("Erro ao enviar e-mail de alerta de limite superior: " + ex.getMessage(), ex);
        }
    }

    /**
     * Obtém o e-mail de suporte configurado no parametro de sistema TPC_EMAIL_SUPORTE_ZETRASOFT (207)
     *
     * @param responsavel Objeto AcessoSistema
     * @return E-mail de suporte ou null se não configurado
     */

    private String getEmailSuporte(AcessoSistema responsavel) {
        try {
            Object param = ParamSist.getInstance().getParam(CodedValues.TPC_EMAIL_SUPORTE_ZETRASOFT, responsavel);
            if (param != null && !TextHelper.isNull(param.toString())) {
                return param.toString();
            }
        } catch (Exception ex) {
            LOG.warn("Erro ao obter e-mail de suporte: " + ex.getMessage());
        }
        return null;
    }



    /**
     * Registra ocorrência de envio de SMS na tabela tb_ocorrencia_usuario
     * Utiliza o tipo de ocorrencia TOC_ENVIO_SMS (261)
     * registro é feito para o usuário responsável pela operaçao (usuário logado)
     */
    private void registrarOcorrenciaUsuario(String telefoneDestino, String conteudo, AcessoSistema responsavel) {
        try {
            if (responsavel == null || TextHelper.isNull(responsavel.getUsuCodigo())) {
                LOG.warn("Não foi possível registrar ocorrência SMS: responsavel ou usuCodigo nulo");
                return;
            }

            UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext()
                    .getBean(UsuarioController.class);

            OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setTocCodigo(CodedValues.TOC_ENVIO_SMS);
            ocorrencia.setOusObs("SMS enviado para: " + telefoneDestino);
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

            usuarioController.createOcorrenciaUsuario(ocorrencia, responsavel);

            LOG.debug("Ocorrência de envio SMS registrada para usuário: " +  responsavel.getUsuCodigo());
        } catch (Exception ex) {
            LOG.warn("Erro ao registrar ocorrencia de SMS: " + ex.getMessage(), ex);
        }
    }

    /**
     *Atualiza o controle de quantitativo de SMS  mensal em tb_dados_consignante.
     * Utiliza dois dados adicionais
     * - TDA_DATA_MES_ENVIO_SMS (96): Armazena o mês/ano corrente (yyyy-MM)
     * - TDA_QTD_ENVIOS_SMS_MES (97): Armazena a quantidade de SMS enviados no mês
     *
     * Lógica:
     * -Se não existir dado adicional de data, cria ambos (data e qtd=1)
     * -Se existir e for do mes corrente, incrementa a quantidade
     * -Se existir e for de outro mês, reinicia para o mês corrente com qtd=1
     *
     * @param responsavel Objeto AcessoSistema com cseCodigo do consignante
     */

    private void atualizarQuantitativoSms(AcessoSistema responsavel) {
        try {
            if (responsavel == null || TextHelper.isNull(responsavel.getCseCodigo())) {
                LOG.warn("Não foi possível atualizar quantitativo SMS: responsavel ou cseCodigoNulo");
                return;
            }
            String cseCodigo = responsavel.getCseCodigo();
            String mesAnoAtual = new SimpleDateFormat(DATE_FORMAT_MES_ANO).format(new Date());

            DadosConsignante dadoData = findDadoAdicional(cseCodigo, CodedValues.TDA_DATA_MES_ENVIO_SMS);
            DadosConsignante dadoQtd = findDadoAdicional(cseCodigo, CodedValues.TDA_QTD_ENVIOS_SMS_MES);

            if (dadoData == null) {
                DadosConsignanteHome.create(cseCodigo, CodedValues.TDA_DATA_MES_ENVIO_SMS, mesAnoAtual);
                DadosConsignanteHome.create(cseCodigo, CodedValues.TDA_QTD_ENVIOS_SMS_MES, "1");
                LOG.debug("Criados dados adicionais de SMS para consignante: " + cseCodigo);

            } else if (mesAnoAtual.equals(dadoData.getDacValor())) {
                int qtdAtual = dadoQtd != null ? Integer.parseInt(dadoQtd.getDacValor()) : 0;
                int novaQtd = qtdAtual + 1;

                if (dadoQtd != null) {
                    dadoQtd.setDacValor(String.valueOf(novaQtd));
                    persistirDadoAdicional(dadoQtd);
                } else {
                    DadosConsignanteHome.create(cseCodigo, CodedValues.TDA_QTD_ENVIOS_SMS_MES, String.valueOf(novaQtd));
                }
                LOG.debug("Quantitativo SMS atualizado para: " + novaQtd + "(consignante: " + cseCodigo +")");
            } else {
                dadoData.setDacValor(mesAnoAtual);
                persistirDadoAdicional(dadoData);

                if (dadoQtd != null) {
                    dadoQtd.setDacValor("1");
                    persistirDadoAdicional(dadoQtd);
                } else {
                    DadosConsignanteHome.create(cseCodigo, CodedValues.TDA_QTD_ENVIOS_SMS_MES, "1");
                }
                LOG.debug("Mês resetado para " + mesAnoAtual + "com quantitativos 1 (consignante: " + cseCodigo + ")");
            }
        } catch (Exception ex) {
            LOG.error("Erro ao atualizar quantitativo de SMS " + ex.getMessage(), ex);
        }

    }

    /**
     * Persiste as alteracoes de um dado adicional no banco de dados
     *
     * @param dado DadosConsignante a ser persistido
     */

    private void persistirDadoAdicional(DadosConsignante dado) {
        try {
            AbstractEntityHome.update(dado);
        } catch (UpdateException ex) {
            LOG.error("Erro ao persistir dado adicional: " + ex.getMessage(), ex);
        }
    }

    /**
     * Busca um dado adicional do consignante pela chave primária composta
     *
     * @param cseCodigo Código do consignante
     * @param tdaCodigo Código do tipo de dado adicional
     * @return DadosConsignante encontrado ou null se não existir
     */

    private DadosConsignante findDadoAdicional (String cseCodigo, String tdaCodigo) {
        try {
            DadosConsignanteId id = new DadosConsignanteId(cseCodigo, tdaCodigo);
            return DadosConsignanteHome.findByPrimaryKey(id);
        } catch (Exception ex) {
            return null;
        }
    }

    /**
     * Verifica se já foi enviado o alerta de limite inferior no mês corrente
     * Usa o dado adicional TDA 98 para armazenar a flag (valor = mês/ano do último alerta).
     * @param cseCodigo Código do consignante
     * @return true se já foi enviado o alerta no mês corrente, false caso contrário
     */
    private boolean jaEnviouAlerteLimiteInferior(String cseCodigo) {
        if (TextHelper.isNull(cseCodigo)) {
            return false;
        }
        try {
            String mesAnoAtual = new SimpleDateFormat(DATE_FORMAT_MES_ANO).format(new Date());
            DadosConsignante dado = findDadoAdicional(cseCodigo, CodedValues.TDA_ALERTA_LIMITE_INF_SMS);
            return dado != null && mesAnoAtual.equals(dado.getDacValor());
        } catch (Exception ex) {
            return false;
        }
    }

    /**
     * Verifica se já foi enviado o alerta de limite superior no mês corrente
     * Usa o dado adicional TDA 99 para armazenar a flag (valor = mês/ano do último alerta).
     *
     * @param cseCodigo Código do consignante
     * @return true se já foi enviado o alerta no mês corrente, false caso contrário
     */
    private boolean jaEnviouAlerteLimiteSuperior(String cseCodigo) {
        if (TextHelper.isNull(cseCodigo)) {
            return false;
        }
        try {
            String mesAnoAtual = new SimpleDateFormat(DATE_FORMAT_MES_ANO).format(new Date());
            DadosConsignante dado = findDadoAdicional(cseCodigo, CodedValues.TDA_ALERTA_LIMITE_SUP_SMS);
            return dado != null && mesAnoAtual.equals(dado.getDacValor());
        } catch (Exception ex) {
            return false;
        }
    }

    /**
     * Marca que o alerta de limite superior (bloqueio) foi enviado no mês corrente
     *
     * @param cseCodigo Código do consignante
     */

    private void marcarAlertaLimiteSuperiorEnviado(String cseCodigo) {
        if (TextHelper.isNull(cseCodigo)) {
            return;
        }
        try {
            String mesAnoAtual = new SimpleDateFormat(DATE_FORMAT_MES_ANO).format(new Date());
            DadosConsignante dado = findDadoAdicional(cseCodigo, CodedValues.TDA_ALERTA_LIMITE_SUP_SMS);
            if (dado == null) {
                DadosConsignanteHome.create(cseCodigo, CodedValues.TDA_ALERTA_LIMITE_INF_SMS, mesAnoAtual);
            } else {
                dado.setDacValor(mesAnoAtual);
                persistirDadoAdicional(dado);
            }
        } catch (Exception ex) {
            LOG.error("Erro ao marcar alerta de limite superior enviado: " + ex.getMessage(), ex);
        }
    }

    /**
     * Marca que o alerta de limite superior (bloqueio) foi enviado no mês corrente
     *
     * @param cseCodigo Código do consignante
     */

    private void marcarAlertaLimiteInferiorEnviado(String cseCodigo) {
        if (TextHelper.isNull(cseCodigo)) {
            return;
        }
        try {
            String mesAnoAtual = new SimpleDateFormat(DATE_FORMAT_MES_ANO).format(new Date());
            DadosConsignante dado = findDadoAdicional(cseCodigo, CodedValues.TDA_ALERTA_LIMITE_INF_SMS);
            if (dado != null) {
                dado.setDacValor(mesAnoAtual);
                persistirDadoAdicional(dado);
            } else {
                DadosConsignanteHome.create(cseCodigo, CodedValues.TDA_ALERTA_LIMITE_INF_SMS, mesAnoAtual);
            }
            return;
        } catch (Exception ex) {
            return;
        }
    }


        /**
         * Obtém a quantidade de SMS enviados no mês corrente para um consignante
         * Útil para verificar limites antes do envio.
         *
         * @param cseCodigo Código do consignante
         * @return Quantidade de SMS enviados no mês corrente, ou  0 se não houver registro
         */

    public int getQuantidadeSmsNoMes(String cseCodigo) {
        try {
            String mesAnoAtual = new SimpleDateFormat(DATE_FORMAT_MES_ANO).format(new Date());
            DadosConsignante dadoData = findDadoAdicional(cseCodigo, CodedValues.TDA_DATA_MES_ENVIO_SMS);
            if (dadoData == null || !mesAnoAtual.equals(dadoData.getDacValor())) {
                return 0;
            }

            DadosConsignante dadoQtd = findDadoAdicional(cseCodigo, CodedValues.TDA_QTD_ENVIOS_SMS_MES);
            if (dadoQtd != null && !TextHelper.isNull(dadoQtd.getDacValor())) {
                return Integer.parseInt(dadoQtd.getDacValor());
            }
            return 0;
        } catch (Exception ex) {
            LOG.error("Erro ao obter quantidade de SMS no mês: " + ex.getMessage(), ex);
            return 0;
        }
    }

}

