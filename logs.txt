package br.com.experian.buzz.infrastructure.adapter;

import br.com.experian.buzz.domain.dto.AuthenticationResponseDto;
import br.com.experian.buzz.domain.port.AuthenticationPort;
import br.com.experian.buzz.exception.AuthenticationException;
import br.com.experian.buzz.infrastructure.integration.feign.client.auth.AntecipaAuthClient;
import feign.FeignException;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.concurrent.locks.ReentrantLock;

/**
 * üîß Adapter de autentica√ß√£o com DEBUG detalhado.
 * 
 * Vers√£o especial para debugging com logs extensivos e bypass SSL.
 */
@Component
@Profile("debug")
public class AntecipaAuthAdapterDebug implements AuthenticationPort {

    private static final Logger log = LoggerFactory.getLogger(AntecipaAuthAdapterDebug.class);

    private final AntecipaAuthClient authClient;
    private final String basicAuthCredentials;
    private final ReentrantLock lock = new ReentrantLock();

    @Autowired
    private RestTemplate restTemplate;

    // Cache do token atual
    private volatile AuthenticationResponseDto currentToken;

    public AntecipaAuthAdapterDebug(
            AntecipaAuthClient authClient,
            @Value("${api.antecipa.auth.basic:MjM2Y2VhOGEtNzBlMS03MGMzLWM1OGQtODRiMTFmNTI3NmNhOjI5NGZmMzAwLTIyMTAtNDU3YS1iODIyLWJkNGM1ZDIwY2ZmZA==}") String basicAuth) {
        this.authClient = authClient;
        this.basicAuthCredentials = basicAuth;
        log.info("üîß AntecipaAuthAdapterDebug inicializado");
    }

    @PostConstruct
    public void init() {
        try {
            log.info("üîß Inicializando AntecipaAuthAdapterDebug...");
            
            // Decodifica e exibe credenciais (apenas para debug)
            String credentials = new String(java.util.Base64.getDecoder().decode(basicAuthCredentials));
            String[] parts = credentials.split(":");
            log.info("üîë Client ID: {}", parts.length > 0 ? parts[0] : "N/A");
            log.info("üîë Client Secret: {}***", parts.length > 1 ? parts[1].substring(0, Math.min(8, parts[1].length())) : "N/A");
            
            log.info("üåê RestTemplate configurado: {}", restTemplate.getClass().getSimpleName());
            log.info("‚úÖ AntecipaAuthAdapterDebug inicializado com sucesso");
            
        } catch (Exception e) {
            log.error("‚ùå Erro na inicializa√ß√£o do AntecipaAuthAdapterDebug", e);
        }
    }

    @Override
    public String getValidToken() {
        log.debug("üîç Verificando token v√°lido...");
        
        // Verifica√ß√£o r√°pida sem lock
        if (isCurrentTokenValid()) {
            log.debug("‚úÖ Token atual ainda √© v√°lido");
            return currentToken.getAccessToken();
        }

        // Verifica√ß√£o com lock para thread safety
        lock.lock();
        try {
            log.debug("üîí Lock adquirido para verifica√ß√£o de token");
            
            // Double-check: outro thread pode ter renovado
            if (isCurrentTokenValid()) {
                log.debug("‚úÖ Token foi renovado por outro thread");
                return currentToken.getAccessToken();
            }

            log.info("üîÑ Token inv√°lido ou expirado, renovando...");
            return refreshToken();

        } finally {
            lock.unlock();
            log.debug("üîì Lock liberado");
        }
    }

    @Override
    public String refreshToken() {
        lock.lock();
        try {
            log.info("üîÑ Iniciando renova√ß√£o de token...");

            AuthenticationResponseDto newToken = performAuthentication();
            this.currentToken = newToken;

            log.info("‚úÖ Token renovado com sucesso!");
            log.info("üìä Token type: {}", newToken.getTokenType());
            log.info("‚è∞ Expira em: {} segundos", newToken.getExpiresIn());
            log.info("üéØ Scope: {}", newToken.getScope());
            
            return newToken.getAccessToken();

        } catch (Exception e) {
            log.error("‚ùå Erro ao renovar token de autentica√ß√£o", e);
            throw new AuthenticationException("Falha na autentica√ß√£o com API Antecipa", e);
        } finally {
            lock.unlock();
        }
    }

    @Override
    public boolean isTokenValid() {
        boolean valid = isCurrentTokenValid();
        log.debug("üîç Token v√°lido: {}", valid);
        return valid;
    }

    /**
     * üîí Realiza chamada de autentica√ß√£o na API com logs detalhados.
     */
    private AuthenticationResponseDto performAuthentication() {
        try {
            log.info("üåê Realizando signin na API de autentica√ß√£o...");
            log.debug("üîó URL base do cliente: {}", authClient.getClass().getSimpleName());
            
            String authHeader = "Basic " + basicAuthCredentials;
            log.debug("üîë Authorization header preparado");
            
            AuthenticationResponseDto response = authClient.signin(authHeader);
            
            if (response == null) {
                log.error("‚ùå Resposta de autentica√ß√£o √© null");
                throw new AuthenticationException("Resposta de autentica√ß√£o √© null");
            }
            
            if (response.getAccessToken() == null) {
                log.error("‚ùå Access token na resposta √© null");
                throw new AuthenticationException("Access token na resposta √© null");
            }

            log.info("‚úÖ Autentica√ß√£o realizada com sucesso!");
            log.debug("üìä Resposta completa: {}", response);
            
            return response;

        } catch (FeignException e) {
            log.error("‚ùå Erro Feign na chamada de autentica√ß√£o");
            log.error("üìä Status: {}", e.status());
            log.error("üìÑ Body: {}", e.contentUTF8());
            log.error("üîó Request: {}", e.request());
            
            if (e.status() == 401) {
                throw new AuthenticationException("Credenciais de autentica√ß√£o inv√°lidas", e);
            } else if (e.status() == 403) {
                throw new AuthenticationException("Acesso negado pela API de autentica√ß√£o", e);
            } else if (e.status() >= 500) {
                throw new AuthenticationException("Erro interno do servidor de autentica√ß√£o", e);
            } else {
                throw new AuthenticationException("Erro na comunica√ß√£o com servi√ßo de autentica√ß√£o", e);
            }
        } catch (Exception e) {
            log.error("‚ùå Erro inesperado na autentica√ß√£o", e);
            throw new AuthenticationException("Erro inesperado na autentica√ß√£o", e);
        }
    }

    /**
     * üîç Verifica se token atual √© v√°lido com logs detalhados.
     */
    private boolean isCurrentTokenValid() {
        if (currentToken == null) {
            log.debug("‚ùå Nenhum token em cache");
            return false;
        }
        
        if (currentToken.getAccessToken() == null) {
            log.debug("‚ùå Access token √© null");
            return false;
        }
        
        if (currentToken.isExpired()) {
            log.debug("‚ùå Token expirado");
            return false;
        }
        
        if (currentToken.isExpiringSoon()) {
            log.debug("‚ö†Ô∏è Token expirando em breve");
            return false;
        }
        
        log.debug("‚úÖ Token atual √© v√°lido");
        return true;
    }
}
