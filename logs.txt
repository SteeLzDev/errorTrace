Inclusão de parâmetros de sistema (997, 998, 999, 1000) para configurar quais métodos de TOTP são permitidos por papel de usuário, com opção de App, E-mail e SMS.
Inclusão de parâmetro de sistema (1001) para configurar se o usuário pode remover o TOTP previamente configurado.
Alteração na edição de usuário para bloquear edição de e-mail ou telefone caso o usuário tenha habilitado TOTP via E-mail ou SMS.
Alteração nas operações de autenticação e autorização de operações sensíveis para permitir uso de TOTP por E-mail e SMS.
Alterações na Documentação:
1) Incluir novos parâmetros de sistema 997 a 1001, e associar aos casos de uso de autenticação e autorização de operação sensível.
2) Documentar na operação de Habilitação de Código de Segurança TOTP as alterações realizadas na atividade
Alterações no Banco de Dados:
-- Alterações de texto sistema existentes
DELETE FROM tb_texto_sistema WHERE TEX_CHAVE IN ('mensagem.cadastro.totp.popup', 'mensagem.totp.leia.codigo');

UPDATE tb_texto_sistema SET TEX_TEXTO = 'O código de segurança será utilizado como duplo fator de autenticação e/ou autorização de operações no sistema. Caso queira desabilitar o código de segurança, clique em Remover. Será necessário revalidar o código de segurança para desabilitá-lo.' WHERE TEX_CHAVE = 'mensagem.totp.cadastrado';

UPDATE tb_texto_sistema SET TEX_TEXTO = 'O código de segurança será utilizado como duplo fator de autenticação e/ou autorização de operações no sistema. O sistema dispõe das seguintes opções de envio de código de segurança:' WHERE TEX_CHAVE = 'mensagem.cadastro.totp';

UPDATE tb_texto_sistema SET TEX_TEXTO = 'Clique aqui para remover a validação de código de segurança.' WHERE TEX_CHAVE = 'mensagem.totp.remover.clique.aqui';
UPDATE tb_texto_sistema SET TEX_TEXTO = 'Clique aqui para cadastrar a validação de código de segurança.' WHERE TEX_CHAVE = 'mensagem.totp.cadastrar.clique.aqui';

-- Novos parametros de sistema
INSERT INTO tb_tipo_param_sist_consignante (TPC_CODIGO, TPC_DESCRICAO, TPC_DOMINIO, TPC_VLR_DEFAULT, TPC_CSE_ALTERA, TPC_CSE_CONSULTA, TPC_SUP_ALTERA, TPC_SUP_CONSULTA, GPS_CODIGO)
VALUES ('997', 'Método de TOTP permitido para Consignante/Órgão', 'ESCOLHA[0=Nenhum;1=App;2=Email;3=SMS;4=App/Email/SMS;5=App/Email;6=App/SMS;7=Email/SMS]', '1', 'N', 'N', 'N', 'N', '1');

INSERT INTO tb_param_sist_consignante (TPC_CODIGO, CSE_CODIGO, PSI_VLR)
VALUES ('997', '1', '1');

INSERT INTO tb_tipo_param_sist_consignante (TPC_CODIGO, TPC_DESCRICAO, TPC_DOMINIO, TPC_VLR_DEFAULT, TPC_CSE_ALTERA, TPC_CSE_CONSULTA, TPC_SUP_ALTERA, TPC_SUP_CONSULTA, GPS_CODIGO)
VALUES ('998', 'Método de TOTP permitido para Consignatária/Correspondente', 'ESCOLHA[0=Nenhum;1=App;2=Email;3=SMS;4=App/Email/SMS;5=App/Email;6=App/SMS;7=Email/SMS]', '1', 'N', 'N', 'N', 'N', '1');

INSERT INTO tb_param_sist_consignante (TPC_CODIGO, CSE_CODIGO, PSI_VLR)
VALUES ('998', '1', '1');

INSERT INTO tb_tipo_param_sist_consignante (TPC_CODIGO, TPC_DESCRICAO, TPC_DOMINIO, TPC_VLR_DEFAULT, TPC_CSE_ALTERA, TPC_CSE_CONSULTA, TPC_SUP_ALTERA, TPC_SUP_CONSULTA, GPS_CODIGO)
VALUES ('999', 'Método de TOTP permitido para Suporte', 'ESCOLHA[0=Nenhum;1=App;2=Email;3=SMS;4=App/Email/SMS;5=App/Email;6=App/SMS;7=Email/SMS]', '0', 'N', 'N', 'N', 'N', '1');

INSERT INTO tb_param_sist_consignante (TPC_CODIGO, CSE_CODIGO, PSI_VLR)
VALUES ('999', '1', '0');

INSERT INTO tb_tipo_param_sist_consignante (TPC_CODIGO, TPC_DESCRICAO, TPC_DOMINIO, TPC_VLR_DEFAULT, TPC_CSE_ALTERA, TPC_CSE_CONSULTA, TPC_SUP_ALTERA, TPC_SUP_CONSULTA, GPS_CODIGO)
VALUES ('1000', 'Método de TOTP permitido para Servidor', 'ESCOLHA[0=Nenhum;1=App;2=Email;3=SMS;4=App/Email/SMS;5=App/Email;6=App/SMS;7=Email/SMS]', '0', 'N', 'N', 'N', 'N', '1');

INSERT INTO tb_param_sist_consignante (TPC_CODIGO, CSE_CODIGO, PSI_VLR)
VALUES ('1000', '1', '0');

INSERT INTO tb_tipo_param_sist_consignante (TPC_CODIGO, TPC_DESCRICAO, TPC_DOMINIO, TPC_VLR_DEFAULT, TPC_CSE_ALTERA, TPC_CSE_CONSULTA, TPC_SUP_ALTERA, TPC_SUP_CONSULTA, GPS_CODIGO)
VALUES ('1001', 'Permite usuário desabilitar validação de TOTP', 'SN', 'N', 'N', 'N', 'N', 'N', NULL);

INSERT INTO tb_param_sist_consignante (TPC_CODIGO, CSE_CODIGO, PSI_VLR)
VALUES ('1001', '1', 'N');

-- Acesso recurso para validacao de OTP ao autorizar operações
INSERT INTO tb_acesso_recurso (ACR_CODIGO, PAP_CODIGO, FUN_CODIGO, ACR_RECURSO, ACR_PARAMETRO, ACR_OPERACAO, ACR_ATIVO, ACR_BLOQUEIO, ACR_SESSAO, ITM_CODIGO, ACR_FIM_FLUXO, ACR_METODO_HTTP)
VALUES ('17104', NULL, NULL, '/v3/enviarOtpOperacao', NULL, NULL, 1, 'S', 'S', NULL, 'N', '2');

-- Conversão do campo USU_PERMITE_VALIDACAO_TOTP, anteriormente S/N para 0/1/2/3
-- Para usuarios que tem chave habilitada, muda a configuracao para o novo valor do campo
UPDATE tb_usuario SET USU_PERMITE_VALIDACAO_TOTP = '1' WHERE USU_PERMITE_VALIDACAO_TOTP = 'S' AND NULLIF(USU_CHAVE_VALIDACAO_TOTP, '') IS NOT NULL;
-- Para os demais, define o campo como Zero, estando o TOTP desabilitado, e o padrao do USU_OPERACOES_VALIDACAO_TOTP como 3 (Ambos)
UPDATE tb_usuario SET USU_PERMITE_VALIDACAO_TOTP = '0', USU_OPERACOES_VALIDACAO_TOTP = '3' WHERE USU_PERMITE_VALIDACAO_TOTP = 'N' OR (USU_PERMITE_VALIDACAO_TOTP IS NOT NULL AND NULLIF(USU_CHAVE_VALIDACAO_TOTP, '') IS NULL);
Arquivos Alterados:
src/main/java/com/zetra/econsig/helper/seguranca/AcessoSistema.java
src/main/java/com/zetra/econsig/helper/usuario/UsuarioHelper.java
src/main/java/com/zetra/econsig/service/usuario/UsuarioControllerBean.java
src/main/java/com/zetra/econsig/service/usuario/UsuarioController.java
src/main/java/com/zetra/econsig/values/CodedValues.java
src/main/java/com/zetra/econsig/values/ParamTipoPermitidoTotpEnum.java
src/main/java/com/zetra/econsig/values/PermiteValidacaoTotpEnum.java
src/main/java/com/zetra/econsig/web/controller/autenticacao/CadastrarValidacaoTotpWebController.java
src/main/java/com/zetra/econsig/web/controller/sistema/AutorizarOperacaoWebController.java
src/main/java/com/zetra/econsig/web/controller/usuario/AbstractManterUsuarioPapelWebController.java
src/main/java/com/zetra/econsig/web/controller/usuario/AutenticarUsuarioWebController.java
src/main/resources/ApplicationResources.properties
src/main/webapp/css/custom_v5.css
src/main/webapp/css/econsig.css
src/main/webapp/css/econsig_v5.css
src/main/webapp/css/vanilla-otp.css
src/main/webapp/js/vanilla-otp.js
src/main/webapp/js/vanilla-otp.min.js
src/main/webapp/package.json
src/main/webapp/package-lock.json
src/main/webapp/WEB-INF/jsp/autenticacao/alterarValidacaoTotp_v4.jsp
src/main/webapp/WEB-INF/jsp/autenticacao/cadastrarValidacaoTotp_v4.jsp
src/main/webapp/WEB-INF/jsp/autenticarUsuario/validarTotp_v4.jsp
src/main/webapp/WEB-INF/jsp/manterBeneficio/alterarBeneficiario_v4.jsp
src/main/webapp/WEB-INF/jsp/manterUsuario/editarUsuarioPapel_v4.jsp
src/main/webapp/WEB-INF/tags/empty_v4.tag
src/main/webapp/WEB-INF/tags/page_v4.tag

src/main/resources/db/0.0.0/dml_all_DESENV-23985.sql


1) Incluir opção de Código de Segurança (TOTP) via E-mail e SMS.
2) O campo USU_PERMITE_VALIDACAO_TOTP na tb_usuario atualmente é booleano, S/N. Alterar a utilização do campo para que tenha as seguintes opções:
2.1) 0 = Desabilitado
2.2) 1 = TOTP via App
2.3) 2 = TOTP via E-mail
2.4) 3 = TOTP via SMS
3) Criar comando SQL para converter os valores de nulo ou N para Zero, e S para 1.
4) Alterar os pontos que atualmente utilizam este campo para que passe a tratar o cenário de envio de OTP por e-mail ou SMS.
4.1) Esta alteração deve afetar autenticação no sistema e autorização de operações sensíveis.
5) Alterar a manutenção de usuário para bloquear edição de e-mail caso o usuário tenha o USU_PERMITE_VALIDACAO_TOTP com o valor 2.
5.1) Somente usuários do papel SUP podem editar endereço de e-mail de usuários com USU_PERMITE_VALIDACAO_TOTP = 2.
5.2) Para os demais papéis, na edição, bloquear o campo e incluir um alerta que o dado não pode ser alterado pois é usado como MFA.
6) Alterar a manutenção de usuário para bloquear edição de telefone caso o usuário tenha o USU_PERMITE_VALIDACAO_TOTP com o valor 3.
6.1) Somente usuários do papel SUP podem editar telefone de usuários com USU_PERMITE_VALIDACAO_TOTP = 3.
6.2) Para os demais papéis, na edição, bloquear o campo e incluir um alerta que o dado não pode ser alterado pois é usado como MFA.


package com.zetra.econsig.helper.usuario;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.BeansException;

import com.zetra.econsig.delegate.ConsignanteDelegate;
import com.zetra.econsig.delegate.LogDelegate;
import com.zetra.econsig.delegate.UsuarioDelegate;
import com.zetra.econsig.dto.TransferObject;
import com.zetra.econsig.dto.entidade.ConsignanteTransferObject;
import com.zetra.econsig.dto.entidade.ConsignatariaTransferObject;
import com.zetra.econsig.dto.entidade.CorrespondenteTransferObject;
import com.zetra.econsig.dto.entidade.EstabelecimentoTransferObject;
import com.zetra.econsig.dto.entidade.OcorrenciaUsuarioTransferObject;
import com.zetra.econsig.dto.entidade.OrgaoTransferObject;
import com.zetra.econsig.dto.entidade.UsuarioTransferObject;
import com.zetra.econsig.dto.web.SSOToken;
import com.zetra.econsig.exception.ConsignanteControllerException;
import com.zetra.econsig.exception.ConsignatariaControllerException;
import com.zetra.econsig.exception.HQueryException;
import com.zetra.econsig.exception.LogControllerException;
import com.zetra.econsig.exception.ParametroControllerException;
import com.zetra.econsig.exception.SSOException;
import com.zetra.econsig.exception.SenhaExpiradaException;
import com.zetra.econsig.exception.ServidorControllerException;
import com.zetra.econsig.exception.UsuarioControllerException;
import com.zetra.econsig.exception.ViewHelperException;
import com.zetra.econsig.exception.ZetraException;
import com.zetra.econsig.helper.criptografia.JCrypt;
import com.zetra.econsig.helper.log.Log;
import com.zetra.econsig.helper.parametro.ParamSist;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.helper.seguranca.ControleLogin;
import com.zetra.econsig.helper.seguranca.GoogleAuthenticatorHelper;
import com.zetra.econsig.helper.senha.SenhaHelper;
import com.zetra.econsig.helper.texto.ApplicationResourcesHelper;
import com.zetra.econsig.helper.texto.TextHelper;
import com.zetra.econsig.helper.web.JspHelper;
import com.zetra.econsig.persistence.entity.Perfil;
import com.zetra.econsig.service.consignante.ConsignanteController;
import com.zetra.econsig.service.consignataria.ConsignatariaController;
import com.zetra.econsig.service.parametro.ParametroController;
import com.zetra.econsig.service.servidor.ServidorController;
import com.zetra.econsig.service.usuario.UsuarioController;
import com.zetra.econsig.values.CanalEnum;
import com.zetra.econsig.values.CodedValues;
import com.zetra.econsig.values.Columns;
import com.zetra.econsig.values.PermiteValidacaoTotpEnum;
import com.zetra.econsig.web.ApplicationContextProvider;
import com.zetra.econsig.webclient.faces.FacesWebServiceClient;
import com.zetra.econsig.webclient.sso.SSOClient;
import com.zetra.econsig.webclient.sso.SSOErrorCodeEnum;

public final class UsuarioHelper {
    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(UsuarioHelper.class);

    public static final String LAYOUT_V4 = "v4";

    /**
     * busca usuário(s) dado pelo id
     * @param usuId - pode ser o login ou e-mail do usuário
     * @return
     * @throws ViewHelperException
     */
    public static List<TransferObject> localizarUsuario (String usuId, AcessoSistema responsavel) throws ViewHelperException {
        try {
            final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);

            // tenta primeira busca pelo login
            final TransferObject usuario = usuarioController.findTipoUsuarioByLogin(usuId, responsavel);

            if (usuario != null) {
                return List.of(usuario);
            }

            // Busca assumindo usuId como e-mail
            return usuarioController.findUsuarioByEmail(usuId, responsavel);
        } catch (final UsuarioControllerException e) {
            throw new ViewHelperException(e);
        }
    }

    /**
     * verifica se usuário autentica via serviço SSO. a configuração específica do registro do usuário tem precedência sobre a de sistema para o papel
     * @param usuario
     * @param responsavel
     * @return
     */
    public static boolean usuarioAutenticaSso(TransferObject usuario, AcessoSistema responsavel) {
        // Se usuário é nulo ou está no leiaute v2, então não tem SSO
        if (usuario == null) {
            return false;
        }

        // Se a configuração do usuário que informa se autentica via SSO está preenchida, então retorna
        // esta informação, seja ela igual a Sim ou Não
        final String usuAutenticaSso = (String) usuario.getAttribute(Columns.USU_AUTENTICA_SSO);
        if (!TextHelper.isNull(usuAutenticaSso)) {
            return CodedValues.TPC_SIM.equals(usuAutenticaSso);
        }

        // Se a configuração do usuário está nula, verifica o parâmetro de sistema de acordo com o papel do usuário
        boolean sistemaConfiguradoSso = false;

        if (!TextHelper.isNull(usuario.getAttribute(Columns.UCE_CSE_CODIGO)) || !TextHelper.isNull(usuario.getAttribute(Columns.UOR_ORG_CODIGO))) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_CSE_ORG, CodedValues.TPC_SIM, responsavel);
        } else if (!TextHelper.isNull(usuario.getAttribute(Columns.UCA_CSA_CODIGO)) || !TextHelper.isNull(usuario.getAttribute(Columns.UCO_COR_CODIGO))) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_CSA_COR, CodedValues.TPC_SIM, responsavel);
        } else if (!TextHelper.isNull(usuario.getAttribute(Columns.USP_CSE_CODIGO))) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_SUP, CodedValues.TPC_SIM, responsavel);
        } else if (!TextHelper.isNull(usuario.getAttribute(Columns.USE_SER_CODIGO))) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_SER, CodedValues.TPC_SIM, responsavel);
        }

        return sistemaConfiguradoSso;
    }

    public static boolean usuarioAutenticaSso(UsuarioTransferObject usuario, String tipoEntidade, AcessoSistema responsavel) {
        // Se usuário é nulo ou está no leiaute v2, então não tem SSO
        if (usuario == null) {
            return false;
        }

        // Se a configuração do usuário que informa se autentica via SSO está preenchida, então retorna
        // esta informação, seja ela igual a Sim ou Não
        final String usuAutenticaSso = usuario.getUsuAutenticaSso();
        if (!TextHelper.isNull(usuAutenticaSso)) {
            return CodedValues.TPC_SIM.equals(usuAutenticaSso);
        }

        // Se a configuração do usuário está nula, verifica o parâmetro de sistema de acordo com o papel do usuário
        boolean sistemaConfiguradoSso = false;

        if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade) || AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade)) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_CSE_ORG, CodedValues.TPC_SIM, responsavel);
        } else if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade) || AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_CSA_COR, CodedValues.TPC_SIM, responsavel);
        } else if (AcessoSistema.ENTIDADE_SER.equals(tipoEntidade)) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_SUP, CodedValues.TPC_SIM, responsavel);
        } else if (AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
            sistemaConfiguradoSso = ParamSist.paramEquals(CodedValues.TPC_AUTENTICACAO_SSO_SER, CodedValues.TPC_SIM, responsavel);
        }

        return sistemaConfiguradoSso;
    }

    public static List<TransferObject> autenticarUsuarios(String senha, List<UsuarioTransferObject> usuarios, String token, AcessoSistema responsavel) throws ViewHelperException {
        return validarSenhaUsuarios(senha, usuarios, true, true, token, responsavel);
    }

    /**
     * Valida a senha dos usuários passados no parâmetro usuarios.
     * Retorna uma lista apenas daqueles usuários cuja senha validou corretamente.
     * @param senha - senha aberta a ser validada
     * @param usuarios - usuários que serão validados pela senha
     * @param salvarToken - grava o token de autenticação do serviço de autenticação no AcessoSistema responsavel (apenas para autenticação remota)
     * @param bloqueiaSenhaErrada - bloqueia usuário caso o número de tentativas erradas de login configurado no sistema tenha sido alcançado
     * @param token - Token que deve ser validado no SSO
     * @param responsavel - AcessoSistema que representará os usuários autenticados pela senha
     * @return
     * @throws ViewHelperException
     */
    public static List<TransferObject> validarSenhaUsuarios(String senha, List<UsuarioTransferObject> usuarios, boolean salvarToken, boolean bloqueiaSenhaErrada, String token, AcessoSistema responsavel) throws ViewHelperException {
        List<TransferObject> usuariosValidados = new ArrayList<>();
        if ((usuarios == null) || usuarios.isEmpty()) {
            return usuariosValidados;
        }

        final List<Boolean> autenticaSsoSet = usuarios.stream().map(usu -> usuarioAutenticaSso(usu, responsavel)).collect(Collectors.toList());

        //Se houver apenas um usuário de mesmo e-mail com usu_autentica_sso = S, então esse usuário será validado para acesso.
        if ((autenticaSsoSet.size() > 1) && autenticaSsoSet.contains(Boolean.TRUE)) {
            final List<UsuarioTransferObject> usuarioSSO = new ArrayList<>();
            for (final UsuarioTransferObject usuario : usuarios) {
                if (!TextHelper.isNull(usuario.getAttribute(Columns.USU_AUTENTICA_SSO)) && CodedValues.TPC_SIM.equals(usuario.getAttribute(Columns.USU_AUTENTICA_SSO))) {
                    usuarioSSO.add(usuario);
                }
            }

            usuariosValidados = validaSenhaSSO(senha, usuarioSSO, salvarToken, bloqueiaSenhaErrada, token, responsavel);
        } else if ((autenticaSsoSet.size() == 1) && autenticaSsoSet.contains(Boolean.FALSE)) {
            for (final UsuarioTransferObject usuario : usuarios) {
                final String senhaSalva = usuario.getUsuSenha();
                if (JCrypt.verificaSenha(senha, senhaSalva)) {
                    usuariosValidados.add(usuario);
                }
            }

            // Apenas se nenhum dos usuários tiver a senha válida faz o controle de quantidade de tentativas.
            if (usuariosValidados.isEmpty()) {
                controleNumTentativasAutenticacao(usuarios, bloqueiaSenhaErrada, responsavel);
            }

        } else if ((autenticaSsoSet.size() == 1) && autenticaSsoSet.contains(Boolean.TRUE)) {
            // verifica se todos usuários estão com o e-mail preenchido e se este é único
            final List<UsuarioTransferObject> usuSemEmail = usuarios.stream().filter(usu -> TextHelper.isNull(usu.getUsuEmail())).collect(Collectors.toList());

            if ((usuSemEmail == null) || !usuSemEmail.isEmpty()) {
                throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
            }
            final Set<String> emailList = usuarios.stream().map(UsuarioTransferObject::getUsuEmail).collect(Collectors.toSet());
            // e-mail deve ser único entre usuários
            if (emailList.size() > 1) {
                throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
            }

            usuariosValidados = validaSenhaSSO(senha, usuarios, salvarToken, bloqueiaSenhaErrada, token, responsavel);
        } else {
            verificaConsistenciaConfigSSO(usuarios, responsavel);
        }

        // Se a lista inicial contém multiplos usuários, caso algum não tenha CPF ou os CPFs sejam diferentes retorna mensagem de erro ao usuário
        if (usuarios.size() > 1) {
            final Set<String> cpfSet = usuarios.stream().map(UsuarioTransferObject::getUsuCPF).collect(Collectors.toSet());
            if ((cpfSet == null) || cpfSet.isEmpty() || cpfSet.contains(null) || (cpfSet.size() > 1)) {
                // Se pelo menos algum usuário da lista foi autenticado com sucesso, então retorna mensagem mais descritiva
                if (!usuariosValidados.isEmpty()) {
                    throw new ViewHelperException("mensagem.erro.autenticacao.email.duplicado", responsavel);
                } else {
                    // Caso contrário, retorna erro de usuário e/ou senha inválidos
                    throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
                }
            }
        }

        return usuariosValidados;
    }

    /**
     * verifica se todos os usuários com mesmo email/cpf no sistema possuem a mesma configuração
     * @param usuarios
     * @param responsavel
     * @throws ViewHelperException
     */
	private static void verificaConsistenciaConfigSSO(List<UsuarioTransferObject> usuarios, AcessoSistema responsavel)
			throws ViewHelperException {
		final String identificacaoUsu = !TextHelper.isNull(usuarios.get(0).getUsuEmail()) ? usuarios.get(0).getUsuEmail() : usuarios.get(0).getUsuCPF();

		LOG.error(ApplicationResourcesHelper.getMessage("mensagem.usuario.erro.configuracao.tipo.autenticacao", (AcessoSistema) null, identificacaoUsu));
		final LogDelegate log = new LogDelegate(responsavel, Log.SISTEMA, Log.LOGIN, Log.LOG_LOGIN_ERRO);
		try {
		    log.add(ApplicationResourcesHelper.getMessage("mensagem.usuario.erro.configuracao.tipo.autenticacao", (AcessoSistema) null, identificacaoUsu));
		    log.write();
		} catch (final LogControllerException ex) {
		    LOG.error(ex.getMessage(), ex);
		}

		throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
	}

    /**
     * valida a senha no serviço SSO para os usuários lógicos no sistema para um indivíduo.
     * @param senha - senha a validar
     * @param usuarios - usuários que um indivíduo pode ter no sistema.
     * @param salvarToken - se o token gerado deve ser gravado no acesso recurso
     * @param bloqueiaSenhaErrada - se bloqueia o usuário caso a validação retorne falso.
     * @param token - se faz a validação via um token dado. Se for nulo, valida a senha passada por parâmetro.
     * @param responsavel
     * @return
     * @throws ViewHelperException
     */
	public static List<TransferObject> validaSenhaSSO(String senha, List<UsuarioTransferObject> usuarios, boolean salvarToken, boolean bloqueiaSenhaErrada, String token, AcessoSistema responsavel) throws ViewHelperException {
		if ((usuarios == null) || usuarios.isEmpty()) {
			return new ArrayList<>();
		}

		final List<TransferObject> usuariosValidados = new ArrayList<>();

		final SSOClient ssoClient = ApplicationContextProvider.getApplicationContext().getBean(SSOClient.class);

		try {
		    final String clientId = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_SSO_OAUTH_CLIENT_ID, responsavel)) ? ParamSist.getInstance().getParam(CodedValues.TPC_SSO_OAUTH_CLIENT_ID, responsavel).toString() : "";

		    SSOToken ssoToken = null;
		    if (TextHelper.isNull(token)) {
		    	ssoToken = ssoClient.autenticar(usuarios.get(0).getUsuEmail(), senha);
		    } else if (!ssoClient.isTokenValido(usuarios.get(0).getUsuEmail(), clientId, token)) {
		        throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
		    }

		    // Se validou usuário no SSO, expiração de senha deve ser considerada do SSO
		    if (salvarToken) {
			    responsavel.setSsoToken(ssoToken);
			    if (!usuariosValidados.isEmpty()) {
			        responsavel.setUsuEmail(usuarios.get(0).getUsuEmail());
			    }
			}

		    usuarios = usuarios.stream().map(usu -> {
		        usu.setAttribute("EXPIROU", "0");
		        return usu;
		    }).collect(Collectors.toList());

		    usuariosValidados.addAll(usuarios);
		} catch (final SSOException e) {
		    tratarSSOException(e, usuarios, salvarToken, bloqueiaSenhaErrada, usuariosValidados, responsavel);
		}

		return usuariosValidados;
	}

	private static void tratarSSOException(SSOException e, List<UsuarioTransferObject> usuarios, boolean salvarToken,
			boolean bloqueiaSenhaErrada, List<TransferObject> usuariosValidados, AcessoSistema responsavel) throws ViewHelperException {
		if ("mensagem.usuarioSenhaInvalidos".equals(e.getMessageKey())) {
		    if ((e.getSsoError() == null) || (!SSOErrorCodeEnum.ACCOUNT_PASSWORD_IS_EXPIRED.equals(e.getSsoError()) && !SSOErrorCodeEnum.GENERIC_ERROR.equals(e.getSsoError()))) {
		        controleNumTentativasAutenticacao(usuarios, bloqueiaSenhaErrada, responsavel);
		    } else if (SSOErrorCodeEnum.ACCOUNT_PASSWORD_IS_EXPIRED.equals(e.getSsoError())) {
		        usuarios = usuarios.stream().map(usu -> {
		            usu.setAttribute("EXPIROU", "1");
		            return usu;
		        }).collect(Collectors.toList());

		        usuariosValidados.addAll(usuarios);
		        final SSOToken ssoToken = new SSOToken();
		        ssoToken.error_code = SSOErrorCodeEnum.ACCOUNT_PASSWORD_IS_EXPIRED.getErrorCode();
		        if (salvarToken) {
				    responsavel.setSsoToken(ssoToken);
				    if (!usuariosValidados.isEmpty()) {
				        responsavel.setUsuEmail(usuarios.get(0).getUsuEmail());
				    }
				}
		    }
		} else {
		    throw new ViewHelperException(e);
		}
	}

	private static void controleNumTentativasAutenticacao(List<UsuarioTransferObject> usuarios, boolean bloqueiaSenhaErrada, AcessoSistema responsavel) throws ViewHelperException {
		ViewHelperException numMaxTentativasException = null;

		if (bloqueiaSenhaErrada) {
		    for (final UsuarioTransferObject usuario : usuarios) {
		        try {
                    final AcessoSistema usuAcesso = AcessoSistema.recuperaAcessoSistema(usuario.getUsuCodigo(), responsavel.getIpUsuario(), responsavel.getPortaLogicaUsuario());
		            ControleLogin.getInstance().bloqueiaUsuario(usuario, usuAcesso);
		        } catch (final ZetraException e) {
		            if (numMaxTentativasException == null) {
		                // guarda exceção por enquanto para poder registrar tentativas para todos usuários
		                numMaxTentativasException = new ViewHelperException(e);
		            }
		        }
		    }
		}

		if (numMaxTentativasException != null) {
		    throw numMaxTentativasException;
		}
	}

    public static TransferObject autenticarUsuario(String usuLogin, String usuSenha, AcessoSistema responsavel) throws ViewHelperException {
        return autenticarUsuario(usuLogin, usuSenha, false, false, true, null, responsavel);
    }

    public static TransferObject autenticarUsuario(String usuLogin, String usuSenha, boolean senhaApp, AcessoSistema responsavel) throws ViewHelperException {
        return autenticarUsuario(usuLogin, usuSenha, senhaApp, false, true, null, responsavel);
    }

    public static TransferObject autenticarUsuario(String usuLogin, String usuSenha, boolean senhaApp, boolean permiteAguardAprovacaoCadastro, boolean autenticarUsuario, AcessoSistema responsavel) throws ViewHelperException {
        return autenticarUsuario(usuLogin, usuSenha, senhaApp, permiteAguardAprovacaoCadastro, autenticarUsuario, null, responsavel);
    }

    public static TransferObject autenticarUsuario(String usuLogin, String usuSenha, boolean senhaApp, boolean permiteAguardAprovacaoCadastro, boolean autenticarUsuario, TransferObject servidor, AcessoSistema responsavel) throws ViewHelperException {
        try {
            final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
            TransferObject usuario = usuarioController.findTipoUsuarioByLogin(usuLogin, AcessoSistema.getAcessoUsuarioSistema());
            if (usuario == null) {
                // Busca pelo usuLogin assumindo que é e-mail
                final List<TransferObject> usuariosListTO = usuarioController.findUsuarioByEmail(usuLogin, responsavel);

                // Recupera o usuário caso seja somente um
                if ((usuariosListTO != null) && !usuariosListTO.isEmpty() && (usuariosListTO.size() == 1)) {
                	usuario = usuariosListTO.get(0);
                }

                // Levanta exceção se usuário ainda não foi localizado
                if (usuario == null) {
                	throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
                }
            }

            // Verifica a licença do eConsig
            final String licenca = (String) usuario.getAttribute(Columns.CSE_LICENCA);
            final String publicKeyCentralizador = (String) usuario.getAttribute(Columns.CSE_RSA_PUBLIC_KEY_CENTRALIZADOR);
            final String modulusCentralizador = (String) usuario.getAttribute(Columns.CSE_RSA_MODULUS_CENTRALIZADOR);
            if (isLicencaExpirada(licenca, publicKeyCentralizador, modulusCentralizador)) {
            	throw new ViewHelperException("mensagem.licencaSistemaInvalida", responsavel);
            }

            // se sistema está configurado para bloquear automaticamente usuário na sua próxima autenticação, faz a verficação de bloqueio.
            boolean bloqueadoPorInatividade = false;
            if(ParamSist.getBoolParamSist(CodedValues.TPC_BLOQUEIA_USU_INATIVIDADE_PROXIMA_AUTENTICACAO, responsavel)) {
            	bloqueadoPorInatividade = UsuarioHelper.bloqueioAutomaticoPorInatividade((String) usuario.getAttribute(Columns.USU_CODIGO), responsavel);
            }

            if (!TextHelper.isNull(usuario.getAttribute(Columns.USE_SER_CODIGO))) {
                // Usuário Servidor, realiza autenticação integrada com senha externa, caso exista
                // Se a validação não for externa e não for login automático, valida a senha do servidor.
                final boolean loginComEstOrg = ParamSist.paramEquals(CodedValues.TPC_LOGIN_USU_SERVIDOR_COM_EST_ORG_ID, CodedValues.TPC_SIM, responsavel);
                final String[] partesLogin = usuLogin.split("-");
                String matricula;
                // As partes são: est[0] -- org[1] -- matricula[2] -- digito matricula[3]
                if (loginComEstOrg && (partesLogin.length > 3)) {
                	matricula = (partesLogin[2] + "-" + partesLogin[3]);
                } else if (loginComEstOrg) {
                	matricula = (partesLogin[2]);
                } else if(partesLogin.length > 2) {
                	matricula = (partesLogin[1] + "-" + partesLogin[2]);
                } else {
                	matricula = (partesLogin[1]);
                }

                final String estIdentificador = partesLogin[0];
                final String orgIdentificador = (loginComEstOrg ? partesLogin[1] : null);


                try {
                    try {
                        if (servidor == null) {
                            final ConsignanteController consignanteController = ApplicationContextProvider.getApplicationContext().getBean(ConsignanteController.class);
                            final EstabelecimentoTransferObject estabelecimento = consignanteController.findEstabelecimentoByIdn(estIdentificador, responsavel);
                            final String estCodigo = estabelecimento.getEstCodigo();
                            String orgCodigo = null;
                            if (loginComEstOrg) {
                                final OrgaoTransferObject orgao = consignanteController.findOrgaoByIdn(orgIdentificador, estCodigo, responsavel);
                                orgCodigo = orgao.getOrgCodigo();
                            }

                            final ServidorController servidorController = ApplicationContextProvider.getApplicationContext().getBean(ServidorController.class);
                            servidor = servidorController.getRegistroServidorPelaMatricula((String) usuario.getAttribute(Columns.USE_SER_CODIGO), orgCodigo, estCodigo, matricula, responsavel);
                            if (servidor == null) {
                                throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
                            }
                        }

                        if (autenticarUsuario) {
                        	if (usuarioAutenticaSso(usuario, responsavel)) {
                        		final SSOClient ssoClient = ApplicationContextProvider.getApplicationContext().getBean(SSOClient.class);
                        		final SSOToken ssoToken = ssoClient.autenticar((String) usuario.getAttribute(Columns.USU_EMAIL).toString(), usuSenha);
                        		usuario.setAttribute("EXPIROU", "0");
                                usuario.setAttribute("SSO_TOKEN", ssoToken);
                        	} else {
                        		try {
                        			SenhaHelper.validarSenhaServidor((String) servidor.getAttribute(Columns.RSE_CODIGO), usuSenha, responsavel.getIpUsuario(), null, null, false, true, senhaApp, responsavel);
                        			usuario.setAttribute("EXPIROU", "0");
                        		} catch (final SenhaExpiradaException ex) {
                        			usuario.setAttribute("EXPIROU", "1");
                        		}
                        	}
                        }
            		} catch (ConsignanteControllerException | ServidorControllerException | UsuarioControllerException | SSOException ex) {
                        LOG.error(ex.getMessage(), ex);
                        throw new ViewHelperException(ex);
                    }
        		} catch (final ViewHelperException ex) {
                    try {
                        final LogDelegate log = new LogDelegate(responsavel, Log.SISTEMA, Log.LOGIN, Log.LOG_LOGIN_ERRO);
                        log.add(ApplicationResourcesHelper.getMessage("mensagem.log.matricula.arg0", (AcessoSistema) null, matricula));
                        log.add(ApplicationResourcesHelper.getMessage("mensagem.log.erro.arg0", (AcessoSistema) null, ex.getMessage()));
                        if (CanalEnum.REST.equals(responsavel.getCanal())) {
                            log.add(ApplicationResourcesHelper.getMessage("rotulo.log.origem.mobile", responsavel));
                        }

                        log.write();
                    } catch (final LogControllerException le) {
                        LOG.error(le);
                    }

                    throw ex;
                }
            } else {
                final String senha = (String) usuario.getAttribute(Columns.USU_SENHA);

                if (autenticarUsuario) {
                	if (usuarioAutenticaSso(usuario, responsavel)) {
                		try {
                			final SSOClient ssoClient = ApplicationContextProvider.getApplicationContext().getBean(SSOClient.class);
                			ssoClient.autenticar((String) usuario.getAttribute(Columns.USU_EMAIL), usuSenha);
                			usuario.setAttribute("EXPIROU", "0");
                		} catch (BeansException | SSOException e) {
                			throw new ViewHelperException(e);
                		}
                	} else // Verifica a senha do usuário
                    if (!JCrypt.verificaSenha(usuSenha, senha)) {
                    	try {
                    		// verifica se já atingiu o num max de tentativas de login definidas em parâmetro de sistema
                    		// se sim, bloqueia o usuário
                    		ControleLogin.getInstance().bloqueiaUsuario(usuario, responsavel);
                    	} catch (final ZetraException ze) {
                    		throw new ViewHelperException(ze);
                    	}
                    	throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
                    }
                }
            }

            // se a senha está correta, limpa cache de tentativas de login para este usuário.
            ControleLogin.getInstance().resetTetantivasLogin((String) usuario.getAttribute(Columns.USU_CODIGO));

            // Verifica se a senha já expirou
            final String expirou = usuario.getAttribute("EXPIROU") != null ? usuario.getAttribute("EXPIROU").toString() : "1";
            if ("1".equals(expirou)) {
                boolean senhaExpirada = true;
                throw new ViewHelperException("mensagem.senhaExpirada", senhaExpirada, responsavel);
            }

            // Verifica o status do usuário
            final String stuCodigo = usuario.getAttribute(Columns.USU_STU_CODIGO) != null ? usuario.getAttribute(Columns.USU_STU_CODIGO).toString() : CodedValues.STU_BLOQUEADO;
            if (CodedValues.STU_EXCLUIDO.equals(stuCodigo)) {
                throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
            } else if (bloqueadoPorInatividade || CodedValues.STU_CODIGOS_INATIVOS.contains(stuCodigo)) {
                throw new ViewHelperException("mensagem.usuarioBloqueado", responsavel);
            } else if (CodedValues.STU_AGUARD_APROVACAO_CADASTRO.equals(stuCodigo) && (servidor != null)) {
                try {
                    FacesWebServiceClient.verificarCadastro((String) usuario.getAttribute(Columns.USU_CODIGO), (String) servidor.getAttribute(Columns.SER_CPF), responsavel);
                } catch (final UsuarioControllerException ex) {
                    if (!permiteAguardAprovacaoCadastro) {
                        throw new ViewHelperException(ex);
                    }
                }
            }

            obterTipoEntidade(usuario);
            final String tipo = (String) usuario.getAttribute("TIPO_ENTIDADE");
            final String entidade = (String) usuario.getAttribute("COD_ENTIDADE");

            // Verifica se o perfil do usuário não está bloqueado
            final String perCodigo = (String)usuario.getAttribute(Columns.UPE_PER_CODIGO);
            if ((perCodigo != null) && !"".equals(perCodigo)) {
                Short upeStatus = usuarioController.getStatusPerfil(tipo, entidade, perCodigo, responsavel);
                if ((upeStatus == null) || !upeStatus.equals(CodedValues.STS_ATIVO)) {
                    throw new ViewHelperException("mensagem.usuarioBloqueado", responsavel);
                }
            }

            final String usuCodigo = usuario.getAttribute(Columns.USU_CODIGO) != null ? usuario.getAttribute(Columns.USU_CODIGO).toString() : "";

            final String usuCpf = usuario.getAttribute(Columns.USU_CPF) != null ? usuario.getAttribute(Columns.USU_CPF).toString() : "";
            final String usuEmail = usuario.getAttribute(Columns.USU_EMAIL) != null ? usuario.getAttribute(Columns.USU_EMAIL).toString() : "";
            final String usuIPAcesso = usuario.getAttribute(Columns.USU_IP_ACESSO) != null ? usuario.getAttribute(Columns.USU_IP_ACESSO).toString() : "";
            final String usuDDNSAcesso = usuario.getAttribute(Columns.USU_DDNS_ACESSO) != null ? usuario.getAttribute(Columns.USU_DDNS_ACESSO).toString() : "";
            final String endereco = responsavel.getIpUsuario();

            final String usuCentralizador = (String) usuario.getAttribute(Columns.USU_CENTRALIZADOR);
            if (CodedValues.TPC_SIM.equals(usuCentralizador)) {
                // Verifica usuario de centralizador
                verificarUsuarioCentralizador(endereco, responsavel);
                if (!TextHelper.isNull(responsavel.getIpOrigem())) {
                    responsavel.setIpUsuario(responsavel.getIpOrigem());
                    responsavel.setPortaLogicaUsuario(responsavel.getPortaLogicaUsuario());
                }
            } else {
                // Verifica obrigatoriedade e validade do IP/DDNS de acesso
                verificarIpDDNSAcesso(tipo, entidade, endereco, usuIPAcesso, usuDDNSAcesso, usuCodigo, responsavel);
            }

            // Verifica obrigatoriedade de CPF para acesso ao sistema
            verificarCpfUsuario(tipo, usuCpf, responsavel);

            // Verifica obrigatoriedade de email para acesso ao sistema
            verificarEmailUsuario(tipo, usuEmail, responsavel);

            // Altera a data de último acesso do usuário
            final CanalEnum canal = responsavel.getCanal();
            try {
                final AcessoSistema acesso = new AcessoSistema(usuCodigo);
                acesso.setCanal(canal);
                usuarioController.alteraDataUltimoAcessoSistema(acesso);
            } catch (final UsuarioControllerException e) {
                LOG.error("Não foi possível alterar a data de último acesso ao sistema para o usuário: ['" + usuCodigo + "'].");
            }

            return usuario;

        } catch (final UsuarioControllerException ex) {
            throw new ViewHelperException("mensagem.usuarioSenhaInvalidos", responsavel);
        }
    }

    public static String obterTipoEntidade(TransferObject usuario) {
        String tipo = "";
        String entidade = "";

        final String cseCodigo = usuario.getAttribute(Columns.UCE_CSE_CODIGO) != null ? usuario.getAttribute(Columns.UCE_CSE_CODIGO).toString() : "";
        final String csaCodigo = usuario.getAttribute(Columns.UCA_CSA_CODIGO) != null ? usuario.getAttribute(Columns.UCA_CSA_CODIGO).toString() : "";
        final String corCodigo = usuario.getAttribute(Columns.UCO_COR_CODIGO) != null ? usuario.getAttribute(Columns.UCO_COR_CODIGO).toString() : "";
        final String orgCodigo = usuario.getAttribute(Columns.UOR_ORG_CODIGO) != null ? usuario.getAttribute(Columns.UOR_ORG_CODIGO).toString() : "";
        final String serCodigo = usuario.getAttribute(Columns.USE_SER_CODIGO) != null ? usuario.getAttribute(Columns.USE_SER_CODIGO).toString() : "";
        final String uspCseCodigo = usuario.getAttribute(Columns.USP_CSE_CODIGO) != null ? usuario.getAttribute(Columns.USP_CSE_CODIGO).toString() : "";

        // Determina o tipo da entidade do usuário
        if (!"".equals(cseCodigo)) {
            tipo = AcessoSistema.ENTIDADE_CSE;
            entidade = cseCodigo;
        } else if (!"".equals(csaCodigo)) {
            tipo = AcessoSistema.ENTIDADE_CSA;
            entidade = csaCodigo;
        } else if (!"".equals(corCodigo)) {
            tipo = AcessoSistema.ENTIDADE_COR;
            entidade = corCodigo;
        } else if (!"".equals(orgCodigo)) {
            tipo = AcessoSistema.ENTIDADE_ORG;
            entidade = orgCodigo;
        } else if (!"".equals(serCodigo)) {
            tipo = AcessoSistema.ENTIDADE_SER;
            entidade = serCodigo;
        } else if (!"".equals(uspCseCodigo)) {
            tipo = AcessoSistema.ENTIDADE_SUP;
            entidade = uspCseCodigo;
        }

        usuario.setAttribute("TIPO_ENTIDADE", tipo);
        usuario.setAttribute("COD_ENTIDADE", entidade);

        return tipo;
    }

    /**
     * Verifica se a licença do eConsig está válida.
     * @param licenca
     * @param rsaPublicKeyCentralizador
     * @param rsaModulusCentralizador
     * @return
     */
    public static boolean isLicencaExpirada(String licenca, String rsaPublicKeyCentralizador, String rsaModulusCentralizador) {
        // DESENV-21369 : Nunca foi usado e consome recursos sem ter possibilidade de desabilitar
        return false;
        /*
        if (TextHelper.isNull(licenca)) {
            // Se a licença é nula, é porque não foi possível conectar ao validador de licença e a licença deve ser considerada expirada.
            return true;
        }
        final Key publicKeyCentralizador = RSA.generatePublicKey(rsaModulusCentralizador, rsaPublicKeyCentralizador);
        final Key privateKeyEConsig = RSA.generatePrivateKey(CodedValues.RSA_MODULUS_ECONSIG, CodedValues.RSA_PRIVATE_KEY_ECONSIG);

        // Descriptografa com as chaves do eConsig, e com a chave publica do centralizador
        String message;
        try {
            message = RSA.decrypt(licenca, privateKeyEConsig);
            message = RSA.decrypt(message, publicKeyCentralizador);
        } catch (final BadPaddingException e) {
            // Tentativa de decriptografia com chave inválida.
            LOG.error(e.getMessage(), e);
            message = null;
        }

        final Calendar calendarLicenca = Calendar.getInstance();
        calendarLicenca.setTimeInMillis(Long.parseLong(message));

        return calendarLicenca.before(Calendar.getInstance());
        */
    }

    public static String getPapCodigo(String tipo) {
        tipo = tipo.toUpperCase();
        String papCodigo = null;

        if (AcessoSistema.ENTIDADE_CSE.equalsIgnoreCase(tipo)) { // CONSIGNANTE
            papCodigo = CodedValues.PAP_CONSIGNANTE;
        } else if (AcessoSistema.ENTIDADE_CSA.equalsIgnoreCase(tipo)) { // CONSIGNATARIA
            papCodigo = CodedValues.PAP_CONSIGNATARIA;
        } else if (AcessoSistema.ENTIDADE_EST.equalsIgnoreCase(tipo)) { // ESTABELECIMENTO
            papCodigo = CodedValues.PAP_ESTABELECIMENTO;
        } else if (AcessoSistema.ENTIDADE_ORG.equalsIgnoreCase(tipo)) { // ORGAO
            papCodigo = CodedValues.PAP_ORGAO;
        } else if (AcessoSistema.ENTIDADE_COR.equalsIgnoreCase(tipo)) { // CORRESPONDENTE
            papCodigo = CodedValues.PAP_CORRESPONDENTE;
        } else if (AcessoSistema.ENTIDADE_SER.equalsIgnoreCase(tipo)) { // SERVIDOR
            papCodigo = CodedValues.PAP_SERVIDOR;
        } else if (AcessoSistema.ENTIDADE_SUP.equalsIgnoreCase(tipo)) { // SUPORTE
            papCodigo = CodedValues.PAP_SUPORTE;
        }

        return papCodigo;
    }

    /**
     * Retorna um array de string de duas posições, contendo o IP e o DNS de acesso
     * cadastrado na entidade do usuário responsável.
     * @param responsavel
     * @return
     * @throws ViewHelperException
     */
    public static String[] obtemRestricaoIpDDNSEntidadeUsu(AcessoSistema responsavel) throws ViewHelperException {
        try {
            if (responsavel.isCse()) {
                final ConsignanteController consignanteController = ApplicationContextProvider.getApplicationContext().getBean(ConsignanteController.class);
                final ConsignanteTransferObject cse = consignanteController.findConsignante(responsavel.getCodigoEntidade(), responsavel);
                return new String[] { cse.getCseIPAcesso(), cse.getCseDDNSAcesso() };

            } else if (responsavel.isOrg()) {
                final ConsignanteController consignanteController = ApplicationContextProvider.getApplicationContext().getBean(ConsignanteController.class);
                final OrgaoTransferObject org = consignanteController.findOrgao(responsavel.getCodigoEntidade(), responsavel);
                return new String[] { org.getOrgIPAcesso(), org.getOrgDDNSAcesso() };

            } else if (responsavel.isCsa()) {
                final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                final ConsignatariaTransferObject csa = consignatariaController.findConsignataria(responsavel.getCodigoEntidade(), responsavel);
                return new String[] { csa.getCsaIPAcesso(), csa.getCsaDDNSAcesso() };

            } else if (responsavel.isCor()) {
                final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                final CorrespondenteTransferObject cor = consignatariaController.findCorrespondente(responsavel.getCodigoEntidade(), responsavel);
                return new String[] { cor.getCorIPAcesso(), cor.getCorDDNSAcesso() };
            }

            return new String[] { null, null };
        } catch (ConsignanteControllerException | ConsignatariaControllerException ex) {
            throw new ViewHelperException("mensagem.erro.validacao.restricao.ip.entidade", responsavel, ex);
        }
    }

    /**
     * Verifica se as restrições de IP ou DDNS de acesso, do usuário ou de sua entidade, são válidos
     * de acordo com as configurações do sistema. Caso exista restrição e esta esteja inválida, o método
     * retorna uma exceção com a mensagem correspondente.
     * @param tipo
     * @param codigo
     * @param endereco
     * @param usuIPAcesso
     * @param usuDDNSAcesso
     * @param responsavel
     * @return
     * @throws ViewHelperException
     */
    public static void verificarIpDDNSAcesso(String tipo, String entCodigo, String endereco, String usuIPAcesso, String usuDDNSAcesso, String usuCodigo, AcessoSistema responsavel) throws ViewHelperException {
        // Confere se cadastro de IPs de acesso é obrigatório de acordo com o tipo da entidade
        boolean vrfIpAcesso = false;
        boolean passouValidacao = false;
        boolean existeRestricao = false;
        if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
            // Deve verificar se tem IP cadastrado em usuario, consignante ou órgão.
            vrfIpAcesso = ParamSist.getBoolParamSist(CodedValues.TPC_VERIFICA_CADASTRO_IP_CSE_ORG, responsavel);
        } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) {
            // Deve verificar se tem IP cadastrado em usuario, correspondente ou consignataria.
            vrfIpAcesso = ParamSist.getBoolParamSist(CodedValues.TPC_VERIFICA_CADASTRO_IP_CSA_COR, responsavel);
        }

        final boolean paramValidaAcessoIPUsuarioOuEntidade = ParamSist.paramEquals(CodedValues.TPC_VALIDA_ACESSO_IP_POR_USUARIO_OU_ENTIDADE, CodedValues.TPC_SIM, responsavel);

        if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
            // Verifica se o cadastro de restrição no usuário sobrepõe o geral
            final boolean paramCadUsuSobrepoeGeral = !ParamSist.paramEquals(CodedValues.TPC_ENDERECO_ACESSO_USU_SOBREPOE_CSE_ORG, CodedValues.TPC_NAO, responsavel);
            if ((paramCadUsuSobrepoeGeral || AcessoSistema.ENTIDADE_SUP.equals(tipo)) && (!TextHelper.isNull(usuIPAcesso) || !TextHelper.isNull(usuDDNSAcesso))) {
                try {
                    validaIpDDNS(usuIPAcesso, usuDDNSAcesso, endereco);
                    passouValidacao = true;
                } catch (final ViewHelperException exception) {
                    existeRestricao = true;
                    if (!paramValidaAcessoIPUsuarioOuEntidade) {
                        throw exception;
                    }
                }
            }

            if (!passouValidacao && !paramCadUsuSobrepoeGeral) {
                if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                    // Validacao de IP e DDNS de consignante
                    try {
                        final ConsignanteController consignanteController = ApplicationContextProvider.getApplicationContext().getBean(ConsignanteController.class);
                        final ConsignanteTransferObject cse = consignanteController.findConsignante(entCodigo, responsavel);

                        if (vrfIpAcesso && TextHelper.isNull(cse.getCseIPAcesso()) && TextHelper.isNull(cse.getCseDDNSAcesso())) {
                            throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }

                        validaIpDDNS(cse.getCseIPAcesso(), cse.getCseDDNSAcesso(), endereco);
                        passouValidacao = true;

                    } catch (final ConsignanteControllerException e) {
                        throw new ViewHelperException(e);
                    }

                } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                    // Validacao de IP e DDNS de órgão
                    try {
                        final ConsignanteController consignanteController = ApplicationContextProvider.getApplicationContext().getBean(ConsignanteController.class);
                        final OrgaoTransferObject org = consignanteController.findOrgao(entCodigo, responsavel);

                        if (vrfIpAcesso && TextHelper.isNull(org.getOrgIPAcesso()) && TextHelper.isNull(org.getOrgDDNSAcesso())) {
                            throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }

                        validaIpDDNS(org.getOrgIPAcesso(), org.getOrgDDNSAcesso(), endereco);
                        passouValidacao = true;

                    } catch (final ConsignanteControllerException e) {
                        throw new ViewHelperException(e);
                    }
                }
            } else {

                String perIpAcesso = null;
                String perDdnsAcesso = null;
                Perfil perfil = new Perfil();

                try {
                    final UsuarioDelegate usuDelegate = new UsuarioDelegate();

                    perfil = usuDelegate.findPerfilByUsuCodigo(usuCodigo, responsavel);

                    perIpAcesso = perfil.getPerIpAcesso();
                    perDdnsAcesso = perfil.getPerDdnsAcesso();
                } catch (final UsuarioControllerException e) {
                    //Não achar o perfil, não é erro!
                }

                if (!TextHelper.isNull(perIpAcesso) || !TextHelper.isNull(perDdnsAcesso)) {
                    try {
                        validaIpDDNS(perIpAcesso, perDdnsAcesso, endereco);
                        passouValidacao = true;
                    } catch (final ViewHelperException exception) {
                        existeRestricao = true;
                        if (!paramValidaAcessoIPUsuarioOuEntidade) {
                            throw new ViewHelperException(exception);
                        } else if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                            // Validacao de IP e DDNS de consignante
                            try {
                                final ConsignanteDelegate cseDelegate = new ConsignanteDelegate();
                                final ConsignanteTransferObject cse = cseDelegate.findConsignante(entCodigo, responsavel);

                                if (vrfIpAcesso && TextHelper.isNull(cse.getCseIPAcesso()) && TextHelper.isNull(cse.getCseDDNSAcesso())) {
                                    throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                                }

                                if (!TextHelper.isNull(cse.getCseIPAcesso()) || !TextHelper.isNull(cse.getCseDDNSAcesso())) {
                                    validaIpDDNS(cse.getCseIPAcesso(), cse.getCseDDNSAcesso(), endereco);
                                    passouValidacao = true;
                                }

                            } catch (final ConsignanteControllerException e) {
                                throw new ViewHelperException(e);
                            }

                        } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                            // Validacao de IP e DDNS de órgão
                            try {
                                final ConsignanteDelegate cseDelegate = new ConsignanteDelegate();
                                final OrgaoTransferObject org = cseDelegate.findOrgao(entCodigo, responsavel);

                                if (vrfIpAcesso && TextHelper.isNull(org.getOrgIPAcesso()) && TextHelper.isNull(org.getOrgDDNSAcesso())) {
                                    throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                                }

                                if (!TextHelper.isNull(org.getOrgIPAcesso()) || !TextHelper.isNull(org.getOrgDDNSAcesso())) {
                                    validaIpDDNS(org.getOrgIPAcesso(), org.getOrgDDNSAcesso(), endereco);
                                    passouValidacao = true;
                                }

                            } catch (final ConsignanteControllerException e) {
                                throw new ViewHelperException(e);
                            }
                        } else {
                            throw new ViewHelperException("rotulo.endereco.acesso.invalido.ip", (AcessoSistema) null, endereco);
                        }
                    }
                } else if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                    // Validacao de IP e DDNS de consignante
                    try {
                        final ConsignanteDelegate cseDelegate = new ConsignanteDelegate();
                        final ConsignanteTransferObject cse = cseDelegate.findConsignante(entCodigo, responsavel);

                        if (vrfIpAcesso && TextHelper.isNull(cse.getCseIPAcesso()) && TextHelper.isNull(cse.getCseDDNSAcesso())) {
                            throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }

                        if (!TextHelper.isNull(cse.getCseIPAcesso()) || !TextHelper.isNull(cse.getCseDDNSAcesso())) {
                            validaIpDDNS(cse.getCseIPAcesso(), cse.getCseDDNSAcesso(), endereco);
                            passouValidacao = true;
                        }

                    } catch (final ConsignanteControllerException e) {
                        throw new ViewHelperException(e);
                    }

                } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                    // Validacao de IP e DDNS de órgão
                    try {
                        final ConsignanteDelegate cseDelegate = new ConsignanteDelegate();
                        final OrgaoTransferObject org = cseDelegate.findOrgao(entCodigo, responsavel);

                        if (vrfIpAcesso && TextHelper.isNull(org.getOrgIPAcesso()) && TextHelper.isNull(org.getOrgDDNSAcesso())) {
                            throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }

                        if (!TextHelper.isNull(org.getOrgIPAcesso()) || !TextHelper.isNull(org.getOrgDDNSAcesso())) {
                            validaIpDDNS(org.getOrgIPAcesso(), org.getOrgDDNSAcesso(), endereco);
                            passouValidacao = true;
                        }

                    } catch (final ConsignanteControllerException e) {
                        throw new ViewHelperException(e);
                    }
                }
            }

            if ((!passouValidacao && existeRestricao) && !responsavel.isNavegadorExclusivo()) {
                throw new ViewHelperException("rotulo.endereco.acesso.invalido.ip", (AcessoSistema) null, endereco);
            }

        } else {
            // Verifica o usuário tem permissão para acessar o sistema a partir de seu IP ou DDNS
            if (!TextHelper.isNull(usuIPAcesso) || !TextHelper.isNull(usuDDNSAcesso)) {
                try {
                    validaIpDDNS(usuIPAcesso, usuDDNSAcesso, endereco);
                    passouValidacao = true;
                } catch (final ViewHelperException exception) {
                    existeRestricao = true;
                    if (!paramValidaAcessoIPUsuarioOuEntidade) {
                        throw new ViewHelperException(exception);
                    }
                }
            }

            if (!passouValidacao) {

                String perIpAcesso = null;
                String perDdnsAcesso = null;
                Perfil perfil = new Perfil();

                try {
                    final UsuarioDelegate usuDelegate = new UsuarioDelegate();

                    perfil = usuDelegate.findPerfilByUsuCodigo(usuCodigo, responsavel);

                    perIpAcesso = perfil.getPerIpAcesso();
                    perDdnsAcesso = perfil.getPerDdnsAcesso();
                } catch (final UsuarioControllerException e) {
                    //Não achar o perfil, não é erro!
                }

                if (!TextHelper.isNull(perIpAcesso) || !TextHelper.isNull(perDdnsAcesso)) {
                    try {
                        validaIpDDNS(perIpAcesso, perDdnsAcesso, endereco);
                        passouValidacao = true;
                    } catch (final ViewHelperException exception) {
                        existeRestricao = true;
                        if (!paramValidaAcessoIPUsuarioOuEntidade) {
                            throw new ViewHelperException(exception);
                        } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                            // Validacao de IP e DDNS de consignataria
                            try {
                                final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                                final ConsignatariaTransferObject csa = consignatariaController.findConsignataria(entCodigo, responsavel);

                                // Se o campo csaExigeEnderecoAcesso estiver preenchido, ele prevalece sobre o parametro 224
                                vrfIpAcesso = (csa.getCsaExigeEnderecoAcesso() != null) ? CodedValues.TPC_SIM.equals(csa.getCsaExigeEnderecoAcesso()) : vrfIpAcesso;

                                if (vrfIpAcesso && TextHelper.isNull(csa.getCsaIPAcesso()) && TextHelper.isNull(csa.getCsaDDNSAcesso())) {
                                    throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                                }

                                if (!TextHelper.isNull(csa.getCsaIPAcesso()) || !TextHelper.isNull(csa.getCsaDDNSAcesso())) {
                                    validaIpDDNS(csa.getCsaIPAcesso(), csa.getCsaDDNSAcesso(), endereco);
                                    passouValidacao = true;
                                }

                            } catch (final ConsignatariaControllerException e) {
                                throw new ViewHelperException(e);
                            }

                        } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                            // Validacao de IP e DDNS de correspondente
                            try {
                                final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                                final CorrespondenteTransferObject cor = consignatariaController.findCorrespondente(entCodigo, responsavel);

                                // Se o campo corExigeEnderecoAcesso estiver preenchido, ele prevalece sobre o parametro 224
                                vrfIpAcesso = (cor.getCorExigeEnderecoAcesso() != null) ? CodedValues.TPC_SIM.equals(cor.getCorExigeEnderecoAcesso()) : vrfIpAcesso;

                                if (vrfIpAcesso && TextHelper.isNull(cor.getCorIPAcesso()) && TextHelper.isNull(cor.getCorDDNSAcesso())) {
                                    throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                                }

                                if (!TextHelper.isNull(cor.getCorIPAcesso()) || !TextHelper.isNull(cor.getCorDDNSAcesso())) {
                                    validaIpDDNS(cor.getCorIPAcesso(), cor.getCorDDNSAcesso(), endereco);
                                    passouValidacao = true;
                                }

                            } catch (final ConsignatariaControllerException e) {
                                throw new ViewHelperException(e);
                            }
                        }
                    }
                } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                    // Validacao de IP e DDNS de consignataria
                    try {
                        final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                        final ConsignatariaTransferObject csa = consignatariaController.findConsignataria(entCodigo, responsavel);

                        // Se o campo csaExigeEnderecoAcesso estiver preenchido, ele prevalece sobre o parametro 224
                        vrfIpAcesso = (csa.getCsaExigeEnderecoAcesso() != null) ? CodedValues.TPC_SIM.equals(csa.getCsaExigeEnderecoAcesso()) : vrfIpAcesso;

                        if (vrfIpAcesso && TextHelper.isNull(csa.getCsaIPAcesso()) && TextHelper.isNull(csa.getCsaDDNSAcesso())) {
                            throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }

                        if (!TextHelper.isNull(csa.getCsaIPAcesso()) || !TextHelper.isNull(csa.getCsaDDNSAcesso())) {
                            validaIpDDNS(csa.getCsaIPAcesso(), csa.getCsaDDNSAcesso(), endereco);
                            passouValidacao = true;
                        }

                    } catch (final ConsignatariaControllerException e) {
                        throw new ViewHelperException(e);
                    }

                } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                    // Validacao de IP e DDNS de correspondente
                    try {
                        final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                        final CorrespondenteTransferObject cor = consignatariaController.findCorrespondente(entCodigo, responsavel);

                        // Se o campo corExigeEnderecoAcesso estiver preenchido, ele prevalece sobre o parametro 224
                        vrfIpAcesso = (cor.getCorExigeEnderecoAcesso() != null) ? CodedValues.TPC_SIM.equals(cor.getCorExigeEnderecoAcesso()) : vrfIpAcesso;

                        if (vrfIpAcesso && TextHelper.isNull(cor.getCorIPAcesso()) && TextHelper.isNull(cor.getCorDDNSAcesso())) {
                            throw new ViewHelperException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }

                        if (!TextHelper.isNull(cor.getCorIPAcesso()) || !TextHelper.isNull(cor.getCorDDNSAcesso())) {
                            validaIpDDNS(cor.getCorIPAcesso(), cor.getCorDDNSAcesso(), endereco);
                            passouValidacao = true;
                        }

                    } catch (final ConsignatariaControllerException e) {
                        throw new ViewHelperException(e);
                    }
                }
            }
            if ((!passouValidacao && existeRestricao) && !responsavel.isNavegadorExclusivo()) {
                throw new ViewHelperException("rotulo.endereco.acesso.invalido.ip", (AcessoSistema) null, endereco);
            }
        }
    }

    private static void validaIpDDNS(String restricaoIpAcesso, String restricaoDDNSAcesso, String endereco) throws ViewHelperException {
        if (!TextHelper.isNull(restricaoIpAcesso)) {
            if (!JspHelper.validaIp(endereco, restricaoIpAcesso)) {
                if (!TextHelper.isNull(restricaoDDNSAcesso)) {
                    if (!JspHelper.validaDDNS(endereco, restricaoDDNSAcesso)) {
                        throw new ViewHelperException("rotulo.endereco.acesso.invalido.ip", (AcessoSistema) null, endereco);
                    }
                } else {
                    throw new ViewHelperException("rotulo.endereco.acesso.invalido.ip", (AcessoSistema) null, endereco);
                }
            }
        } else if (!TextHelper.isNull(restricaoDDNSAcesso) && !JspHelper.validaDDNS(endereco, restricaoDDNSAcesso)) {
            throw new ViewHelperException("rotulo.endereco.acesso.invalido.ip", (AcessoSistema) null, endereco);
        }
    }

    private static void verificarUsuarioCentralizador(String endereco, AcessoSistema responsavel) throws ViewHelperException {
        final Object paramUrlCentralizador = ParamSist.getInstance().getParam(CodedValues.TPC_URL_CENTRALIZADOR, responsavel);
        final String urlCentralizador = (paramUrlCentralizador != null) ? (String) paramUrlCentralizador : "";
        if (!"".equals(urlCentralizador)) {
            final List<String> urls = Arrays.asList(urlCentralizador.split(";"));
            if (!JspHelper.validaUrl(endereco, urls)) {
                throw new ViewHelperException("mensagem.enderecoAcessoCentralizadorInvalido", responsavel);
            }
        } else {
            throw new ViewHelperException("mensagem.urlAcessoNaoCadastradaCentralizador", responsavel);
        }
    }

    /**
     * Verifica os parâmetros de sistema para determinar se o usuário deve possuir
     * CPF cadastrado no sistema para acessá-lo.
     *
     * @param tipoEntidade
     * @param cpf
     * @param responsavel
     * @throws ViewHelperException
     */
    public static void verificarCpfUsuario(String tipoEntidade, String cpf, AcessoSistema responsavel) throws ViewHelperException {
        boolean bloqueiaAcessoUsuSemCpf = false;
        if (!TextHelper.isNull(tipoEntidade)) {
            if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade) || AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade) || AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
                bloqueiaAcessoUsuSemCpf = ParamSist.paramEquals(CodedValues.TPC_BLOQUEIA_LOGIN_USU_SEM_CPF_CSE_ORG, CodedValues.TPC_SIM, responsavel);
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade) || AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
                bloqueiaAcessoUsuSemCpf = ParamSist.paramEquals(CodedValues.TPC_BLOQUEIA_LOGIN_USU_SEM_CPF_CSA_COR, CodedValues.TPC_SIM, responsavel);
            }
        }

        if (bloqueiaAcessoUsuSemCpf && TextHelper.isNull(cpf)) {
            throw new ViewHelperException("mensagem.cpfUsuarioObrigatorio", responsavel);
        }
    }

    /**
     * Verifica os parâmetros de sistema para determinar se o usuário deve possuir
     * CPF cadastrado no sistema para acessá-lo.
     * @param tipoEntidade
     * @param cpf
     * @param responsavel
     * @throws ViewHelperException
     */
    public static void verificarEmailUsuario(String tipoEntidade, String email, AcessoSistema responsavel) throws ViewHelperException {
        boolean bloqueiaAcessoUsuSemEmail = false;
        if (!TextHelper.isNull(tipoEntidade)) {
            if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade) || AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade) || AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
                bloqueiaAcessoUsuSemEmail = ParamSist.paramEquals(CodedValues.TPC_BLOQUEIA_LOGIN_USU_SEM_EMAIL_CSE_ORG_SUP, CodedValues.TPC_SIM, responsavel);
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade) || AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
                bloqueiaAcessoUsuSemEmail = ParamSist.paramEquals(CodedValues.TPC_BLOQUEIA_LOGIN_USU_SEM_EMAIL_CSA_COR, CodedValues.TPC_SIM, responsavel);
            }
        }

        if (bloqueiaAcessoUsuSemEmail && TextHelper.isNull(email)) {
            throw new ViewHelperException("mensagem.emailUsuarioObrigatorio", responsavel);
        }
    }

    /**
     * Metodo usado no login do usuario para verificar se ele precisa validar o certificado digital.
     * Tambem é usado nas telas de manutencao do usuario para exibir o valor correto do campo
     * UsuExigeCertificado, o qual deve levar em consideracao os parametros:
     * TPC_EXIGE_CERTIFICADO_DIGITAL_CSE_ORG,
     * TPC_EXIGE_CERTIFICADO_DIGITAL_CSA_COR, TPC_PERMITE_CSA_OPTAR_CERTIF_DIGITAL,
     * TPA_EXIGE_CERTIFICADO_DIGITAL e TPA_PERMITE_USU_OPTAR_CERTIF_DIGITAL.
     * Essa validacao não é feita na autenticacao de usuario via XML ou entrada em lote.
     * @param usuLogin Login do usuario.
     * @param usuExigeCertificado Valor do campo do usuario.
     * @param tipo Tipo da entidade. Se for CSA ou COR, o parametro
     * @param codigo Codigo da entidade. Usado para encontrar a
     * @param responsavel Usuario logado no sistema.
     * @return Verdadeiro ou falso, caso o usuario tenha ou nao que validar o certificado.
     * @throws ViewHelperException Excecao padrao da camada de visao.
     */
    public static boolean isUsuarioCertificadoDigital(String usuLogin, String usuExigeCertificado, String tipo, String codigo, AcessoSistema responsavel) throws ViewHelperException {
        boolean usaCertificado = false;

        if (!TextHelper.isNull(tipo)) {
            if (AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) {

                // Parametro de sistema que indica se exige certificado digital para CSA/COR
                if (ParamSist.paramEquals(CodedValues.TPC_EXIGE_CERTIFICADO_DIGITAL_CSA_COR, CodedValues.TPC_SIM, responsavel)) {
                    usaCertificado = true;
                }

                // Verifica se a CSA/COR pode optar pelo uso do certificado, o que vai sobrepor
                // o parametro acima
                if (ParamSist.paramEquals(CodedValues.TPC_PERMITE_CSA_OPTAR_CERTIF_DIGITAL, CodedValues.TPC_SIM, responsavel)) {

                    String csaCodigo = null;

                    if (!TextHelper.isNull(codigo)) {
                        if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                            csaCodigo = codigo;
                        } else {
                            try {
                                final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                                final CorrespondenteTransferObject cor = consignatariaController.findCorrespondente(codigo, responsavel);
                                csaCodigo = cor.getCsaCodigo();
                            } catch (final ConsignatariaControllerException e) {
                                // Se der erro, tenta encontrar o csaCodigo novamente abaixo
                            }
                        }
                    }

                    // Procura o codigo da consignataria atraves do login do usuario
                    if ((csaCodigo == null) && !TextHelper.isNull(usuLogin)) {
                        try {
                            final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
                            final TransferObject usuario = usuarioController.findTipoUsuarioByLogin(usuLogin, responsavel);
                            final String csa_codigo = !TextHelper.isNull(usuario.getAttribute(Columns.UCA_CSA_CODIGO)) ? usuario.getAttribute(Columns.UCA_CSA_CODIGO).toString() : null;
                            final String cor_codigo = !TextHelper.isNull(usuario.getAttribute(Columns.UCO_COR_CODIGO)) ? usuario.getAttribute(Columns.UCO_COR_CODIGO).toString() : null;
                            if (csa_codigo != null) {
                                csaCodigo = csa_codigo;
                            } else if (cor_codigo != null) {
                                final ConsignatariaController consignatariaController = ApplicationContextProvider.getApplicationContext().getBean(ConsignatariaController.class);
                                final CorrespondenteTransferObject cor = consignatariaController.findCorrespondente(cor_codigo, responsavel);
                                csaCodigo = cor.getCsaCodigo();
                            }
                        } catch (UsuarioControllerException | ConsignatariaControllerException e) {
                            throw new ViewHelperException("mensagem.erro.obter.tipo.usuario", responsavel);
                        }
                    }

                    if (csaCodigo != null) {
                        // Verifica parametro de consignataria que vale para todos os seus usuarios
                        try {
                            final ParametroController parametroController = ApplicationContextProvider.getApplicationContext().getBean(ParametroController.class);
                            final String pcsVlr = parametroController.getParamCsa(csaCodigo, CodedValues.TPA_EXIGE_CERTIFICADO_DIGITAL, responsavel);
                            // Só avalia o parâmetro de CSA se este não for nulo, para não sobrepor a variável neste cenário
                            if (!TextHelper.isNull(pcsVlr)) {
                                usaCertificado = "S".equals(pcsVlr);
                            }
                        } catch (final ParametroControllerException ex) {
                            throw new ViewHelperException("mensagem.erro.obter.parametro.consignataria", responsavel);
                        }

                        // Verifica parametro de consignataria que vale para um usuario especifico e sobrepoe todos
                        if (!TextHelper.isNull(usuExigeCertificado)) {
                            try {
                                final ParametroController parametroController = ApplicationContextProvider.getApplicationContext().getBean(ParametroController.class);
                                final String pcsVlr = parametroController.getParamCsa(csaCodigo, CodedValues.TPA_PERMITE_USU_OPTAR_CERTIF_DIGITAL, responsavel);
                                if ("S".equals(pcsVlr)) {
                                    if (CodedValues.TPC_SIM.equals(usuExigeCertificado)) {
                                        usaCertificado = true;
                                    } else if (CodedValues.TPC_NAO.equals(usuExigeCertificado)) {
                                        usaCertificado = false;
                                    }
                                }
                            } catch (final ParametroControllerException ex) {
                                throw new ViewHelperException("mensagem.erro.obter.parametro.consignataria", responsavel);
                            }
                        }
                    }
                }

            } else if ((AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo)) && ParamSist.paramEquals(CodedValues.TPC_EXIGE_CERTIFICADO_DIGITAL_CSE_ORG, CodedValues.TPC_SIM, responsavel)) {
                // Parametro de sistema que indica se exige certificado digital para CSE/ORG
                usaCertificado = true;

            } else if (!TextHelper.isNull(usuExigeCertificado) && CodedValues.TPC_SIM.equals(usuExigeCertificado)) {
                usaCertificado = true;
            } // Nao precisa verificar o TPC_NAO, pois ja esta false
        }

        return usaCertificado;
    }

    /**
     * Verifica se servidor já acessou o sistema ao menos uma vez com alguma de suas matrículas em algum órgão
     * @param serCpf - cpf do servidor
     * @param lstRegistroServidores - lista de registros do servidor
     * @return
     * @throws HQueryException
     * @throws UsuarioControllerException
     */
    public static boolean primeiroAcessoSistema(String serCpf, List<TransferObject> lstRegistroServidores, AcessoSistema responsavel) throws ViewHelperException {
        try {
            if (TextHelper.isNull(serCpf)) {
                throw new ViewHelperException("mensagem.erro.servidor.nao.encontrado", responsavel);
            }

            final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);

            if ((lstRegistroServidores != null) && !lstRegistroServidores.isEmpty()) {
                for (final TransferObject rse : lstRegistroServidores) {
                    final List<TransferObject> lstUsuResult = usuarioController.lstUsuariosSer(serCpf, (String) rse.getAttribute(Columns.RSE_MATRICULA), (String) rse.getAttribute(Columns.EST_IDENTIFICADOR), (String) rse.getAttribute(Columns.ORG_IDENTIFICADOR), null);

                    for (final TransferObject usuarioSer : lstUsuResult) {
                        if (!TextHelper.isNull(usuarioSer.getAttribute(Columns.USU_DATA_ULT_ACESSO))) {
                            return false;
                        }
                    }
                }
            } else {
                final List<TransferObject> lstUsuResult = usuarioController.lstUsuariosSer(serCpf, null, null, null, null);

                if ((lstUsuResult == null) || lstUsuResult.isEmpty()) {
                    throw new ViewHelperException("mensagem.erro.servidor.nao.encontrado", responsavel);
                }

                for (final TransferObject usuarioSer : lstUsuResult) {
                    if (!TextHelper.isNull(usuarioSer.getAttribute(Columns.USU_DATA_ULT_ACESSO))) {
                        return false;
                    }
                }
            }

        } catch (final UsuarioControllerException e) {
            throw new ViewHelperException(e.getMessageKey(), responsavel);
        }

        return true;
    }

    /**
     * valida token de fluxo de caso de uso de validação de OTP de usuário servidor
     * @param usuCodigo
     * @param token
     * @param responsavel
     * @return
     * @throws ViewHelperException
     */
    public static boolean isTokenOtpPageValido(String usuCodigo, String token, AcessoSistema responsavel) throws ViewHelperException {
        try {
            final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
            final UsuarioTransferObject usuTO = usuarioController.findUsuario(usuCodigo, responsavel);
            final String tokenSistema = usuTO.getUsuOtpChaveSeguranca();
            return !TextHelper.isNull(tokenSistema) && tokenSistema.equalsIgnoreCase(token);
        } catch (final UsuarioControllerException e) {
            throw new ViewHelperException(e.getMessageKey(), responsavel);
        }
    }

    public static boolean isTotpValidoUsuario(String otpInformado, PermiteValidacaoTotpEnum permiteValidacaoTotp, String chaveValidacaoTotpProvisoria, long timeInMilliseconds, AcessoSistema responsavel) throws ViewHelperException {
        // Configuração de uso de TOTP cadastrada no registro do usuário
        if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.APP)) {
            final GoogleAuthenticatorHelper authenticator = new GoogleAuthenticatorHelper();

            // Verificar código de segurança informado
            final String usuChaveValidacaoTotp = !TextHelper.isNull(responsavel.getUsuChaveValidacaoTotp()) ? responsavel.getUsuChaveValidacaoTotp() : chaveValidacaoTotpProvisoria;
            if (!authenticator.checkCode(usuChaveValidacaoTotp, Long.valueOf(otpInformado), timeInMilliseconds)) {
                registrarLogErroSegurancaUsuario(ApplicationResourcesHelper.getMessage("mensagem.totp.codigo.invalido", responsavel), responsavel);
                throw new ViewHelperException("mensagem.totp.codigo.invalido", responsavel);
            }
        } else if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) || permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS)) {
            try {
                final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
                if (responsavel.isSer()) {
                    usuarioController.validarOtpServidorEnviadoPorEmailOuCelular(responsavel.getUsuCodigo(), otpInformado, responsavel);
                } else {
                    usuarioController.validarOtpUsuarioEnviadoPorEmailOuCelular(responsavel.getUsuCodigo(), otpInformado, responsavel);
                }
            } catch (UsuarioControllerException ex) {
                // Repassa o erro original, que pode ser de token inválido ou expirado
                registrarLogErroSegurancaUsuario(ex.getMessage(), responsavel);
                throw new ViewHelperException(ex);
            }
        } else {
            throw new ViewHelperException("mensagem.usoIncorretoSistema", responsavel);
        }

        return true;
    }

    private static void registrarLogErroSegurancaUsuario(String mensagem, AcessoSistema responsavel) {
        try {
            final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_ERRO_SEGURANCA);
            log.setUsuario(responsavel.getUsuCodigo());
            log.add(ApplicationResourcesHelper.getMessage("rotulo.erro.upper.arg0", responsavel, mensagem));
            log.write();
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
        }
    }

    /**
     * verifica se o usuário autenticou o email cadastrado
     * @param tipoEntidade
     * @param dataValidacaoEmail
     * @param responsavel
     * @return
     * @throws ViewHelperException
     */
    public static boolean usuarioValidouEmail(String tipoEntidade, String dataValidacaoEmail, AcessoSistema responsavel) throws ViewHelperException {
        boolean validarEmailUsuario = false;

        if (!TextHelper.isNull(tipoEntidade)) {
            if (ParamSist.paramEquals(CodedValues.TPC_VALIDA_EMAIL_PAPEL_USUARIO_CSE_ORG_SUP, CodedValues.TPC_SIM, responsavel) && (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade) || AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade) || AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade))) {
                validarEmailUsuario = true;

            } else if (ParamSist.paramEquals(CodedValues.TPC_VALIDA_EMAIL_PAPEL_USUARIO_CSA_COR, CodedValues.TPC_SIM, responsavel) && (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade) || AcessoSistema.ENTIDADE_COR.equals(tipoEntidade))) {
                validarEmailUsuario = true;
            }
        }

        return !validarEmailUsuario || !TextHelper.isNull(dataValidacaoEmail);
    }

    /**
     * verifica parâmetros pertinentes ao bloqueio por inatividade e bloqueia usuário(s) caso a data configurada de inatividade tenha sido excedida.
     * @param usuCodigo - código do usuário a verificar bloqueio. Para verificar para todos usuários, informe null.
     * @param responsavel
     * @return retorna true se um ou mais usuários foram bloqueados por inatividade
     * @throws UsuarioControllerException
     */
    public static boolean bloqueioAutomaticoPorInatividade(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
		final Integer diasSemAcessoCse = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSE_SEM_ACESSO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSE_SEM_ACESSO, responsavel).toString()) : 0;
        final Integer diasSemAcessoCsa = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSA_SEM_ACESSO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSA_SEM_ACESSO, responsavel).toString()) : 0;
        final Integer diasSemAcessoSer = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_SER_SEM_ACESSO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_SER_SEM_ACESSO, responsavel).toString()) : 0;

        List<TransferObject> lista = null;
        if ((diasSemAcessoCse > 0) || (diasSemAcessoCsa > 0) || (diasSemAcessoSer > 0)) {
            final Integer qtdeHorasPrazoLoginUsuario = maxHorasParaLogarAposDesbloqueio(responsavel);

            final Calendar data = Calendar.getInstance();
            data.add(Calendar.HOUR, -qtdeHorasPrazoLoginUsuario);

            final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
            lista = usuarioController.listarBloqueiaUsuariosInativos(usuCodigo, data.getTime(), responsavel);
            if ((lista != null) && !lista.isEmpty()) {
                for (final TransferObject to : lista) {
                    bloqueiaUsuarioAutomaticamente(responsavel, to);
                }
            }
        }

        return (lista != null) && !lista.isEmpty();
	}

    /**
     * Recupera CPF do usuário servidor de acordo com o email informado.
     * @param email
     * @param cpf
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
	public static String getCPFByUsuEmailSer(String email, AcessoSistema responsavel) throws UsuarioControllerException {
        // busca o cpf do servidor a partir do e-mail
        final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
		final List<UsuarioTransferObject> lstCpf = usuarioController.lstUsuariosSerByEmail(email, responsavel);

		return ((lstCpf != null) && !lstCpf.isEmpty()) ? lstCpf.get(0).getUsuCPF() : null;
	}

	private static Integer maxHorasParaLogarAposDesbloqueio(AcessoSistema responsavel) {
		// DESENV-14804 Quantidade de horas que o usuário tem de prazo para logar no sistema após o desbloqueio no sistema.
		Integer qtdeHorasPrazoLoginUsuario = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_HORAS_USUARIO_LOGAR_APOS_DESBLOQUEIO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_HORAS_USUARIO_LOGAR_APOS_DESBLOQUEIO, responsavel).toString()) : 48;
		// Prazo máximo permitido será 10 (dez) dias, ou seja 240 horas.
		if (qtdeHorasPrazoLoginUsuario > 240) {
		    qtdeHorasPrazoLoginUsuario = 240;
		}
		return qtdeHorasPrazoLoginUsuario;
	}

	private static void bloqueiaUsuarioAutomaticamente(AcessoSistema responsavel, TransferObject to) {
		final String innerUsuCodigo = to.getAttribute(Columns.USU_CODIGO).toString();

		// Altera status do usuário para bloqueado automaticamente
		final UsuarioTransferObject usuario = new UsuarioTransferObject(innerUsuCodigo);
		usuario.setStuCodigo(CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE);
		usuario.setUsuTipoBloq(ApplicationResourcesHelper.getMessage("mensagem.usuario.bloqueado.inatividade", responsavel));

		// Grava ocorrência de bloqueio automático do usuário por inatividade
		final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
		ocorrencia.setUsuCodigo(innerUsuCodigo);
		ocorrencia.setTocCodigo(CodedValues.TOC_BLOQUEIO_AUTOMATICO_USUARIO);
		ocorrencia.setOusUsuCodigo((responsavel.getUsuCodigo() != null) ? responsavel.getUsuCodigo() : AcessoSistema.getAcessoUsuarioSistema().getUsuCodigo());
		ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.bloqueio.automatico.usuario.inatividade", responsavel));
		ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

		try {
            final UsuarioController usuarioController = ApplicationContextProvider.getApplicationContext().getBean(UsuarioController.class);
		    usuarioController.updateUsuario(usuario, ocorrencia, null, null, null, null, null, responsavel);
		} catch (final UsuarioControllerException e) {
		    LOG.debug("Erro na tentativa de bloquear usuário: " + innerUsuCodigo);
		    LOG.debug(e);
		}
	}
}


package com.zetra.econsig.service.usuario;

import java.io.File;
import java.io.IOException;
import java.sql.Date;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import com.zetra.econsig.config.SysConfig;
import com.zetra.econsig.web.ApplicationContextProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.interceptor.TransactionAspectSupport;

import com.zetra.econsig.delegate.LogDelegate;
import com.zetra.econsig.dto.CustomTransferObject;
import com.zetra.econsig.dto.TransferObject;
import com.zetra.econsig.dto.entidade.ConsignanteTransferObject;
import com.zetra.econsig.dto.entidade.ConsignatariaTransferObject;
import com.zetra.econsig.dto.entidade.CorrespondenteTransferObject;
import com.zetra.econsig.dto.entidade.EnderecoFuncaoTransferObject;
import com.zetra.econsig.dto.entidade.OcorrenciaUsuarioTransferObject;
import com.zetra.econsig.dto.entidade.OrgaoTransferObject;
import com.zetra.econsig.dto.entidade.RegistroServidorTO;
import com.zetra.econsig.dto.entidade.ServidorTransferObject;
import com.zetra.econsig.dto.entidade.UsuarioTransferObject;
import com.zetra.econsig.exception.AutorizacaoControllerException;
import com.zetra.econsig.exception.ConsignanteControllerException;
import com.zetra.econsig.exception.ConsignatariaControllerException;
import com.zetra.econsig.exception.CorrespondenteControllerException;
import com.zetra.econsig.exception.CreateException;
import com.zetra.econsig.exception.DAOException;
import com.zetra.econsig.exception.FindException;
import com.zetra.econsig.exception.HQueryException;
import com.zetra.econsig.exception.HistoricoArquivoControllerException;
import com.zetra.econsig.exception.LogControllerException;
import com.zetra.econsig.exception.ParametroControllerException;
import com.zetra.econsig.exception.RemoveException;
import com.zetra.econsig.exception.SSOException;
import com.zetra.econsig.exception.ServicoControllerException;
import com.zetra.econsig.exception.ServidorControllerException;
import com.zetra.econsig.exception.UpdateException;
import com.zetra.econsig.exception.UsuarioControllerException;
import com.zetra.econsig.exception.ViewHelperException;
import com.zetra.econsig.exception.ZetraException;
import com.zetra.econsig.helper.arquivo.FileHelper;
import com.zetra.econsig.helper.criptografia.JCrypt;
import com.zetra.econsig.helper.email.EnviaEmailHelper;
import com.zetra.econsig.helper.emailexterno.ConsultarEmailExternoServidor;
import com.zetra.econsig.helper.emailexterno.ConsultarEmailExternoServidorFactory;
import com.zetra.econsig.helper.log.Log;
import com.zetra.econsig.helper.parametro.ParamSist;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.helper.seguranca.SynchronizerToken;
import com.zetra.econsig.helper.senha.GeradorSenhaUtil;
import com.zetra.econsig.helper.senha.SenhaHelper;
import com.zetra.econsig.helper.senhaexterna.SenhaExterna;
import com.zetra.econsig.helper.sms.EnviaSMSHelper;
import com.zetra.econsig.helper.sms.SMSHelper;
import com.zetra.econsig.helper.texto.ApplicationResourcesHelper;
import com.zetra.econsig.helper.texto.DateHelper;
import com.zetra.econsig.helper.texto.LocaleHelper;
import com.zetra.econsig.helper.texto.TextHelper;
import com.zetra.econsig.helper.usuario.UsuarioHelper;
import com.zetra.econsig.helper.web.JspHelper;
import com.zetra.econsig.parser.EscritorArquivoTexto;
import com.zetra.econsig.parser.EscritorMemoria;
import com.zetra.econsig.parser.Leitor;
import com.zetra.econsig.parser.LeitorListTO;
import com.zetra.econsig.parser.ParserException;
import com.zetra.econsig.parser.Tradutor;
import com.zetra.econsig.persistence.entity.*;
import com.zetra.econsig.persistence.query.funcao.FuncoesPerfilQuery;
import com.zetra.econsig.persistence.query.funcao.FuncoesPerfilRestricaoAcessoQuery;
import com.zetra.econsig.persistence.query.funcao.FuncoesPersonalizadasQuery;
import com.zetra.econsig.persistence.query.funcao.FuncoesPersonalizadasRestricaoAcessoQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncaoPerfilTodasEntidadesQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesAuditadasQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesAuditaveisPapelQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesBloqueadasQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesBloqueaveisQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesPerfilQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesPermitidasNcaQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesPermitidasPapelQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesRegraTaxaQuery;
import com.zetra.econsig.persistence.query.funcao.ListaFuncoesSensiveisCsaQuery;
import com.zetra.econsig.persistence.query.funcao.ListaPapeisQuery;
import com.zetra.econsig.persistence.query.funcao.ListaPerfilTodasEntidadesPossuemFuncaoQuery;
import com.zetra.econsig.persistence.query.funcao.ListarFuncaoQuery;
import com.zetra.econsig.persistence.query.funcao.ObtemFuncaoQuery;
import com.zetra.econsig.persistence.query.perfil.ListaOcorrenciaPerfilQuery;
import com.zetra.econsig.persistence.query.perfil.ListaPerfilSemBloqueioRepasseQuery;
import com.zetra.econsig.persistence.query.perfil.ListaPerfilTipoEntidadeQuery;
import com.zetra.econsig.persistence.query.senha.ListaOcorrenciaUsuSerSenhaAutorizacaoViaTotemQuery;
import com.zetra.econsig.persistence.query.senha.ListaSenhaAutorizacaoServidorExpiradaQuery;
import com.zetra.econsig.persistence.query.senha.ListaSenhaAutorizacaoServidorQuery;
import com.zetra.econsig.persistence.query.senha.ListaSenhasAntigasUsuarioQuery;
import com.zetra.econsig.persistence.query.senha.ListaUsuarioSerSenhaAutExpiradaQuery;
import com.zetra.econsig.persistence.query.senha.ObtemProtocoloSenhaAutorizacaoQuery;
import com.zetra.econsig.persistence.query.senha.ObtemSenhaServidorQuery;
import com.zetra.econsig.persistence.query.servidor.ListaServidoresQuery;
import com.zetra.econsig.persistence.query.servidor.ObtemTotalServidoresPorEmailCelularQuery;
import com.zetra.econsig.persistence.query.usuario.FindEmailUsuarioRepeatQuery;
import com.zetra.econsig.persistence.query.usuario.ListaFuncoesUsuarioQuery;
import com.zetra.econsig.persistence.query.usuario.ListaOcorrenciaUsuarioQuery;
import com.zetra.econsig.persistence.query.usuario.ListaStatusLoginQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuarioAtivoComEmailQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuarioAuditorEntidadeQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuarioCriadoPorResponsavelQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuarioFimVigenciaQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuarioInativoQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuarioNotificacaoInatividadeQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuarioServidorNovaSenhaQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosAuditoresQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosComNovaSenhaQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosEntidadeQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosFuncaoEspecificaQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosSerQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosSerRseQuery;
import com.zetra.econsig.persistence.query.usuario.ListaUsuariosServidorLoginQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemNomeUsuarioQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemPapelUsuarioQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemTotalUsuariosPorEmailQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemUsuarioCsaCorQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemUsuarioCseOrgQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemUsuarioCseQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemUsuarioQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemUsuarioServidorQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemUsuarioSupQuery;
import com.zetra.econsig.persistence.query.usuario.ObtemUsuarioTipoQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioCorPodeModificarPerfilQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioCorPodeModificarUsuQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioCsaPodeModificarPerfilQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioCsaPodeModificarUsuQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioCsePodeModificarUsuQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioEstPodeModificarUsuQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioOrgPodeModificarPerfilQuery;
import com.zetra.econsig.persistence.query.usuario.UsuarioOrgPodeModificarUsuQuery;
import com.zetra.econsig.persistence.query.usuario.VerificaBloqueioSegurancaPorCpfQuery;
import com.zetra.econsig.service.arquivo.HistoricoArquivoController;
import com.zetra.econsig.service.consignante.ConsignanteController;
import com.zetra.econsig.service.consignataria.ConsignatariaController;
import com.zetra.econsig.service.correspondente.CorrespondenteController;
import com.zetra.econsig.service.parametro.ParametroController;
import com.zetra.econsig.service.servico.ServicoController;
import com.zetra.econsig.service.servidor.PesquisarServidorController;
import com.zetra.econsig.service.servidor.ServidorController;
import com.zetra.econsig.values.CanalEnum;
import com.zetra.econsig.values.CodedValues;
import com.zetra.econsig.values.Columns;
import com.zetra.econsig.values.OperacaoValidacaoTotpEnum;
import com.zetra.econsig.values.ParamEmailExternoServidorEnum;
import com.zetra.econsig.values.PermiteValidacaoTotpEnum;
import com.zetra.econsig.values.TipoArquivoEnum;
import com.zetra.econsig.webclient.sso.SSOClient;

/**
 * <p>Title: UsuarioControllerBean</p>
 * <p>Description: Session Façade para manipulação de usuário</p>
 * <p>Copyright: Copyright (c) 2003</p>
 * <p>Company: ZetraSoft Ltda.</p>
 * $
 * $
 * $
 */
@Service
@Transactional
public class UsuarioControllerBean implements UsuarioController {
    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(UsuarioControllerBean.class);

    // TODO Criar uma constante única para todo o código
    private static final String MENSAGEM_ERRO_INTERNO_SISTEMA = "mensagem.erroInternoSistema";

    @Autowired
    private ConsignanteController consignanteController;

    @Autowired
    private ConsignatariaController consignatariaController;

    @Autowired
    private HistoricoArquivoController historicoArquivoController;

    @Autowired
    private ServidorController servidorController;

    @Autowired
    private ServicoController servicoController;

    @Autowired
    private ParametroController parametroController;

    @Autowired
    private PesquisarServidorController pesquisarServidorController;
    
    @Autowired
    private CorrespondenteController correspondenteController;

    @Lazy(true)
    @Autowired
    private SSOClient ssoClient;

    // Usuario
    @Override
    public UsuarioTransferObject findUsuario(UsuarioTransferObject usuario, String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        return setUsuarioValues(findUsuarioBean(usuario, tipo));
    }

    @Override
    public UsuarioTransferObject findUsuario(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        final UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        return findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);
    }

    @Override
    public UsuarioTransferObject findUsuarioSer(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        final UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        return findUsuario(usuario, AcessoSistema.ENTIDADE_SER, responsavel);
    }

    @Override
    public UsuarioTransferObject findUsuarioByLogin(String login, AcessoSistema responsavel) throws UsuarioControllerException {
        final UsuarioTransferObject usuario = new UsuarioTransferObject();
        usuario.setUsuLogin(login);
        return findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);
    }

    @Override
    public String findUsuarioPerfil(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        // Remove o perfil do usuário
        try {
            final PerfilUsuario upeBean = PerfilUsuarioHome.findByPrimaryKey(usuCodigo);
            return upeBean.getPerfil().getPerCodigo();
        } catch (final FindException e) {
            return null;
        }
    }

    @Override
    public CustomTransferObject findTipoUsuarioByLogin(String usuLogin, AcessoSistema responsavel) throws UsuarioControllerException {
        CustomTransferObject usuario = null;
        try {
            final ObtemUsuarioQuery query = new ObtemUsuarioQuery();
            query.usuLogin = usuLogin;
            final List<TransferObject> list = query.executarDTO();
            if (list.size() > 0) {
                usuario = (CustomTransferObject) list.get(0);
            }
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
        return usuario;
    }

    @Override
    public CustomTransferObject findTipoUsuarioByCodigo(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        CustomTransferObject usuario = null;
        try {
            final ObtemUsuarioQuery query = new ObtemUsuarioQuery();
            query.usuCodigo = usuCodigo;
            final List<TransferObject> list = query.executarDTO();
            if (list.size() > 0) {
                usuario = (CustomTransferObject) list.get(0);
            }
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
        return usuario;
    }

    @Override
    public List<TransferObject> findUsuarioCseList(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemUsuarioCseQuery query = new ObtemUsuarioCseQuery();
            return query.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public Usuario findUsuarioByEmailAndToken(String email, String token, AcessoSistema responsavel) throws UsuarioControllerException {
        List<Usuario> usuarioBean = null;

        try {
            usuarioBean = UsuarioHome.findByEmailAndToken(email, token);

        } catch (final FindException e) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", (AcessoSistema) null);
        }

        if (usuarioBean == null) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", (AcessoSistema) null);
        }

        if (usuarioBean.size() > 1) {
            throw new UsuarioControllerException("mensagem.erro.usuario.multiplo", (AcessoSistema) null);
        }

        return usuarioBean.get(0);
    }

    @Override
    public List<TransferObject> findUsuarioByEmail(String email, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemUsuarioQuery query = new ObtemUsuarioQuery();
            query.usuEmail = email;
            return query.executarDTO();

        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public List<UsuarioTransferObject> lstUsuariosSerByEmail(String email, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final List<UsuarioTransferObject> retorno = new ArrayList<>();

            final List<Usuario> usuarios = UsuarioHome.findByEmail(email);
            if ((usuarios != null) && !usuarios.isEmpty()) {
                for (final Usuario usuario : usuarios) {
                    try {
                        // Verifica se é usuário servidor
                        findUsuarioSer(usuario.getUsuCodigo(), responsavel);

                        if (!TextHelper.isNull(usuario.getUsuCpf())) {
                            retorno.add(setUsuarioValues(usuario));
                        }
                    } catch (final UsuarioControllerException e) {
                        // Se não é usuário servidor, não inclui na lista que será retornada
                    }
                }
            }

            return retorno;
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    private Usuario findUsuarioBean(UsuarioTransferObject usuario, String tipo) throws UsuarioControllerException {
        tipo = tipo.toUpperCase();

        if (!AcessoSistema.ENTIDADE_USU.equals(tipo) && (usuario.getUsuCodigo() == null)) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", (AcessoSistema) null);
        }

        Usuario usuarioBean = null;
        try {
            if (AcessoSistema.ENTIDADE_USU.equals(tipo)) {
                if (usuario.getUsuCodigo() != null) {
                    usuarioBean = UsuarioHome.findByPrimaryKey(usuario.getUsuCodigo());
                } else if (usuario.getUsuLogin() != null) {
                    usuarioBean = UsuarioHome.findByLogin(usuario.getUsuLogin());
                }
            } else if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                usuarioBean = UsuarioHome.findUsuCse(usuario.getUsuCodigo());
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                usuarioBean = UsuarioHome.findUsuCsa(usuario.getUsuCodigo());
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                usuarioBean = UsuarioHome.findUsuCor(usuario.getUsuCodigo());
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                usuarioBean = UsuarioHome.findUsuOrg(usuario.getUsuCodigo());
            } else if (AcessoSistema.ENTIDADE_SER.equals(tipo)) {
                usuarioBean = UsuarioHome.findUsuSer(usuario.getUsuCodigo());
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                usuarioBean = UsuarioHome.findUsuSup(usuario.getUsuCodigo());
            }
        } catch (final FindException e) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", (AcessoSistema) null, e);
        }
        if (usuarioBean == null) {
            // Se não deu FindException, significa que o método foi chamado com ENTIDADE_USU
            // e não foi passado usuCodigo nem usuLogin. Chama o dumpStack para identificarmos
            // o ponto que está chamando o método com parâmetros inválidos.
            Thread.dumpStack();
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", (AcessoSistema) null);
        }

        return usuarioBean;
    }

    private Collection<?> findFuncaoPerfilBean(String usuCodigo, String tipo) throws UsuarioControllerException {
        tipo = tipo.toUpperCase();

        try {
            Collection<?> funcoes = null;

            if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                funcoes = FuncaoPerfilCseHome.findByUsuCodigo(usuCodigo);
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                funcoes = FuncaoPerfilCsaHome.findByUsuCodigo(usuCodigo);
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                funcoes = FuncaoPerfilCorHome.findByUsuCodigo(usuCodigo);
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                funcoes = FuncaoPerfilOrgHome.findByUsuCodigo(usuCodigo);
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                funcoes = FuncaoPerfilSupHome.findByUsuCodigo(usuCodigo);
            }
            return funcoes;
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.perfil.usuario.nao.encontrado", (AcessoSistema) null);
        }
    }

    /**
     * Recupera arquivos de um usuário na base
     * @param usuCodigo - código do usuário
     * @param tarCodigo - tipo de arquivo de usuário que se deseja buscar (opcional)
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public Collection<ArquivoUsuario> findArquivoUsuario(String usuCodigo, String tarCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            return ArquivoUsuarioHome.findByUsuCodigoTipoArquivo(usuCodigo, tarCodigo);
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.arquivo.nao.encontrado", (AcessoSistema) null);
        }
    }

    private UsuarioTransferObject setUsuarioValues(Usuario usuarioBean) {
        final UsuarioTransferObject usuario = new UsuarioTransferObject(usuarioBean.getUsuCodigo());
        if (usuarioBean.getUsuDataCad() != null) {
            usuario.setUsuDataCad(DateHelper.toSQLDate(usuarioBean.getUsuDataCad()));
        }
        usuario.setStuCodigo(usuarioBean.getStatusLogin().getStuCodigo());
        usuario.setUsuLogin(usuarioBean.getUsuLogin());
        usuario.setUsuSenha(usuarioBean.getUsuSenha());
        usuario.setUsuSenha2(usuarioBean.getUsuSenha2());
        usuario.setUsuSenhaApp(usuarioBean.getUsuSenhaApp());
        usuario.setUsuNome(usuarioBean.getUsuNome());
        usuario.setUsuEmail(usuarioBean.getUsuEmail());
        usuario.setUsuTel(usuarioBean.getUsuTel());
        usuario.setUsuDicaSenha(usuarioBean.getUsuDicaSenha());
        usuario.setUsuTipoBloq(usuarioBean.getUsuTipoBloq());
        if (usuarioBean.getUsuDataExpSenha() != null) {
            usuario.setUsuDataExpSenha(DateHelper.toSQLDate(usuarioBean.getUsuDataExpSenha()));
        }
        if (usuarioBean.getUsuDataExpSenha2() != null) {
            usuario.setUsuDataExpSenha2(DateHelper.toSQLDate(usuarioBean.getUsuDataExpSenha2()));
        }
        if (usuarioBean.getUsuDataUltAcesso() != null) {
            usuario.setUsuDataUltAcesso(DateHelper.toSQLDate(usuarioBean.getUsuDataUltAcesso()));
        }
        usuario.setUsuIpAcesso(usuarioBean.getUsuIpAcesso());
        usuario.setUsuDDNSAcesso(usuarioBean.getUsuDdnsAcesso());
        usuario.setUsuCPF(usuarioBean.getUsuCpf());
        usuario.setUsuCentralizador(usuarioBean.getUsuCentralizador() != null ? usuarioBean.getUsuCentralizador().toString() : null);
        usuario.setUsuVisivel(usuarioBean.getUsuVisivel() != null ? usuarioBean.getUsuVisivel().toString() : null);
        usuario.setUsuExigeCertificado(usuarioBean.getUsuExigeCertificado() != null ? usuarioBean.getUsuExigeCertificado().toString() : null);
        usuario.setUsuMatriculaInst(usuarioBean.getUsuMatriculaInst() != null ? usuarioBean.getUsuMatriculaInst().toString() : null);
        usuario.setUsuChaveRecuperarSenha(usuarioBean.getUsuChaveRecuperarSenha() != null ? usuarioBean.getUsuChaveRecuperarSenha().toString() : null);
        usuario.setUsuNovaSenha(usuarioBean.getUsuNovaSenha() != null ? usuarioBean.getUsuNovaSenha().toString() : null);
        usuario.setUsuDataFimVig(usuarioBean.getUsuDataFimVig() != null ? new Date(usuarioBean.getUsuDataFimVig().getTime()) : null);
        usuario.setUsuDeficienteVisual(usuarioBean.getUsuDeficienteVisual() != null ? usuarioBean.getUsuDeficienteVisual().toString() : null);
        usuario.setUsuDataRecSenha(usuarioBean.getUsuDataRecSenha() != null ? new Date(usuarioBean.getUsuDataRecSenha().getTime()) : null);
        usuario.setUsuChaveValidacaoTotp(usuarioBean.getUsuChaveValidacaoTotp());
        usuario.setUsuPermiteValidacaoTotp(usuarioBean.getUsuPermiteValidacaoTotp());
        usuario.setUsuOperacoesValidacaoTotp(usuarioBean.getUsuOperacoesValidacaoTotp());
        usuario.setUsuOperacoesSenha2(usuarioBean.getUsuOperacoesSenha2());
        usuario.setUsuOtpCodigo(usuarioBean.getUsuOtpCodigo());
        usuario.setUsuOtpChaveSeguranca(usuarioBean.getUsuOtpChaveSeguranca());
        usuario.setUsuOtpDataCadastro(usuarioBean.getUsuOtpDataCadastro());
        usuario.setUsuQtdConsultasMargem(usuarioBean.getUsuQtdConsultasMargem());
        usuario.setUsuAutentiaSso(usuarioBean.getUsuAutenticaSso());
        usuario.setUsuAutorizaEmailMarketing(usuarioBean.getUsuAutorizaEmailMarketing());
        return usuario;
    }

    @Override
    public String createUsuario(UsuarioTransferObject usuario, List<String> funcoes, String codigoEntidade, String tipo, String senhaAberta, AcessoSistema responsavel) throws UsuarioControllerException {
        return createUsuario(usuario, funcoes, null, codigoEntidade, tipo, null, true, senhaAberta, true, responsavel);
    }

    @Override
    public String createUsuario(UsuarioTransferObject usuario, List<String> funcoes, String codigoEntidade, String tipo, TransferObject tipoMotivoOperacao, boolean validaCpfEmail, String senhaAberta, AcessoSistema responsavel) throws UsuarioControllerException {
        return createUsuario(usuario, funcoes, null, codigoEntidade, tipo, tipoMotivoOperacao, validaCpfEmail, senhaAberta, true, responsavel);
    }

    @Override
    public String createUsuario(UsuarioTransferObject usuario, List<String> funcoes, String codigoEntidade, String tipo, TransferObject tipoMotivoOperacao, boolean validaCpfEmail, String senhaAberta, boolean validaForcaSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        return createUsuario(usuario, funcoes, null, codigoEntidade, tipo, tipoMotivoOperacao, validaCpfEmail, senhaAberta, validaForcaSenha, responsavel);
    }

    @Override
    public String createUsuario(UsuarioTransferObject usuario, String perCodigo, String codigoEntidade, String tipo, String senhaAberta, AcessoSistema responsavel) throws UsuarioControllerException {
        return createUsuario(usuario, null, perCodigo, codigoEntidade, tipo, null, true, senhaAberta, true, responsavel);
    }

    @Override
    public String createUsuario(UsuarioTransferObject usuario, String perCodigo, String codigoEntidade, String tipo, TransferObject tipoMotivoOperacao, boolean validaCpfEmail, String senhaAberta, boolean validaForcaSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        return createUsuario(usuario, null, perCodigo, codigoEntidade, tipo, tipoMotivoOperacao, validaCpfEmail, senhaAberta, validaForcaSenha, responsavel);
    }

    private String createUsuario(UsuarioTransferObject usuario, List<String> funcoes, String perCodigo, String codigoEntidade, String tipo, TransferObject tipoMotivoOperacao, boolean validaCpfEmail, String senhaAberta, boolean validaForcaSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        String usuCodigo = null;
        try {
            // Verifica se não existe outro usuário com o mesmo login
            final UsuarioTransferObject teste = new UsuarioTransferObject();
            teste.setUsuLogin((String) usuario.getAttribute(Columns.USU_LOGIN));

            boolean existe = false;
            try {
                findUsuarioBean(teste, AcessoSistema.ENTIDADE_USU);
                existe = true;
            } catch (final UsuarioControllerException ex) {
                // OK, nenhum usuário encontrato com o login informado
            }

            if (existe) {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.criar.este.usuario.existe.outro.mesmo.login.cadastrado.sistema", responsavel);
            }

            boolean autenticaSSO = false;

            if (responsavel.isCsa() && responsavel.getCanal() == CanalEnum.WEB) {

                boolean campoAutenticaSsoTrue = (!TextHelper.isNull(usuario.getUsuAutenticaSso()) && usuario.getUsuAutenticaSso().equals("S"));
                // Verifica se como CSA o campo autentica via SSO é verdadeiro
                autenticaSSO = campoAutenticaSsoTrue;

            } else {
                // se o parâmetro de sistema do papel autentica no SSO
                autenticaSSO = validarDadosSSO(usuario, codigoEntidade, tipo, responsavel);
            }

            
            
            boolean enviaEmailInicializacaoSenha = false;

            // Na criação do usuário MASTER realizado durante a criação da CSA, não valido CPF ou email
            if (validaCpfEmail) {

                validaCpfUsuario(usuario.getUsuCPF(), tipo, responsavel);
                validaUnicidadeCpf(usuario.getUsuCodigo(), usuario.getUsuCPF(), tipo, codigoEntidade, responsavel);

                enviaEmailInicializacaoSenha = verificarSeEnviaEmailInicializacaoSenha(autenticaSSO, tipo, usuario, responsavel);

            }

            if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                final boolean usuTelObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_TELEFONE_OBRIGATORIO_USUARIO_SUP, CodedValues.TPC_SIM, responsavel);
                if (usuTelObrigatorio && TextHelper.isNull(usuario.getUsuTel())) {
                    throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.telefone.usuario.deve.ser.informado", responsavel);
                }
            }
            if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                final boolean usuTelObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_TELEFONE_OBRIGATORIO_USUARIO_CSE, CodedValues.TPC_SIM, responsavel);
                if (usuTelObrigatorio && TextHelper.isNull(usuario.getUsuTel())) {
                    throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.telefone.usuario.deve.ser.informado", responsavel);
                }
            }
            
            // Cria a entidade na tb_usuario
            final String usuExigeCertificado = !TextHelper.isNull(usuario.getUsuExigeCertificado()) ? usuario.getUsuExigeCertificado().substring(0, 1) : null;
            final String usuCentralizador = !TextHelper.isNull(usuario.getUsuCentralizador()) ? usuario.getUsuCentralizador().substring(0, 1) : null;
            final String usuVisivel = !TextHelper.isNull(usuario.getUsuVisivel()) ? usuario.getUsuVisivel().substring(0, 1) : null;

            if (validaForcaSenha) {
                SenhaHelper.validarForcaSenha(senhaAberta, AcessoSistema.ENTIDADE_SER.equals(tipo), responsavel);
            }

            final Usuario usuarioBean = UsuarioHome.create(usuario.getStuCodigo(), usuario.getUsuLogin(), usuario.getUsuSenha(), usuario.getUsuSenha2(), usuario.getUsuNome(), usuario.getUsuEmail(), usuario.getUsuTel(), usuario.getUsuDicaSenha(), usuario.getUsuTipoBloq(), usuario.getUsuDataExpSenha(), usuario.getUsuDataExpSenha2(), usuario.getUsuIpAcesso(), usuario.getUsuDDNSAcesso(), usuario.getUsuCPF(), usuCentralizador, usuVisivel, usuExigeCertificado, usuario.getUsuMatriculaInst(), usuario.getUsuChaveRecuperarSenha(), usuario.getUsuDataFimVig(), usuario.getUsuDeficienteVisual(),
                                                           usuario.getUsuChaveValidacaoTotp(), usuario.getUsuPermiteValidacaoTotp(), usuario.getUsuQtdConsultasMargem(), usuario.getUsuAutenticaSso());
            usuCodigo = usuarioBean.getUsuCodigo();

            // Cria a entidade na tb_usuario_xxx
            createUsuarioEntidade(usuCodigo, codigoEntidade, tipo);

            // Verifica se o responsável tem permissão para criar este usuário
            usuarioPodeModificarUsu(usuCodigo, false, true, responsavel);

            // Cria o perfil do usuário
            updateUsuarioPerfil(funcoes, perCodigo, usuCodigo, codigoEntidade, tipo, false, responsavel);

            // Recupera as funções que pertencem ao papel do novo usuário e
            // que estão bloqueadas para o usuário responsável, que serão bloqueadas também para o novo usuário
            final List<String> codSvcEntidade = retornaCodigoServicoEntidade(codigoEntidade, tipo, responsavel);
            final List<TransferObject> lista = selectFuncoesBloqueadas(responsavel.getUsuCodigo(), tipo, responsavel);
            if (!lista.isEmpty()) {
                final List<TransferObject> funcoesBloqueadas = new ArrayList<>();
                for (final TransferObject to : lista) {
                    // Se não retornou uma lista de serviços nula,
                    // é porque a entidade possui convênio com todos os serviços.
                    // Se retornou serviços, devem ser validados os serviços que pertencem ao convênio da entidade.
                    if ((codSvcEntidade == null) || ((codSvcEntidade != null) && !codSvcEntidade.isEmpty() && codSvcEntidade.contains(to.getAttribute(Columns.BUF_SVC_CODIGO).toString()))) {
                        to.setAttribute(Columns.BUF_USU_CODIGO, usuCodigo);
                        funcoesBloqueadas.add(to);
                    }
                }
                // Insere bloqueio de funções para o novo usuário
                insereBloqueiosFuncoes(usuCodigo, funcoesBloqueadas, responsavel);
            }

            // Cria ocorrência de inclusão de usuário
            final CustomTransferObject ocorrencia = new CustomTransferObject();
            ocorrencia.setAttribute(Columns.OUS_USU_CODIGO, usuCodigo);
            ocorrencia.setAttribute(Columns.OUS_TOC_CODIGO, CodedValues.TOC_INCLUSAO_USUARIO);
            ocorrencia.setAttribute(Columns.OUS_OUS_USU_CODIGO, responsavel.getUsuCodigo());
            ocorrencia.setAttribute(Columns.OUS_OBS, ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.inclusao.usuario", responsavel));
            ocorrencia.setAttribute(Columns.OUS_IP_ACESSO, responsavel.getIpUsuario());
            if (tipoMotivoOperacao != null) {
                ocorrencia.setAttribute(Columns.OUS_OBS, ocorrencia.getAttribute(Columns.OUS_OBS) + (ocorrencia.getAttribute(Columns.OUS_OBS).toString().lastIndexOf(".") == (ocorrencia.getAttribute(Columns.OUS_OBS).toString().length() - 1) ? " " : ". ") + tipoMotivoOperacao.getAttribute(Columns.OUS_OBS));
                ocorrencia.setAttribute(Columns.OUS_TMO_CODIGO, tipoMotivoOperacao.getAttribute(Columns.TMO_CODIGO));
            }

            createOcorrenciaUsuario(ocorrencia, responsavel);

            if (enviaEmailInicializacaoSenha) {
                final String linkReinicializacao = usuario.getLinkRecuperarSenha();

                if (TextHelper.isNull(linkReinicializacao)) {
                    throw new UsuarioControllerException("mensagem.erro.usuario.link.senha.ausente", responsavel);
                }

                // Gera uma nova codigo de recuparação de senha
                final String cod_Senha = SynchronizerToken.generateToken();
                // Atualiza o codigo de recuperação de senha do usuário
                alteraChaveRecupSenha(usuCodigo, cod_Senha, responsavel);
                // Envia e-mail com link para recuperação de senha
                enviaLinkIniciacaoSenhaNovoUsuario(usuCodigo, usuario.getUsuEmail(), (String) usuario.getAttribute(Columns.USU_LOGIN), usuario.getUsuNome(), linkReinicializacao, cod_Senha, responsavel);
                // Limpa o atributo para não ser gravado no log
                usuario.setLinkRecuperarSenha(null);
            }

            if (autenticaSSO) {
                // Irá verificar se o sso está habilitado e cria o usuário no sso
                ssoClient.addUsuarioSSO(usuario, senhaAberta, tipo, codigoEntidade, responsavel);
            }

            final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.CREATE, Log.LOG_INFORMACAO);
            log.setUsuario(usuCodigo);
            log.setStatusLogin(usuario.getStuCodigo());
            log.getUpdatedFields(usuario.getAtributos(), null);

            if (!TextHelper.isNull(tipo)) {
                final List<String> codigosEntidade = new ArrayList<>();
                codigosEntidade.add(codigoEntidade);

                log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.usuario.tipo.arg0", responsavel, tipo + " "));
                if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                    log.add(Columns.CSE_NOME, codigosEntidade, ConsignanteHome.class);
                } else if (AcessoSistema.ENTIDADE_EST.equals(tipo)) {
                    log.add(Columns.EST_NOME, codigosEntidade, EstabelecimentoHome.class);
                } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                    log.add(Columns.ORG_NOME, codigosEntidade, OrgaoHome.class);
                } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                    log.add(Columns.CSA_NOME, codigosEntidade, ConsignatariaHome.class);
                } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                    log.add(Columns.COR_NOME, codigosEntidade, CorrespondenteHome.class);
                } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                    log.add(Columns.CSE_NOME, codigosEntidade, ConsignanteHome.class);
                }
            }

            if ((perCodigo != null) && !"".equals(perCodigo)) {
                log.setPerfil(perCodigo);
            } else {
                log.add(Columns.FUN_CODIGO, funcoes, FuncaoHome.class);
            }
            log.write();
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.criar.usuario.erro.interno.arg0", responsavel, ex.getMessage());
        } catch (final ZetraException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(e);
        }
        return usuCodigo;
    }

    private boolean verificarSeEnviaEmailInicializacaoSenha(boolean autenticaSSO, 
            String tipo,
            UsuarioTransferObject usuario,
            AcessoSistema responsavel) throws UsuarioControllerException {
        
        //DESENV-10463: Verifica se sistema envia e-mail de inicialização de senha na criação do usuário do tipo em questão
        boolean enviaEmailInicializacaoSenha = ((AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo)) && ParamSist.paramEquals(CodedValues.TPC_ENVIA_EMAIL_CRIACAO_SENHA_NOVO_USU_CSE_ORG, CodedValues.TPC_SIM, responsavel)) || ((AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) && ParamSist.paramEquals(CodedValues.TPC_ENVIA_EMAIL_CRIACAO_SENHA_NOVO_USU_CSA_COR, CodedValues.TPC_SIM, responsavel)) ||
                                        (AcessoSistema.ENTIDADE_SUP.equals(tipo) && ParamSist.paramEquals(CodedValues.TPC_ENVIA_EMAIL_CRIACAO_SENHA_NOVO_USU_SUP, CodedValues.TPC_SIM, responsavel));

        if (AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) {
            final boolean usuEmailObrigatorio = enviaEmailInicializacaoSenha || ParamSist.getBoolParamSist(CodedValues.TPC_CADASTRO_EMAIL_OBRIGATORIO_USUARIO_CSA, responsavel);
            if (usuEmailObrigatorio && TextHelper.isNull(usuario.getUsuEmail())) {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.email.usuario.deve.ser.informado", responsavel);
            }
        } else if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
            final boolean usuEmailObrigatorio = enviaEmailInicializacaoSenha || ParamSist.getBoolParamSist(CodedValues.TPC_CADASTRO_EMAIL_OBRIGATORIO_CSE_ORG_SUP, responsavel);
            if (usuEmailObrigatorio && TextHelper.isNull(usuario.getUsuEmail())) {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.email.usuario.deve.ser.informado", responsavel);
            }
        }
        
        boolean ehCriacaoUsuarioViaAccessGateway = autenticaSSO && responsavel.getCanal() == CanalEnum.SOAP;

        if (ehCriacaoUsuarioViaAccessGateway) {
            enviaEmailInicializacaoSenha = false;
        }

        return enviaEmailInicializacaoSenha;

    }

    private boolean validarDadosSSO(UsuarioTransferObject usuario, String codigoEntidade, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException, ParametroControllerException {

        boolean realizaCadastroSSO = UsuarioHelper.usuarioAutenticaSso(usuario, tipoEntidade, responsavel);

        if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade)) {
            // Caso seja consignatária, valida se o parâmetro de criação de usuário autenticado no SSO foi habilitado para a CSA
            realizaCadastroSSO = false;
            final String criaUsuarioAutenticaoSSO = parametroController.getParamCsa(codigoEntidade, CodedValues.TPA_USUARIO_AUTENTICA_SSO, responsavel);

            if (!TextHelper.isNull(criaUsuarioAutenticaoSSO) && "S".equalsIgnoreCase(criaUsuarioAutenticaoSSO)) {
                realizaCadastroSSO = true;
            }
        } else if (AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
            // Se for correspondente, o padrão é criar não autenticando no SSO
            realizaCadastroSSO = false;
        }

        if (realizaCadastroSSO) {
            // Validar se email cadastrado
            if (TextHelper.isNull(usuario.getUsuEmail())) {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.email.usuario.deve.ser.informado", responsavel);
            }

            // Seta para autenticar no SSO
            usuario.setUsuAutentiaSso(CodedValues.TPC_SIM);
        }

        return realizaCadastroSSO;
    }

    /**
     * Retorna os códigos dos serviços disponíveis para a entidade informada.
     * Se retornou uma lista nula é porque a entidade é cse e possui convênio com todos os serviços.
     *
     * @param codigoEntidade Código da entidade informada.
     * @param tipo Tipo da entidade informada.
     * @param responsavel
     * @return Retorna uma lista com os códigos dos serviços disponíveis para a entidade informada. Se a lista nula é porque a entidade é cse e possui convênio com todos os serviços.
     * @throws UsuarioControllerException
     */
    private List<String> retornaCodigoServicoEntidade(String codigoEntidade, String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        tipo = tipo.toUpperCase();
        List<String> retorno = null;
        try {
            List<TransferObject> servicos = null;
            if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                servicos = servicoController.selectServicosCsa(codigoEntidade, responsavel);
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                servicos = servicoController.selectServicosCorrespondente(codigoEntidade, responsavel);
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                servicos = servicoController.selectServicosOrgao(codigoEntidade, responsavel);
            }

            if ((servicos != null) && !servicos.isEmpty()) {
                retorno = new ArrayList<>();
                for (final TransferObject servico : servicos) {
                    retorno.add(servico.getAttribute(Columns.SVC_CODIGO).toString());
                }
            }

        } catch (final ServicoControllerException ex) {
            throw new UsuarioControllerException(ex);
        }
        return retorno;
    }

    private void createUsuarioEntidade(String usuCodigo, String codigoEntidade, String tipo) throws UsuarioControllerException {
        tipo = tipo.toUpperCase();
        try {
            final String stuCodigo = CodedValues.STU_ATIVO;

            if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                UsuarioCseHome.create(codigoEntidade, usuCodigo, stuCodigo);
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                UsuarioCsaHome.create(codigoEntidade, usuCodigo, stuCodigo);
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                UsuarioCorHome.create(codigoEntidade, usuCodigo, stuCodigo);
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                UsuarioOrgHome.create(codigoEntidade, usuCodigo, stuCodigo);
            } else if (AcessoSistema.ENTIDADE_SER.equals(tipo)) {
                UsuarioSerHome.create(codigoEntidade, usuCodigo, stuCodigo);
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                UsuarioSupHome.create(codigoEntidade, usuCodigo, stuCodigo);
            }
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.criar.usuario.erro.interno.arg0", (AcessoSistema) null, ex.getMessage());
        }
    }

    private void createUsuarioPerfil(List<String> funcoes, String usuCodigo, String codigoEntidade, String tipo) throws UsuarioControllerException {
        tipo = tipo.toUpperCase();
        if (funcoes == null) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.criar.usuario.erro.interno.arg0", (AcessoSistema) null, ApplicationResourcesHelper.getMessage("mensagem.informacao.lista.funcoes.perfil.usuario.nao.pode.ser.nula", (AcessoSistema) null));
        }

        try {
            final Iterator<String> it = funcoes.iterator();

            if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                while (it.hasNext()) {
                    final String funCodigo = it.next().toString();
                    FuncaoPerfilCseHome.create(codigoEntidade, usuCodigo, funCodigo);
                }
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                while (it.hasNext()) {
                    final String funCodigo = it.next().toString();
                    FuncaoPerfilCsaHome.create(codigoEntidade, usuCodigo, funCodigo);
                }
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                while (it.hasNext()) {
                    final String funCodigo = it.next().toString();
                    FuncaoPerfilCorHome.create(codigoEntidade, usuCodigo, funCodigo);
                }
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                while (it.hasNext()) {
                    final String funCodigo = it.next().toString();
                    FuncaoPerfilOrgHome.create(codigoEntidade, usuCodigo, funCodigo);
                }
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                while (it.hasNext()) {
                    final String funCodigo = it.next().toString();
                    FuncaoPerfilSupHome.create(codigoEntidade, usuCodigo, funCodigo);
                }
            }
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.criar.usuario.erro.interno.arg0", (AcessoSistema) null, ex.getMessage());
        }
    }

    private void updateUsuario(UsuarioTransferObject usuario, OcorrenciaUsuarioTransferObject ocorrenciaUsu, AcessoSistema responsavel) throws UsuarioControllerException {
        alteraUsuario(usuario, ocorrenciaUsu, null, null, null, null, false, false, false, null, responsavel);
    }

    @Override
    public void updateUsuario(UsuarioTransferObject usuario, OcorrenciaUsuarioTransferObject ocorrenciaUsu, List<String> funcoes, String perCodigo, String tipo, String codigoEntidade, TransferObject tipoMotivoOperacao, AcessoSistema responsavel) throws UsuarioControllerException {
        alteraUsuario(usuario, ocorrenciaUsu, funcoes, perCodigo, tipo, codigoEntidade, true, true, true, tipoMotivoOperacao, responsavel);
    }

    private void updateUsuario(UsuarioTransferObject usuario, OcorrenciaUsuarioTransferObject ocorrenciaUsu, List<String> funcoes, String perCodigo, String tipo, String codigoEntidade, TransferObject tipoMotivoOperacao, AcessoSistema responsavel, Boolean validarCpf) throws UsuarioControllerException {
        alteraUsuario(usuario, ocorrenciaUsu, funcoes, perCodigo, tipo, codigoEntidade, validarCpf, true, true, tipoMotivoOperacao, responsavel);
    }

    /**
     * Altera os dados do usuário.
     * Se uma ocorrência for passada por parâmetro a mesma será salva, caso contrário será incluída uma ocorrência de alteração de usuário.
     * @param usuario : Dados para alteração do usuário
     * @param ocorrenciaUsu : Ocorrencia que deverá ser incluída, caso seja nula será criada uma ocorrência de alteração de usuário.
     * @param funcoes : Funções de perfil personalizado do usuário
     * @param perCodigo : Perfil não personalizado do usuário
     * @param tipo : Tipo da entidade do usuario.
     * @param codigoEntidade : Código da entidade do usuário
     * @param validaCpf : True caso seja para validar o CPF do usuário
     * @param validaEmail : True caso seja para validar o Email do usuário de CSA/COR
     * @param validaTel : True caso seja para validar o Telefone do usuário CSA/COR
     * @param tipoMotivoOperacao : Motivo da operação
     * @param responsavel : Responsável pela operação
     * @throws UsuarioControllerException
     */
    private void alteraUsuario(UsuarioTransferObject usuario, OcorrenciaUsuarioTransferObject ocorrenciaUsu, List<String> funcoes, String perCodigo, String tipo, String codigoEntidade, boolean validaCpf, boolean validaEmail, boolean validaTel, TransferObject tipoMotivoOperacao, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            // Se é consumo de senha, ou o usuário pode modificar o usuário, realiza a operação
            if (((ocorrenciaUsu != null) && ocorrenciaUsu.isUtilizacaoSenhaAutServidor()) || usuarioPodeModificarUsu(usuario.getUsuCodigo(), true, true, responsavel)) {

                final Usuario usuarioBean = findUsuarioBean(usuario, AcessoSistema.ENTIDADE_USU);
                final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_INFORMACAO);
                final String usuCodigo = usuarioBean.getUsuCodigo();
                log.setUsuario(usuCodigo);

                /* Compara a versão do cache com a passada por parâmetro */
                final String usuLoginAntesExclusao = usuarioBean.getUsuLogin();
                final UsuarioTransferObject usuarioCache = setUsuarioValues(usuarioBean);
                final CustomTransferObject merge = log.getUpdatedFields(usuario.getAtributos(), usuarioCache.getAtributos());

                final StringBuilder msgOus = new StringBuilder();

                if (merge.getAtributos().containsKey(Columns.USU_LOGIN)) {

                    // Verifica se não existe outro usuário com o mesmo login
                    final UsuarioTransferObject teste = new UsuarioTransferObject();
                    teste.setUsuLogin((String) merge.getAttribute(Columns.USU_LOGIN));

                    boolean existe = false;
                    try {
                        findUsuarioBean(teste, AcessoSistema.ENTIDADE_USU);
                        existe = true;
                    } catch (final UsuarioControllerException ex) {
                    }
                    if (existe) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.alterar.este.usuario.existe.outro.mesmo.login.cadastrado.sistema", responsavel);
                    }
                    msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.login.alterado.de.arg0.para.arg1", responsavel, usuarioBean.getUsuLogin(), (String) merge.getAttribute(Columns.USU_LOGIN)));
                    usuarioBean.setUsuLogin((String) merge.getAttribute(Columns.USU_LOGIN));
                }

                String stu_codigo = "";
                boolean stuAtivo = CodedValues.STU_ATIVO.equals(usuarioBean.getStatusLogin().getStuCodigo());
                if (merge.getAtributos().containsKey(Columns.USU_STU_CODIGO)) {
                    final boolean isCseSup = responsavel == null ? false : responsavel.isCseSup();
                    final boolean isSup = responsavel == null ? false : responsavel.isSup();
                    final boolean isCor = responsavel == null ? false : responsavel.isCor();
                    
                    stu_codigo = merge.getAttribute(Columns.USU_STU_CODIGO) != null ? merge.getAttribute(Columns.USU_STU_CODIGO).toString() : CodedValues.STU_ATIVO;

                    // Se o usuário alterado está sendo bloqueado ...
                    if (CodedValues.STU_BLOQUEADO.equals(stu_codigo)) {

                        // Verifica se ele não esta sendo bloqueado por ele próprio
                        if ((responsavel != null) && usuarioCache.getUsuCodigo().equals(responsavel.getUsuCodigo())) {
                            throw new UsuarioControllerException("mensagem.erro.usuario.nao.pode.bloquear.ele.proprio", responsavel);
                        }

                        // Verifica se o usuário está sendo bloqueado por um usuário da consignante
                        if (isCseSup) {
                            stu_codigo = CodedValues.STU_BLOQUEADO_POR_CSE;
                            usuarioBean.setUsuTipoBloq(ApplicationResourcesHelper.getMessage(isSup ? "mensagem.usuario.bloqueado.sup" : "mensagem.usuario.bloqueado.cse", responsavel));
                        }

                        // Se o usuário alterado está sendo desbloqueado ...
                    } else if (CodedValues.STU_ATIVO.equals(stu_codigo)) {

                        if (!isCseSup && CodedValues.STU_BLOQUEADO_POR_CSE.equals(usuarioCache.getStuCodigo())) {
                            // Verifica se um usuário que não é da consignante está tentando desbloquear um usuário bloqueado pela consignante
                            throw new UsuarioControllerException("mensagem.erro.nao.possivel.desbloquear.usuario.arg0.pois.foi.bloqueado.pelo.consignante", responsavel, usuarioCache.getUsuLogin());
                        } else if (!isSup && CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE_SEGURANCA.equals(usuarioCache.getStuCodigo())) {
                            // verifica se o usuário não é sup e está tentando desbloquear um usuário bloqueado por segurança
                            throw new UsuarioControllerException("mensagem.erro.nao.possivel.desbloquear.usuario.arg0.pois.foi.bloqueado.por.seguranca", responsavel, usuarioCache.getUsuLogin());
                        } else if(isCor) {
                        	Optional<TransferObject> ultimoResponsavelBloqueio = correspondenteController.buscarUltimoRespBloqueioNaoCorrespondente(usuCodigo, responsavel);
                        	final boolean ehBloqueioPorPapelNaoCorrespondente = ultimoResponsavelBloqueio.isPresent();
                        	
                        	if(ehBloqueioPorPapelNaoCorrespondente) {
                        		final String usuBloqueado = (String) ultimoResponsavelBloqueio.get().getAttribute(Columns.USU_CODIGO);
                        		
                        		// Grava log de Erro
                                final LogDelegate logCor = new LogDelegate(responsavel, Log.CORRESPONDENTE, Log.UNLOCK, Log.LOG_ERRO_SEGURANCA);
                                logCor.setCorrespondente(usuBloqueado);
                                logCor.add(ApplicationResourcesHelper.getMessage("rotulo.erro.upper.arg0", responsavel, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.tem.permissao.desbloquear.correspondente", responsavel)));
                                logCor.write();
                                
                                throw new UsuarioControllerException("mensagem.erro.usuario.nao.tem.permissao.desbloquear.correspondente", responsavel, usuarioCache.getUsuLogin());
                        	}
                        } else {
                            usuarioBean.setUsuTipoBloq("");
                        }

                        // Se o usuário alterado está sendo cancelado ...
                    } else if (CodedValues.STU_EXCLUIDO.equals(stu_codigo)) {

                        // Altera o login do usuário para o seu código de modo que
                        // novos usuários possam usar o login deste usuário
                        usuarioBean.setUsuTipoBloq(usuarioBean.getUsuLogin());
                        usuarioBean.setUsuLogin(usuCodigo);
                    }

                    stuAtivo = CodedValues.STU_ATIVO.equals(stu_codigo);

                    // Altera o status do usuário
                    final StatusLogin statusLogin = StatusLoginHome.findByPrimaryKey(stu_codigo);
                    usuarioBean.setStatusLogin(statusLogin);
                    log.setStatusLogin(stu_codigo);
                }

                if (merge.getAtributos().containsKey(Columns.USU_NOME)) {
                    final String antes = usuarioBean.getUsuNome() != null ? usuarioBean.getUsuNome() : "";
                    final String depois = merge.getAttribute(Columns.USU_NOME) != null ? merge.getAttribute(Columns.USU_NOME).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.nome.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }
                    usuarioBean.setUsuNome((String) merge.getAttribute(Columns.USU_NOME));
                }
                if (merge.getAtributos().containsKey(Columns.USU_CPF)) {
                    final String antes = usuarioBean.getUsuCpf() != null ? usuarioBean.getUsuCpf() : "";
                    final String depois = merge.getAttribute(Columns.USU_CPF) != null ? merge.getAttribute(Columns.USU_CPF).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.cpf.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }
                    usuarioBean.setUsuCpf((String) merge.getAttribute(Columns.USU_CPF));
                }
                if (merge.getAtributos().containsKey(Columns.USU_EMAIL)) {
                    final String antes = usuarioBean.getUsuEmail() != null ? usuarioBean.getUsuEmail() : "";
                    final String depois = merge.getAttribute(Columns.USU_EMAIL) != null ? merge.getAttribute(Columns.USU_EMAIL).toString() : "";

                    final boolean bloqueiaEdicaoEmail = !responsavel.isSup() && ParamSist.getBoolParamSist(CodedValues.TPC_BLOQUEIA_EDICAO_EMAIL, responsavel);
                    if (bloqueiaEdicaoEmail && !TextHelper.isNull(antes)) {
                        // Se não pode editar e-mail e ele já estava cadastrado, então lança exceção
                        throw new UsuarioControllerException("mensagem.erro.usuario.email.nao.pode.ser.alterado", responsavel);
                    }
                    if (existeOutroUsuarioMesmoEmail(depois, usuarioBean.getUsuCpf(), responsavel)) {
                        // Se existe outro usuário no sistema com o mesmo e-mail, envia mensagem de erro
                        throw new UsuarioControllerException("mensagem.erro.usuario.email.informado.em.uso", responsavel);
                    }
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.email.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }

                    usuarioBean.setUsuEmail(depois);
                    // força nova validação do e-mail
                    usuarioBean.setUsuDataValidacaoEmail(null);
                }
                if (merge.getAtributos().containsKey(Columns.USU_TEL)) {
                    final String antes = usuarioBean.getUsuTel() != null ? usuarioBean.getUsuTel() : "";
                    final String depois = merge.getAttribute(Columns.USU_TEL) != null ? merge.getAttribute(Columns.USU_TEL).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.telefone.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }
                    usuarioBean.setUsuTel((String) merge.getAttribute(Columns.USU_TEL));
                }
                if (merge.getAtributos().containsKey(Columns.USU_SENHA)) {
                    usuarioBean.setUsuSenha((String) merge.getAttribute(Columns.USU_SENHA));
                }
                if (merge.getAtributos().containsKey(Columns.USU_SENHA_APP)) {
                    usuarioBean.setUsuSenhaApp((String) merge.getAttribute(Columns.USU_SENHA_APP));
                }
                if (merge.getAtributos().containsKey(Columns.USU_SENHA_2)) {
                    usuarioBean.setUsuSenha2((String) merge.getAttribute(Columns.USU_SENHA_2));
                }
                if (merge.getAtributos().containsKey(Columns.USU_NOVA_SENHA)) {
                    usuarioBean.setUsuNovaSenha((String) merge.getAttribute(Columns.USU_NOVA_SENHA));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DICA_SENHA)) {
                    final String antes = usuarioBean.getUsuDicaSenha() != null ? usuarioBean.getUsuDicaSenha() : "";
                    final String depois = merge.getAttribute(Columns.USU_DICA_SENHA) != null ? merge.getAttribute(Columns.USU_DICA_SENHA).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.dica.senha.alterada.dearg0.para.arg1", responsavel, antes, depois));
                    }
                    usuarioBean.setUsuDicaSenha((String) merge.getAttribute(Columns.USU_DICA_SENHA));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DATA_EXP_SENHA)) {
                    usuarioBean.setUsuDataExpSenha((java.sql.Date) merge.getAttribute(Columns.USU_DATA_EXP_SENHA));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DATA_EXP_SENHA_2)) {
                    usuarioBean.setUsuDataExpSenha2((java.sql.Date) merge.getAttribute(Columns.USU_DATA_EXP_SENHA_2));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DATA_EXP_SENHA_APP)) {
                    usuarioBean.setUsuDataExpSenhaApp((java.sql.Date) merge.getAttribute(Columns.USU_DATA_EXP_SENHA_APP));
                }
                if (merge.getAtributos().containsKey(Columns.USU_IP_ACESSO)) {
                    final String antes = usuarioBean.getUsuIpAcesso() != null ? usuarioBean.getUsuIpAcesso() : "";
                    final String depois = merge.getAttribute(Columns.USU_IP_ACESSO) != null ? merge.getAttribute(Columns.USU_IP_ACESSO).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.ip.acesso.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }
                    usuarioBean.setUsuIpAcesso((String) merge.getAttribute(Columns.USU_IP_ACESSO));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DDNS_ACESSO)) {
                    final String antes = usuarioBean.getUsuDdnsAcesso() != null ? usuarioBean.getUsuDdnsAcesso() : "";
                    final String depois = merge.getAttribute(Columns.USU_DDNS_ACESSO) != null ? merge.getAttribute(Columns.USU_DDNS_ACESSO).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.endereco.acesso.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }
                    usuarioBean.setUsuDdnsAcesso((String) merge.getAttribute(Columns.USU_DDNS_ACESSO));
                }
                if (merge.getAtributos().containsKey(Columns.USU_CENTRALIZADOR)) {
                    final String usuCentralizador = (String) merge.getAttribute(Columns.USU_CENTRALIZADOR);
                    final String centralizadorOld = usuarioBean.getUsuCentralizador() != null ? usuarioBean.getUsuCentralizador().toString() : "";
                    final String centralizadorNew = !TextHelper.isNull(usuCentralizador) ? usuCentralizador.substring(0, 1) : "";
                    if (!centralizadorOld.equals(centralizadorNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.centralizador.alterado.de.arg0.para.arg1", responsavel, centralizadorOld, centralizadorNew));
                    }
                    usuarioBean.setUsuCentralizador(!TextHelper.isNull(usuCentralizador) ? usuCentralizador.substring(0, 1) : null);
                }
                if (merge.getAtributos().containsKey(Columns.USU_AUTENTICA_SSO)) {
                    final String usuAutenticaSso = (String) merge.getAttribute(Columns.USU_AUTENTICA_SSO);
                    final String ssoOld = usuarioBean.getUsuAutenticaSso() != null ? usuarioBean.getUsuAutenticaSso().toString() : "";
                    final String ssoNew = !TextHelper.isNull(usuAutenticaSso) ? usuAutenticaSso.substring(0, 1) : "";
                    if (!ssoOld.equals(ssoNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.sso.alterado.de.arg0.para.arg1", responsavel, ssoOld, ssoNew));
                    }
                    usuarioBean.setUsuAutenticaSso(!TextHelper.isNull(usuAutenticaSso) ? usuAutenticaSso.substring(0, 1) : null);
                }
                if (merge.getAtributos().containsKey(Columns.USU_VISIVEL)) {
                    final String usuVisivel = (String) merge.getAttribute(Columns.USU_VISIVEL);
                    final String visivelOld = usuarioBean.getUsuVisivel() != null ? usuarioBean.getUsuVisivel().toString() : "";
                    final String visivelNew = !TextHelper.isNull(usuVisivel) ? usuVisivel.substring(0, 1) : "";
                    if (!visivelOld.equals(visivelNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.visibilidade.alterada.de.arg0.para.arg1", responsavel, visivelOld, visivelNew));
                    }
                    usuarioBean.setUsuVisivel(!TextHelper.isNull(usuVisivel) ? usuVisivel.substring(0, 1) : null);
                }
                if (merge.getAtributos().containsKey(Columns.USU_EXIGE_CERTIFICADO)) {
                    final String usuExigeCertificado = (String) merge.getAttribute(Columns.USU_EXIGE_CERTIFICADO);
                    final String certificadoOld = usuarioBean.getUsuExigeCertificado() != null ? usuarioBean.getUsuExigeCertificado().toString() : "";
                    final String certificadoNew = !TextHelper.isNull(usuExigeCertificado) ? usuExigeCertificado.substring(0, 1) : "";
                    if (!certificadoOld.equals(certificadoNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.exige.certificado.alterado.de.arg0.para.arg1", responsavel, certificadoOld, certificadoNew));
                    }
                    usuarioBean.setUsuExigeCertificado(!TextHelper.isNull(usuExigeCertificado) ? usuExigeCertificado.substring(0, 1) : null);
                }
                if (merge.getAtributos().containsKey(Columns.USU_TIPO_BLOQ)) {
                    usuarioBean.setUsuTipoBloq((String) merge.getAttribute(Columns.USU_TIPO_BLOQ));
                }
                if (merge.getAtributos().containsKey(Columns.USU_MATRICULA_INST)) {
                    usuarioBean.setUsuMatriculaInst((String) merge.getAttribute(Columns.USU_MATRICULA_INST));
                }
                if (merge.getAtributos().containsKey(Columns.USU_CHAVE_RECUPERAR_SENHA)) {
                    usuarioBean.setUsuChaveRecuperarSenha((String) merge.getAttribute(Columns.USU_CHAVE_RECUPERAR_SENHA));
                }
                if (merge.getAtributos().containsKey(Columns.USU_OPERACOES_SENHA_2)) {
                    usuarioBean.setUsuOperacoesSenha2((Short) merge.getAttribute(Columns.USU_OPERACOES_SENHA_2));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DATA_REC_SENHA)) {
                    usuarioBean.setUsuDataRecSenha((java.util.Date) merge.getAttribute(Columns.USU_DATA_REC_SENHA));
                }
                if (merge.getAtributos().containsKey(Columns.USU_QTD_CONSULTAS_MARGEM)) {
                    usuarioBean.setUsuQtdConsultasMargem((Integer) merge.getAttribute(Columns.USU_QTD_CONSULTAS_MARGEM));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DATA_FIM_VIG)) {
                    final String dataOld = usuarioBean.getUsuDataFimVig() != null ? DateHelper.toDateString(usuarioBean.getUsuDataFimVig()) : "";
                    final String dataNew = merge.getAttribute(Columns.USU_DATA_FIM_VIG) != null ? DateHelper.toDateString((Date) merge.getAttribute(Columns.USU_DATA_FIM_VIG)) : "";
                    if (!dataOld.equals(dataNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.fim.vigencia.alterado.de.arg0.para.arg1", responsavel, dataOld, dataNew));
                    }
                    usuarioBean.setUsuDataFimVig((Date) merge.getAttribute(Columns.USU_DATA_FIM_VIG));
                }
                if (merge.getAtributos().containsKey(Columns.USU_DEFICIENTE_VISUAL)) {
                    final String usuDeficienteVisual = (String) merge.getAttribute(Columns.USU_DEFICIENTE_VISUAL);
                    final String deficienteVisualOld = usuarioBean.getUsuDeficienteVisual() != null ? usuarioBean.getUsuDeficienteVisual().toString() : "";
                    final String deficienteVisualNew = !TextHelper.isNull(usuDeficienteVisual) ? usuDeficienteVisual.substring(0, 1) : "";
                    if (!deficienteVisualOld.equals(deficienteVisualNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.deficiente.visual.alterado.de.arg0.para.arg1", responsavel, deficienteVisualOld, deficienteVisualNew));
                    }
                    usuarioBean.setUsuDeficienteVisual(!TextHelper.isNull(usuDeficienteVisual) ? usuDeficienteVisual.substring(0, 1) : null);
                }

                if (merge.getAtributos().containsKey(Columns.USU_CHAVE_VALIDACAO_EMAIL)) {
                    usuarioBean.setUsuChaveValidacaoEmail((String) merge.getAttribute(Columns.USU_CHAVE_VALIDACAO_EMAIL));
                }

                if (merge.getAtributos().containsKey(Columns.USU_DATA_VALIDACAO_EMAIL)) {
                    usuarioBean.setUsuDataValidacaoEmail((java.util.Date) merge.getAttribute(Columns.USU_DATA_VALIDACAO_EMAIL));
                }

                if (merge.getAtributos().containsKey(Columns.USU_AUTORIZA_EMAIL_MARKETING)) {
                    usuarioBean.setUsuAutorizaEmailMarketing((String) merge.getAttribute(Columns.USU_AUTORIZA_EMAIL_MARKETING));
                }

                if (stuAtivo) {
                    if (validaCpf) {
                        // Se o usuário está ativo, ou está sendo desbloqueado, validar obrigatoriedade
                        // do CPF, bem como sua unicidade, dado os parâmetros de sistema
                        validaCpfUsuario(usuarioBean.getUsuCpf(), tipo, responsavel);
                        validaUnicidadeCpf(usuCodigo, usuarioBean.getUsuCpf(), tipo, codigoEntidade, responsavel);
                    }
                    if (validaEmail) {
                        if (AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                            final boolean usuEmailObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_EMAIL_OBRIGATORIO_USUARIO_CSA, CodedValues.TPC_SIM, responsavel);
                            if (usuEmailObrigatorio && TextHelper.isNull(usuarioBean.getUsuEmail())) {
                                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.email.usuario.deve.ser.informado", responsavel);
                            }
                        } else if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                            final boolean usuEmailObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_EMAIL_OBRIGATORIO_CSE_ORG_SUP, CodedValues.TPC_SIM, responsavel);
                            if (usuEmailObrigatorio && TextHelper.isNull(usuarioBean.getUsuEmail())) {
                                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.email.usuario.deve.ser.informado", responsavel);
                            }
                        }
                    }
                    if (validaTel) {
                        if (AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                            final boolean usuTelObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_TELEFONE_OBRIGATORIO_USUARIO_CSA, CodedValues.TPC_SIM, responsavel);
                            if (usuTelObrigatorio && TextHelper.isNull(usuarioBean.getUsuTel())) {
                                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.telefone.usuario.deve.ser.informado", responsavel);
                            }
                        }
                        if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                            final boolean usuTelObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_TELEFONE_OBRIGATORIO_USUARIO_CSE, CodedValues.TPC_SIM, responsavel);
                            if (usuTelObrigatorio && TextHelper.isNull(usuarioBean.getUsuTel())) {
                                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.telefone.usuario.deve.ser.informado", responsavel);
                            }
                        }
                        if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                            final boolean usuTelObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_TELEFONE_OBRIGATORIO_USUARIO_SUP, CodedValues.TPC_SIM, responsavel);
                            if (usuTelObrigatorio && TextHelper.isNull(usuarioBean.getUsuTel())) {
                                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.telefone.usuario.deve.ser.informado", responsavel);
                            }
                        }
                    }
                }

                if (merge.getAtributos().containsKey(Columns.USU_CHAVE_VALIDACAO_TOTP) && (responsavel.getUsuCodigo().equals(usuario.getUsuCodigo()) || responsavel.isSup())) {
                    final String usuChaveValidacaoTotp = (String) merge.getAttribute(Columns.USU_CHAVE_VALIDACAO_TOTP);
                    final String chaveTotpOld = !TextHelper.isNull(usuarioBean.getUsuChaveValidacaoTotp()) ? usuarioBean.getUsuChaveValidacaoTotp() : "";
                    final String chaveTotpNew = !TextHelper.isNull(usuChaveValidacaoTotp) ? usuChaveValidacaoTotp : "";
                    if (!chaveTotpOld.equals(chaveTotpNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.chave.validacao.totp.alterado.de.arg0.para.arg1", responsavel, chaveTotpOld, chaveTotpNew));
                    }
                    usuarioBean.setUsuChaveValidacaoTotp(!TextHelper.isNull(usuChaveValidacaoTotp) ? usuChaveValidacaoTotp : null);
                }

                if (merge.getAtributos().containsKey(Columns.USU_PERMITE_VALIDACAO_TOTP) && (responsavel.getUsuCodigo().equals(usuario.getUsuCodigo()) || responsavel.isSup())) {
                    final String usuPermiteValidacaoTotp = (String) merge.getAttribute(Columns.USU_PERMITE_VALIDACAO_TOTP);
                    final String permiteTotpOld = !TextHelper.isNull(usuarioBean.getUsuPermiteValidacaoTotp()) ? usuarioBean.getUsuPermiteValidacaoTotp() : "";
                    final String permiteTotpNew = !TextHelper.isNull(usuPermiteValidacaoTotp) ? usuPermiteValidacaoTotp : "";
                    if (!permiteTotpOld.equals(permiteTotpNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.permite.validacao.totp.alterado.de.arg0.para.arg1", responsavel, permiteTotpOld, permiteTotpNew));
                    }
                    usuarioBean.setUsuPermiteValidacaoTotp(!TextHelper.isNull(usuPermiteValidacaoTotp) ? usuPermiteValidacaoTotp : null);
                }

                if (merge.getAtributos().containsKey(Columns.USU_OPERACOES_VALIDACAO_TOTP) && responsavel.getUsuCodigo().equals(usuario.getUsuCodigo())) {
                    final String usuOperacoesValidacaoTotp = (String) merge.getAttribute(Columns.USU_OPERACOES_VALIDACAO_TOTP);
                    final String operacoesTotpOld = !TextHelper.isNull(usuarioBean.getUsuOperacoesValidacaoTotp()) ? usuarioBean.getUsuOperacoesValidacaoTotp() : OperacaoValidacaoTotpEnum.AUTORIZACAO_OPERACAO_SENSIVEL.getCodigo();
                    final String operacoesTotpNew = !TextHelper.isNull(usuOperacoesValidacaoTotp) ? usuOperacoesValidacaoTotp : OperacaoValidacaoTotpEnum.AUTORIZACAO_OPERACAO_SENSIVEL.getCodigo();
                    if (!operacoesTotpOld.equals(operacoesTotpNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.operacoes.validacao.totp.alterado.de.arg0.para.arg1", responsavel, operacoesTotpOld, operacoesTotpNew));
                    }
                    usuarioBean.setUsuOperacoesValidacaoTotp(operacoesTotpNew);
                }

                if (merge.getAtributos().containsKey(Columns.USU_OTP_CHAVE_SEGURANCA)) {
                    final String usuOtpChaveSeguranca = (String) merge.getAttribute(Columns.USU_OTP_CHAVE_SEGURANCA);
                    final String chaveOtpOld = !TextHelper.isNull(usuarioBean.getUsuOtpChaveSeguranca()) ? usuarioBean.getUsuOtpChaveSeguranca() : "";
                    final String chaveOtpNew = !TextHelper.isNull(usuOtpChaveSeguranca) ? usuOtpChaveSeguranca : "";
                    if (!chaveOtpOld.equals(chaveOtpNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.otp.chave.seguranca.alterado.de.arg0.para.arg1", responsavel, chaveOtpOld, chaveOtpNew));
                    }
                    usuarioBean.setUsuOtpChaveSeguranca(!TextHelper.isNull(usuOtpChaveSeguranca) ? usuOtpChaveSeguranca : null);
                }

                if (merge.getAtributos().containsKey(Columns.USU_OTP_CODIGO)) {
                    final String usuOtpCodigo = (String) merge.getAttribute(Columns.USU_OTP_CODIGO);
                    final String otpCodigoOld = !TextHelper.isNull(usuarioBean.getUsuOtpCodigo()) ? usuarioBean.getUsuOtpCodigo() : "";
                    final String otpCodigoNew = !TextHelper.isNull(usuOtpCodigo) ? usuOtpCodigo : "";
                    if (!otpCodigoOld.equals(otpCodigoNew)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.otp.codigo.alterado.de.arg0.para.arg1", responsavel, otpCodigoOld, otpCodigoNew));
                    }
                    usuarioBean.setUsuOtpCodigo(!TextHelper.isNull(usuOtpCodigo) ? usuOtpCodigo : null);
                }

                if (merge.getAtributos().containsKey(Columns.USU_OTP_DATA_CADASTRO)) {
                    usuarioBean.setUsuOtpDataCadastro((java.util.Date) merge.getAttribute(Columns.USU_OTP_DATA_CADASTRO));
                }

                AbstractEntityHome.update(usuarioBean);

                // Atualiza o perfil do usuário
                if (!TextHelper.isNull(perCodigo) || (funcoes != null)) {
                    updateUsuarioPerfil(funcoes, perCodigo, usuario.getUsuCodigo(), codigoEntidade, tipo, true, responsavel);
                }

                if ((ocorrenciaUsu == null) && !merge.getAtributos().isEmpty()) {
                    // Cria ocorrência de alteração de usuário
                    ocorrenciaUsu = new OcorrenciaUsuarioTransferObject();
                    ocorrenciaUsu.setUsuCodigo(usuCodigo);
                    ocorrenciaUsu.setTocCodigo(CodedValues.TOC_ALTERACAO_USUARIO);
                    ocorrenciaUsu.setOusUsuCodigo(responsavel.getUsuCodigo());
                    ocorrenciaUsu.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.usuario", responsavel) + msgOus.toString());
                    ocorrenciaUsu.setOusIpAcesso(responsavel.getIpUsuario());
                }
                if ((ocorrenciaUsu != null) && (tipoMotivoOperacao != null)) {
                    ocorrenciaUsu.setOusObs(ocorrenciaUsu.getOusObs() + (ocorrenciaUsu.getOusObs().lastIndexOf(".") == (ocorrenciaUsu.getOusObs().length() - 1) ? " " : ". ") + tipoMotivoOperacao.getAttribute(Columns.OUS_OBS));
                    ocorrenciaUsu.setAttribute(Columns.OUS_TMO_CODIGO, tipoMotivoOperacao.getAttribute(Columns.TMO_CODIGO));
                }
                if (ocorrenciaUsu != null) {
                    createOcorrenciaUsuario(ocorrenciaUsu, responsavel);
                }

                log.write();

                // Se for exclusão de usuário csa, verifica se o parâmetro de sistema do papel autentica no SSO
                boolean autenticaSSO = false;
                if (!TextHelper.isNull(tipo) && !TextHelper.isNull(codigoEntidade) && CodedValues.STU_EXCLUIDO.equals(stu_codigo) && AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                    // Seta email apenas para validação do usuário
                    usuario.setUsuEmail(usuarioBean.getUsuEmail());
                    autenticaSSO = !TextHelper.isNull(usuarioBean.getUsuAutenticaSso()) && CodedValues.TPC_SIM.equals(usuarioBean.getUsuAutenticaSso()) && validarDadosSSO(usuario, codigoEntidade, tipo, responsavel);
                }

                if (autenticaSSO) {
                    // Irá verificar se o sso está habilitado e remover a ligação com a consignatária
                    ssoClient.removeServiceProviderFromUser(usuLoginAntesExclusao, tipo, codigoEntidade);
                }
            }
        } catch (final UsuarioControllerException ex) {
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw ex;
        } catch (ParametroControllerException | CorrespondenteControllerException | SSOException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(ex.getMessage(), responsavel, ex);
        } catch (UpdateException | FindException | LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public void updateEnderecoAcessoFuncao(CustomTransferObject dadosTo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final String usuCodigo = (String) dadosTo.getAttribute(Columns.USU_CODIGO);
            final String codEntidade = (String) dadosTo.getAttribute("COD_ENTIDADE");
            final String tipo = (String) dadosTo.getAttribute("TIPO");

            final String funCodigo = (String) dadosTo.getAttribute(Columns.FUN_CODIGO);
            final String funDescricao = (String) dadosTo.getAttribute(Columns.FUN_DESCRICAO);
            final String eafIpAcesso = (String) dadosTo.getAttribute(Columns.EAF_IP_ACESSO);
            final String eafDdnsAcesso = (String) dadosTo.getAttribute(Columns.EAF_DDNS_ACESSO);

            // Carrega o objeto do banco (se existir)
            final CustomTransferObject criterio = new CustomTransferObject();
            criterio.setAttribute(Columns.FUN_CODIGO, funCodigo);
            final EnderecoFuncaoTransferObject funcoesToAtual = selectFuncoes(usuCodigo, codEntidade, tipo, criterio, -1, -1, responsavel).get(funCodigo);
            boolean create = false;
            EnderecoAcessoFuncao eafBean = null;
            try {
                eafBean = EnderecoAcessoFuncaoHome.findByPrimaryKey(usuCodigo, funCodigo);
            } catch (final FindException ex) {
                eafBean = new EnderecoAcessoFuncao(usuCodigo, funCodigo, funcoesToAtual.getEafIpAcesso(), funcoesToAtual.getEafDdnsAcesso());
                create = true;
            }

            // Objeto a ser salvo
            final EnderecoFuncaoTransferObject funcoesToNovo = new EnderecoFuncaoTransferObject();
            funcoesToNovo.setFunCodigo(funCodigo);
            funcoesToNovo.setFunDescricao(funDescricao);
            funcoesToNovo.setEafIpAcesso(eafIpAcesso);
            funcoesToNovo.setEafDdnsAcesso(eafDdnsAcesso);

            // LOG
            final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_INFORMACAO);
            log.setUsuario(usuCodigo);

            final boolean podeEdtRestAcessoFun = usuarioPodeModificarUsu(usuCodigo, true, true, responsavel) && responsavel.temPermissao(CodedValues.FUN_EDT_RESTRICAO_ACESSO_POR_FUNCAO);

            // Se o usuário pode modificar o usuário, realiza a operação
            if (podeEdtRestAcessoFun) {
                // Compara as versões
                final CustomTransferObject merge = log.getUpdatedFields(funcoesToNovo.getAtributos(), funcoesToAtual.getAtributos());

                final StringBuilder msgOus = new StringBuilder();

                if (merge.getAtributos().containsKey(Columns.EAF_IP_ACESSO)) {
                    final String antes = eafBean.getEafIpAcesso() != null ? eafBean.getEafIpAcesso() : "";
                    final String depois = merge.getAttribute(Columns.EAF_IP_ACESSO) != null ? merge.getAttribute(Columns.EAF_IP_ACESSO).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.ip.acesso.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }
                    eafBean.setEafIpAcesso((String) merge.getAttribute(Columns.EAF_IP_ACESSO));
                }
                if (merge.getAtributos().containsKey(Columns.EAF_DDNS_ACESSO)) {
                    final String antes = eafBean.getEafDdnsAcesso() != null ? eafBean.getEafDdnsAcesso() : "";
                    final String depois = merge.getAttribute(Columns.EAF_DDNS_ACESSO) != null ? merge.getAttribute(Columns.EAF_DDNS_ACESSO).toString() : "";
                    if (!antes.equals(depois)) {
                        msgOus.append(ApplicationResourcesHelper.getMessage("mensagem.informacao.endereco.acesso.alterado.de.arg0.para.arg1", responsavel, antes, depois));
                    }
                    eafBean.setEafDdnsAcesso((String) merge.getAttribute(Columns.EAF_DDNS_ACESSO));
                }

                if (!create && TextHelper.isNull(eafIpAcesso) && TextHelper.isNull(eafDdnsAcesso)) {
                    AbstractEntityHome.remove(eafBean);
                } else if (create) {
                    EnderecoAcessoFuncaoHome.create(eafBean);
                } else {
                    AbstractEntityHome.update(eafBean);
                }

                if (!merge.getAtributos().isEmpty()) {
                    // Cria ocorrência de alteração de usuário
                    OcorrenciaUsuarioTransferObject ocorrenciaUsu = new OcorrenciaUsuarioTransferObject();
                    ocorrenciaUsu = new OcorrenciaUsuarioTransferObject();
                    ocorrenciaUsu.setUsuCodigo(usuCodigo);
                    ocorrenciaUsu.setTocCodigo(CodedValues.TOC_ALTERACAO_USUARIO);
                    ocorrenciaUsu.setOusUsuCodigo(responsavel.getUsuCodigo());
                    ocorrenciaUsu.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.usuario", responsavel) + msgOus.toString());
                    ocorrenciaUsu.setOusIpAcesso(responsavel.getIpUsuario());
                    if (ocorrenciaUsu != null) {
                        createOcorrenciaUsuario(ocorrenciaUsu, responsavel);
                    }
                }
                log.write();
            }
        } catch (CreateException | UpdateException | RemoveException | LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }

    }

    /**
     * Verifica obrigatoriedade do CPF, bem como se o valor informado é válido para um usuário.
     * @param usuCpf: CPF a ser validado
     * @param tipo : CSE, ORG, CSA, COR, SER ou SUP
     * @param responsavel: Responsável pela operação
     * @return TRUE caso o CPF seja informado e esteja correto, ou se não é obrigatório e não foi informado
     * @throws UsuarioControllerException
     */
    private boolean validaCpfUsuario(String usuCpf, String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        final String[] cpfsInvalidos = {
                                         "000.000.000-00", "111.111.111-11", "222.222.222-22", "333.333.333-33", "444.444.444-44",
                                         "555.555.555-55", "666.666.666-66", "777.777.777-77", "888.888.888-88", "999.999.999-99"
        };

        // Não valida CPF de usuário de suporte em sistema que não seja no Brasil
        final boolean validarCpfSuporte = (!AcessoSistema.ENTIDADE_SUP.equals(tipo) || LocaleHelper.BRASIL.equals(LocaleHelper.getLocale()));

        if (TextHelper.isNull(usuCpf)) {
            final boolean cpfObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_CPF_OBRIGATORIO_USUARIO, CodedValues.TPC_SIM, responsavel);
            if (cpfObrigatorio) {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.cpf.usuario.deve.ser.informado", responsavel);
            }
        } else if (validarCpfSuporte && (!TextHelper.cpfOk(TextHelper.dropSeparator(usuCpf)) || (Arrays.binarySearch(cpfsInvalidos, usuCpf) >= 0))) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.cpf.usuario.invalido", responsavel);
        }
        return true;
    }

    /**
     * Verifica se o sistema impede que o usuario de csa/cor cadastrado tenha CPF igual ao de algum outro usuario csa/cor
     * de entidade diferente ou de um servidor.
     * @param usuCodigo: Codigo do usuario.
     * @param usuCpf: CPF do usuario.
     * @param tipoEntidade: Tipo da entidade do usuario.
     * @param codigoEntidade: Código da entidade do usuário
     * @param responsavel: Responsavel pela operacao.
     * @throws UsuarioControllerException Excecao padrao.
     */
    private void validaUnicidadeCpf(String usuCodigo, String usuCpf, String tipoEntidade, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        if (!TextHelper.isNull(usuCpf) && !TextHelper.isNull(tipoEntidade)) {
            if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade) || AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
                // CPF cadastrado para um usuário de CSA/COR não pode ser igual a um CPF de servidor não excluído
                boolean exigeUnicidadeCPF = ParamSist.getBoolParamSist(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_CSA_E_SER, responsavel);
                if (exigeUnicidadeCPF && existeServidor(usuCpf, responsavel)) {
                    throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.servidor.mesmo.cpf", responsavel);
                }

                // CPF cadastrado para um usuário de CSA/COR não pode ser igual a um CPF de usuário CSE/ORG ativo
                exigeUnicidadeCPF = ParamSist.getBoolParamSist(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_CSA_E_CSE, responsavel);
                if (exigeUnicidadeCPF) {
                    List<TransferObject> usuarios = lstUsuarioCseOrg(usuCodigo, usuCpf, responsavel);
                    if ((usuarios != null) && (usuarios.size() > 0)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.gestor.mesmo.cpf", responsavel);
                    }
                    usuarios = lstUsuarioSup(usuCodigo, usuCpf, responsavel);
                    if ((usuarios != null) && (usuarios.size() > 0)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.suporte.mesmo.cpf", responsavel);
                    }
                }

                // CPF cadastrado para um usuário de CSA/COR não pode ser igual a um CPF de usuário de outra entidade CSA/COR ativo
                exigeUnicidadeCPF = ParamSist.getBoolParamSist(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_CSA, responsavel);
                if (exigeUnicidadeCPF) {
                    final List<TransferObject> usuarios = lstUsuarioCsaCor(usuCodigo, usuCpf, false, tipoEntidade, codigoEntidade, false, responsavel);
                    if ((usuarios != null) && (usuarios.size() > 0)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.usuario.outra.entidade.mesmo.cpf", responsavel);
                    }
                }

                // CPF cadastrado para um usuário de CSA/COR não pode ser igual a um CPF de usuário da mesma entidade CSA/COR ativo
                exigeUnicidadeCPF = ParamSist.getBoolParamSist(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_MESMA_CSA, responsavel);
                if (exigeUnicidadeCPF) {
                    final List<TransferObject> usuarios = lstUsuarioCsaCor(usuCodigo, usuCpf, false, tipoEntidade, codigoEntidade, true, responsavel);
                    if ((usuarios != null) && (usuarios.size() > 0)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.usuario.mesma.entidade.mesmo.cpf", responsavel);
                    }
                }

            } else if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade) || AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade) || AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
                // CPF cadastrado para um usuário de CSE/ORG não pode ser igual a um CPF de outro usuário CSE/ORG ativo
                boolean exigeUnicidadeCPF = ParamSist.getBoolParamSist(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_CSE, responsavel);
                if (exigeUnicidadeCPF) {
                    List<TransferObject> usuarios = lstUsuarioCseOrg(usuCodigo, usuCpf, responsavel);
                    if ((usuarios != null) && (usuarios.size() > 0)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.gestor.mesmo.cpf", responsavel);
                    }
                    usuarios = lstUsuarioSup(usuCodigo, usuCpf, responsavel);
                    if ((usuarios != null) && (usuarios.size() > 0)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.suporte.mesmo.cpf", responsavel);
                    }
                }

                // CPF cadastrado para um usuário de CSE/ORG não pode ser igual a um CPF de usuário CSA/COR ativo
                exigeUnicidadeCPF = ParamSist.getBoolParamSist(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_CSA_E_CSE, responsavel);
                if (exigeUnicidadeCPF) {
                    final List<TransferObject> usuarios = lstUsuarioCsaCor(usuCodigo, usuCpf, false, null, null, false, responsavel);
                    if ((usuarios != null) && (usuarios.size() > 0)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.possivel.realizar.esta.operacao.pois.existe.usuario.outra.entidade.mesmo.cpf", responsavel);
                    }
                }
            }
        }
    }

    private void updateUsuarioPerfil(List<String> funcoes, String perCodigo, String usuCodigo, String codigoEntidade, String tipo, boolean isAlteracao, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            // LOG Verificar log que está setando funções removidas/inseridas ou perfil alterado
            final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_INFORMACAO);
            log.setUsuario(usuCodigo);

            boolean alterou = false;

            // Pega as funções que o usuário possui nas tabelas tb_funcao_perfil_???
            final List<String> funcoesOld = getUsuarioFuncoes(usuCodigo, tipo, responsavel);

            final List<String> diff = new ArrayList<>();
            final List<String> excluir = new ArrayList<>();

            // Funções permitidas para o usuário
            final List<String> funcoesPermitidas = new ArrayList<>();
            final List<TransferObject> funPermUsu = lstFuncoesPermitidasUsuario(tipo, codigoEntidade, responsavel);
            if ((funPermUsu != null) && !funPermUsu.isEmpty()) {
                for (final TransferObject transferObject : funPermUsu) {
                    funcoesPermitidas.add(transferObject.getAttribute(Columns.FUN_CODIGO).toString());
                }
            }

            if (funcoes != null) {
                for (final String funPermitida : funcoesPermitidas) {
                    if (funcoesOld.contains(funPermitida) && !funcoes.contains(funPermitida)) {
                        excluir.add(funPermitida);
                    } else if (funcoesOld.contains(funPermitida) && funcoes.contains(funPermitida)) {
                        // Usuário já possui a função, não precisa incluir
                        continue;
                    } else if (!funcoesOld.contains(funPermitida) && funcoes.contains(funPermitida)) {
                        diff.add(funPermitida);
                    }
                }

                //Caso a função não seja permitida gera log de erro
                for (final String novaFuncao : funcoes) {
                    if (!funcoesPermitidas.contains(novaFuncao)) {
                        try {
                            final LogDelegate logErro = new LogDelegate(responsavel, Log.FUNCAO_PERFIL, Log.UPDATE, Log.LOG_ERRO_SEGURANCA);
                            logErro.setPerfil(perCodigo);
                            logErro.setFuncao(novaFuncao);
                            logErro.add(ApplicationResourcesHelper.getMessage("rotulo.erro.upper.arg0", responsavel, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.tem.permissao.incluir.esta.funcao", responsavel)));
                            logErro.write();
                            continue;
                        } catch (final LogControllerException ex) {
                            LOG.error(ex.getMessage(), ex);
                        }
                    }
                }

                // confere se usuário possui email cadastrado para atrbuir a função 248 (usuário auditor)
                if (funcoes.contains(CodedValues.FUN_USUARIO_AUDITOR)) {
                    final UsuarioTransferObject filtro = new UsuarioTransferObject(usuCodigo);

                    final UsuarioTransferObject usuario = findUsuario(filtro, tipo, responsavel);
                    if (TextHelper.isNull(usuario.getUsuEmail())) {
                        throw new UsuarioControllerException("mensagem.erro.email.valido.deve.ser.cadastrado.para.atribuir.permissao.auditor.ao.usuario", responsavel);
                    }
                }
            } else {
                excluir.addAll(funcoesOld);
            }

            List<String> funcPerfil = null;
            if (!TextHelper.isNull(perCodigo)) {
                funcPerfil = getFuncaoPerfil(tipo, codigoEntidade, perCodigo, responsavel);
            }

            // confere se é o último usuário auditor para a entidade alvo.
            if (excluir.contains(CodedValues.FUN_USUARIO_AUDITOR) && !podeRemoverFuncAuditoria(usuCodigo, codigoEntidade, tipo, responsavel) && ((funcPerfil == null) || !funcPerfil.contains(CodedValues.FUN_USUARIO_AUDITOR))) {
                throw new UsuarioControllerException("mensagem.erro.permissao.auditoria.nao.pode.remover", responsavel);
            }

            // confere se usuário possui email cadastrado para atrbuir a função 248 (usuário auditor)
            // para o caso de ser atribuído a um perfil
            if (!TextHelper.isNull(perCodigo)) {
                funcPerfil = getFuncaoPerfil(tipo, codigoEntidade, perCodigo, responsavel);

                if (funcPerfil.contains(CodedValues.FUN_USUARIO_AUDITOR)) {
                    final UsuarioTransferObject filtro = new UsuarioTransferObject(usuCodigo);

                    final UsuarioTransferObject usuario = findUsuario(filtro, tipo, responsavel);
                    if (TextHelper.isNull(usuario.getUsuEmail())) {
                        throw new UsuarioControllerException("mensagem.erro.email.valido.deve.ser.cadastrado.para.atribuir.permissao.auditor.ao.usuario", responsavel);
                    }
                }
            }

            // Apagar as removidas presentes em funcoesOld
            if (excluir.size() > 0) {
                removeFuncaoPerfilUsuario(excluir, usuCodigo, tipo);
                log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.removendo.permissoes", responsavel, TextHelper.join(excluir, ",")));
                alterou = true;
            }

            // Adicionar as novas presentes em diff
            if (diff.size() > 0) {
                createUsuarioPerfil(diff, usuCodigo, codigoEntidade, tipo);
                log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.inserindo.permissoes", responsavel, TextHelper.join(diff, ",")));
                alterou = true;
            }

            // Busca o perfil do usuário
            PerfilUsuario upeBean = null;
            Perfil perfilAnterior = null;
            try {
                upeBean = PerfilUsuarioHome.findByPrimaryKey(usuCodigo);
                perfilAnterior = PerfilHome.findByPrimaryKey(upeBean.getPerfil().getPerCodigo());
            } catch (final FindException ex) {
            }

            String obs = "";
            if (!TextHelper.isNull(perCodigo) && (upeBean != null)) {
                // Se o usuário mudou de perfil
                if (!perCodigo.equals(perfilAnterior.getPerCodigo())) {
                    log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.trocando.de.perfil", responsavel, perfilAnterior.getPerCodigo() + "," + perCodigo));
                    final Perfil perfil = PerfilHome.findByPrimaryKey(perCodigo);
                    obs = ApplicationResourcesHelper.getMessage("mensagem.informacao.de.arg0.para.arg1", responsavel, perfilAnterior.getPerDescricao(), perfil.getPerDescricao());
                    upeBean.setPerfil(perfil);
                    AbstractEntityHome.update(upeBean);
                    alterou = true;
                }
            } else if (!TextHelper.isNull(perCodigo)) {
                // Se o usuário agora tem um perfil
                log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.incluindo.perfil", responsavel, perCodigo));
                final Perfil perfil = PerfilHome.findByPrimaryKey(perCodigo);
                obs = ApplicationResourcesHelper.getMessage("mensagem.informacao.de.arg0.para.arg1", responsavel, ApplicationResourcesHelper.getMessage("rotulo.usuario.perfil.personalizado", responsavel), perfil.getPerDescricao());
                PerfilUsuarioHome.create(usuCodigo, perCodigo);
                alterou = true;
            } else if (upeBean != null) {
                // Se o usuário não tem mais um perfil
                log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.excluindo.perfil", responsavel, perfilAnterior.getPerCodigo()));
                obs = ApplicationResourcesHelper.getMessage("mensagem.informacao.de.arg0.para.arg1", responsavel, perfilAnterior.getPerDescricao(), ApplicationResourcesHelper.getMessage("rotulo.usuario.perfil.personalizado", responsavel));
                AbstractEntityHome.remove(upeBean);
                alterou = true;
            }

            log.write();

            // Se alterou o perfil de funções do usuário
            if (alterou && isAlteracao) {
                // Cria ocorrência de alteração de perfil de usuário
                final CustomTransferObject ocorrencia = new CustomTransferObject();
                ocorrencia.setAttribute(Columns.OUS_USU_CODIGO, usuCodigo);
                ocorrencia.setAttribute(Columns.OUS_TOC_CODIGO, CodedValues.TOC_ALTERACAO_PERFIL_USUARIO);
                ocorrencia.setAttribute(Columns.OUS_OUS_USU_CODIGO, responsavel.getUsuCodigo());
                ocorrencia.setAttribute(Columns.OUS_OBS, ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.perfil.usuario", responsavel) + obs);
                ocorrencia.setAttribute(Columns.OUS_IP_ACESSO, responsavel.getIpUsuario());

                createOcorrenciaUsuario(ocorrencia, responsavel);
            }
        } catch (CreateException | UpdateException | RemoveException | FindException | LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    /**
     * confere se a função de auditoria pode ser removida do usuário alvo. se ele for o último auditor
     * da entidade e houver funções auditadas para esta, a função não pode ser removida.
     * @param usuCodigo
     * @param codigoEntidade
     * @param tipo
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public boolean podeRemoverFuncAuditoria(String usuCodigo, String codigoEntidade, String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        // se estiver removendo a permissão de auditor, verificar se há funções auditadas para a entidade
        // e se este é o último usuário auditor do sistema
        final ListaUsuariosAuditoresQuery lstAuditores = new ListaUsuariosAuditoresQuery();
        final List<String> usuCodigos = new ArrayList<>();
        usuCodigos.add(CodedValues.NOT_EQUAL_KEY);
        usuCodigos.add(usuCodigo);
        lstAuditores.usuCodigo = usuCodigos;
        lstAuditores.codigoEntidade = codigoEntidade;
        lstAuditores.tipo = tipo;
        lstAuditores.count = true;

        try {
            final int auditoresQntd = lstAuditores.executarContador();
            if (auditoresQntd <= 0) {
                final ListaFuncoesAuditadasQuery funcAuditadasEnt = new ListaFuncoesAuditadasQuery();
                funcAuditadasEnt.codigoEntidade = codigoEntidade;
                funcAuditadasEnt.tipo = tipo;
                funcAuditadasEnt.count = true;

                final int numFuncAuditadas = funcAuditadasEnt.executarContador();
                if (numFuncAuditadas > 0) {
                    return false;
                }
            }
        } catch (final HQueryException e) {
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
        }

        return true;
    }

    @Override
    public void removeUsuario(UsuarioTransferObject usuario, String tipo, TransferObject tipoMotivoOperacao, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if (usuarioPodeModificarUsu(usuario.getUsuCodigo(), true, true, responsavel)) {

                try {
                    // Verifica se o responsável pela operação ainda existe, ou seja, se o usuário não foi excluido.
                    findUsuarioBean(new UsuarioTransferObject(responsavel.getUsuCodigo()), responsavel.getTipoEntidade());
                } catch (final UsuarioControllerException ex) {
                    throw new UsuarioControllerException("mensagem.erro.nao.possivel.excluir.usuario.selecionado.pois.seu.usuario.esta.bloqueado", responsavel);
                }

                final Usuario usuarioBean = findUsuarioBean(usuario, tipo);
                final String usuCodigo = usuarioBean.getUsuCodigo();

                final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.DELETE, Log.LOG_INFORMACAO);
                log.setUsuario(usuCodigo);

                // Se o usuário que está excluindo é o mesmo usuário que será excluído
                if (usuCodigo.equals(responsavel.getUsuCodigo())) {
                    throw new UsuarioControllerException("mensagem.erro.usuario.nao.pode.ser.excluido.por.ele.proprio", responsavel);
                }

                String tpcEnviaAuditoria = null;
                try {
                    if (responsavel.isCseSupOrg()) {
                        tpcEnviaAuditoria = parametroController.findParamSistCse(CodedValues.TPC_PERIODO_ENVIO_EMAIL_AUDITORIA_CSE_ORG, "1", responsavel);
                    } else if (responsavel.isCsaCor()) {
                        tpcEnviaAuditoria = parametroController.findParamSistCse(CodedValues.TPC_PERIODO_ENVIO_EMAIL_AUDITORIA_CSA_COR, "1", responsavel);
                    }
                } catch (final ParametroControllerException e1) {
                    LOG.error(e1.getMessage(), e1);
                    throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e1);
                }

                if (!TextHelper.isNull(tpcEnviaAuditoria) && !CodedValues.PER_ENV_EMAIL_AUDIT_DESABILITADO.equals(tpcEnviaAuditoria)) {
                    final ListaUsuariosAuditoresQuery usuAuditListQuery = new ListaUsuariosAuditoresQuery();

                    final String codEntidade = usuario.getAttribute(Columns.COR_CODIGO) != null ? (String) usuario.getAttribute(Columns.COR_CODIGO) : usuario.getAttribute(Columns.CSA_CODIGO) != null ? (String) usuario.getAttribute(Columns.CSA_CODIGO) : usuario.getAttribute(Columns.CSE_CODIGO) != null ? (String) usuario.getAttribute(Columns.CSE_CODIGO) : usuario.getAttribute(Columns.ORG_CODIGO) != null ? (String) usuario.getAttribute(Columns.ORG_CODIGO) : null;

                    if (!TextHelper.isNull(codEntidade)) {
                        usuAuditListQuery.codigoEntidade = codEntidade;
                        usuAuditListQuery.stuCodigo = CodedValues.STU_ATIVO;
                        usuAuditListQuery.tipo = tipo;

                        try {
                            final List<UsuarioTransferObject> usuAuditList = usuAuditListQuery.executarDTO(UsuarioTransferObject.class);
                            if (usuAuditList.size() == 1) {
                                final String usuCodigoAudit = usuAuditList.get(0).getUsuCodigo();

                                // se usuário é o último auditor remascente da entidade e houver configuração de auditoria para esta,
                                // a remoção do usuário não é permitida
                                if (usuCodigoAudit.equals(usuario.getUsuCodigo())) {
                                    throw new UsuarioControllerException("mensagem.erro.usuario.nao.pode.ser.removido.pois.entidade.possui.configuracoes.auditoria", responsavel);
                                }
                            }
                        } catch (final HQueryException e) {
                            LOG.error(e.getMessage(), e);
                            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
                        }
                    }
                }

                String entidade = null;
                if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                    entidade = (String) usuario.getAttribute(Columns.COR_CODIGO);
                } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                    entidade = (String) usuario.getAttribute(Columns.CSA_CODIGO);
                } else if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                    entidade = (String) usuario.getAttribute(Columns.CSE_CODIGO);
                } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                    entidade = (String) usuario.getAttribute(Columns.ORG_CODIGO);
                } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                    entidade = (String) usuario.getAttribute(Columns.CSE_CODIGO);
                }

                final Map<String, EnderecoFuncaoTransferObject> funcMap = selectFuncoes(usuCodigo, entidade, tipo, responsavel);
                final Set<String> keySet = funcMap.keySet();

                if (keySet.contains(CodedValues.FUN_USUARIO_AUDITOR) && !podeRemoverFuncAuditoria(usuCodigo, entidade, tipo, responsavel)) {
                    throw new UsuarioControllerException("mensagem.erro.permissao.auditoria.nao.pode.remover", responsavel);
                }

                // Remove ligacao entre perfil e usuário (tb_perfil_usuario) para perfis especificos
                try {
                    final PerfilUsuario upeBean = PerfilUsuarioHome.findByPrimaryKey(usuCodigo);
                    AbstractEntityHome.remove(upeBean);
                    final List<String> funcoes = getFuncaoPerfil(tipo, usuCodigo, upeBean.getPerfil().getPerCodigo(), responsavel);

                    log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.funcoes.removidas", responsavel, TextHelper.join(funcoes, ",")));
                } catch (final FindException e) {
                } // Se nao achou é porque usuario possui perfil personalizado

                // Exclui da tabela tb_funcao_perfil_xxx para perfis personalizados
                final List<String> listaFuncoes = removeFuncaoPerfilUsuario(null, usuCodigo, tipo);
                if ((listaFuncoes != null) && !listaFuncoes.isEmpty()) {
                    log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.funcoes.removidas", responsavel, TextHelper.join(listaFuncoes, ",")));
                }

                // Cria ocorrência de exclusão
                final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                ocorrencia.setUsuCodigo(usuario.getUsuCodigo());
                ocorrencia.setTocCodigo(CodedValues.TOC_EXCLUSAO_USUARIO);
                ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.exclusao.usuario", responsavel));
                ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
                if (tipoMotivoOperacao != null) {
                    ocorrencia.setOusObs(ocorrencia.getOusObs() + (ocorrencia.getOusObs().lastIndexOf(".") == (ocorrencia.getOusObs().length() - 1) ? " " : ". ") + tipoMotivoOperacao.getAttribute(Columns.OUS_OBS));
                    ocorrencia.setAttribute(Columns.OUS_TMO_CODIGO, tipoMotivoOperacao.getAttribute(Columns.TMO_CODIGO));
                }

                // Exclusão lógica de usuário
                usuario.setStuCodigo(CodedValues.STU_EXCLUIDO);
                alteraUsuario(usuario, ocorrencia, null, null, tipo, entidade, false, false, false, null, responsavel);

                log.write();
            }
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
        } catch (final RemoveException ex) {
            LOG.error(ex.getMessage());
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.excluir.usuario.selecionado.erro.interno.arg0", responsavel, ex.getMessage());
        } catch (final UsuarioControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(ex);
        }
    }

    private void removeVinculoFuncao(String funCodigo, List<String> papCodigos, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final LogDelegate log = new LogDelegate(responsavel, Log.FUNCAO_PERFIL, Log.DELETE, Log.LOG_INFORMACAO);
            log.setFuncao(funCodigo);

            final Funcao funcao = FuncaoHome.findByPrimaryKey(funCodigo);

            // Exclui todos os vínculos da função com qualquer perfil personalizado de qualquer usuário
            final ListaFuncaoPerfilTodasEntidadesQuery funPerTodasEntidades = new ListaFuncaoPerfilTodasEntidadesQuery();
            funPerTodasEntidades.funCodigo = funCodigo;
            final List<TransferObject> fpeEntidades = funPerTodasEntidades.executarDTO();
            if (fpeEntidades != null) {
                for (final TransferObject fpe : fpeEntidades) {
                    final String codigoEntidade = fpe.getAttribute("CODIGO_ENTIDADE").toString();
                    final String tipoEntidade = fpe.getAttribute("TIPO_ENTIDADE").toString();
                    final String papel = fpe.getAttribute("PAPEL").toString();
                    final String usuCodigo = fpe.getAttribute(Columns.USU_CODIGO).toString();

                    if ((papCodigos == null) || papCodigos.isEmpty() || !papCodigos.contains(papel)) {
                        if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade)) {
                            final FuncaoPerfilCseId id = new FuncaoPerfilCseId();
                            id.setCseCodigo(codigoEntidade);
                            id.setFunCodigo(funCodigo);
                            id.setUsuCodigo(usuCodigo);

                            final FuncaoPerfilCse fp = new FuncaoPerfilCse();
                            fp.setFuncao(funcao);
                            fp.setId(id);

                            AbstractEntityHome.remove(fp);
                        } else if (AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade)) {
                            final FuncaoPerfilOrgId id = new FuncaoPerfilOrgId();
                            id.setOrgCodigo(codigoEntidade);
                            id.setFunCodigo(funCodigo);
                            id.setUsuCodigo(usuCodigo);

                            final FuncaoPerfilOrg fp = new FuncaoPerfilOrg();
                            fp.setFuncao(funcao);
                            fp.setId(id);

                            AbstractEntityHome.remove(fp);
                        } else if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade)) {
                            final FuncaoPerfilCsaId id = new FuncaoPerfilCsaId();
                            id.setCsaCodigo(codigoEntidade);
                            id.setFunCodigo(funCodigo);
                            id.setUsuCodigo(usuCodigo);

                            final FuncaoPerfilCsa fp = new FuncaoPerfilCsa();
                            fp.setFuncao(funcao);
                            fp.setId(id);

                            AbstractEntityHome.remove(fp);
                        } else if (AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
                            final FuncaoPerfilCorId id = new FuncaoPerfilCorId();
                            id.setCorCodigo(codigoEntidade);
                            id.setFunCodigo(funCodigo);
                            id.setUsuCodigo(usuCodigo);

                            final FuncaoPerfilCor fp = new FuncaoPerfilCor();
                            fp.setFuncao(funcao);
                            fp.setId(id);

                            AbstractEntityHome.remove(fp);
                        } else if (AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
                            final FuncaoPerfilSupId id = new FuncaoPerfilSupId();
                            id.setCseCodigo(codigoEntidade);
                            id.setFunCodigo(funCodigo);
                            id.setUsuCodigo(usuCodigo);

                            final FuncaoPerfilSup fp = new FuncaoPerfilSup();
                            fp.setFuncao(funcao);
                            fp.setId(id);

                            AbstractEntityHome.remove(fp);
                        }
                        log.setUsuario(usuCodigo);
                        log.write();
                    }
                }
            }

            // Exclui todos os vínculos da função com qualquer perfil
            final ListaPerfilTodasEntidadesPossuemFuncaoQuery lstPerfilFuncaoTodasEntidades = new ListaPerfilTodasEntidadesPossuemFuncaoQuery();
            lstPerfilFuncaoTodasEntidades.funCodigo = funCodigo;
            final List<TransferObject> funcoesPerfil = lstPerfilFuncaoTodasEntidades.executarDTO();
            if (funcoesPerfil != null) {
                for (final TransferObject to : funcoesPerfil) {
                    final String perCodigo = to.getAttribute(Columns.PER_CODIGO).toString();
                    final String papel = to.getAttribute("PAPEL").toString();

                    if ((papCodigos == null) || papCodigos.isEmpty() || !papCodigos.contains(papel)) {
                        final FuncaoPerfilId id = new FuncaoPerfilId();
                        id.setFunCodigo(funCodigo);
                        id.setPerCodigo(perCodigo);

                        final FuncaoPerfil fpe = new FuncaoPerfil();
                        fpe.setFuncao(funcao);
                        fpe.setId(id);

                        AbstractEntityHome.remove(fpe);

                        log.setPerfil(perCodigo);
                        log.setFuncao(funCodigo);
                        log.write();
                    }
                }
            }
        } catch (HQueryException | FindException | RemoveException | LogControllerException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.excluir.permissoes.usuario.erro.interno.arg0", responsavel, e.getMessage());
        }
    }

    private List<String> removeFuncaoPerfilUsuario(List<String> drop, String usuCodigo, String tipo) throws UsuarioControllerException {
        tipo = tipo.toUpperCase();
        final List<String> listaFuncoes = new ArrayList<>();
        try {
            final Collection<?> funcoes = findFuncaoPerfilBean(usuCodigo, tipo);
            final Iterator<?> it = funcoes.iterator();
            if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                while (it.hasNext()) {
                    final FuncaoPerfilCse fp = (FuncaoPerfilCse) it.next();
                    if ((drop == null) || drop.contains(fp.getFunCodigo())) {
                        AbstractEntityHome.remove(fp);
                        listaFuncoes.add(fp.getFunCodigo());
                    }
                }
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                while (it.hasNext()) {
                    final FuncaoPerfilCsa fp = (FuncaoPerfilCsa) it.next();
                    if ((drop == null) || drop.contains(fp.getFunCodigo())) {
                        AbstractEntityHome.remove(fp);
                        listaFuncoes.add(fp.getFunCodigo());
                    }
                }
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                while (it.hasNext()) {
                    final FuncaoPerfilCor fp = (FuncaoPerfilCor) it.next();
                    if ((drop == null) || drop.contains(fp.getFunCodigo())) {
                        AbstractEntityHome.remove(fp);
                        listaFuncoes.add(fp.getFunCodigo());
                    }
                }
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                while (it.hasNext()) {
                    final FuncaoPerfilOrg fp = (FuncaoPerfilOrg) it.next();
                    if ((drop == null) || drop.contains(fp.getFunCodigo())) {
                        AbstractEntityHome.remove(fp);
                        listaFuncoes.add(fp.getFunCodigo());
                    }
                }
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                while (it.hasNext()) {
                    final FuncaoPerfilSup fp = (FuncaoPerfilSup) it.next();
                    if ((drop == null) || drop.contains(fp.getFunCodigo())) {
                        AbstractEntityHome.remove(fp);
                        listaFuncoes.add(fp.getFunCodigo());
                    }
                }
            }
        } catch (final RemoveException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.excluir.usuario.selecionado.erro.interno.arg0", (AcessoSistema) null, ex.getMessage());
        }
        return listaFuncoes;
    }

    /** LISTAGEM DE USUÁRIOS --------------------------------------------------------------------------------- **/

    // Get (lst_usuario_papel)
    @Override
    public List<TransferObject> getUsuarios(String tipo, String codigo, CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException {
        return lstUsuarios("0", tipo, codigo, filtro, offset, count, responsavel);
    }

    // List (lst_usuario)
    @Override
    public List<TransferObject> listUsuarios(String tipo, String codigo, CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException {
        return lstUsuarios("1", tipo, codigo, filtro, offset, count, responsavel);
    }

    @Override
    public List<TransferObject> lstUsuarios(String opcao, String tipo, String codigoEntidade, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException {
        return lstUsuarios(opcao, tipo, codigoEntidade, filtro, -1, -1, responsavel);
    }

    @Override
    public List<TransferObject> lstUsuarios(String opcao, String tipo, String codigoEntidade, CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException {

        if (!responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_CSE) && !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_CSA) && !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_COR) && !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_ORG) && !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_SUP)) {
            return new ArrayList<>();
        }

        // somente usuários de suporte podem listar usuários de papel suporte
        if (AcessoSistema.ENTIDADE_SUP.equals(tipo) && !responsavel.isSup()) {
            return new ArrayList<>();
        }

        try {
            if ("1".equals(opcao)) {
                final ListaUsuariosQuery query = new ListaUsuariosQuery();
                query.responsavel = responsavel;

                if (offset != -1) {
                    query.firstResult = offset;
                }

                if (count != -1) {
                    query.maxResults = count;
                }

                query.tipo = tipo;
                query.entCodigo = codigoEntidade;

                if (filtro != null) {
                    query.cseNome = (String) filtro.getAttribute(Columns.CSE_NOME);
                    query.usuCodigo = (String) filtro.getAttribute(Columns.USU_CODIGO);
                    query.usuLogin = (String) filtro.getAttribute(Columns.USU_LOGIN);
                    query.usuNome = (String) filtro.getAttribute(Columns.USU_NOME);
                    query.usuCpf = (String) filtro.getAttribute(Columns.USU_CPF);
                    query.stuCodigo = filtro.getAttribute(Columns.USU_STU_CODIGO);
                    query.orgNome = (String) filtro.getAttribute(Columns.ORG_NOME);
                    query.csaNome = (String) filtro.getAttribute(Columns.CSA_NOME + CodedValues.OR_KEY + Columns.CSA_NOME_ABREV);
                    query.csaNomeAbrev = (String) filtro.getAttribute(Columns.CSA_NOME + CodedValues.OR_KEY + Columns.CSA_NOME_ABREV);
                    query.corNome = (String) filtro.getAttribute(Columns.COR_NOME);
                    query.orgNome = (String) filtro.getAttribute(Columns.ORG_NOME);
                    query.usuCseUsuCodigo = (String) filtro.getAttribute(Columns.UCE_USU_CODIGO);
                    query.usuCsaUsuCodigo = (String) filtro.getAttribute(Columns.UCA_USU_CODIGO);
                    query.usuCorUsuCodigo = (String) filtro.getAttribute(Columns.UCO_USU_CODIGO);
                    query.usuOrgUsuCodigo = (String) filtro.getAttribute(Columns.UOR_USU_CODIGO);
                    if (filtro.getAttribute("OCULTA_USU_VISIVEL") != null) {
                        query.ocultaUsuVisivel = (Boolean) filtro.getAttribute("OCULTA_USU_VISIVEL");
                    }
                }

                return query.executarDTO();
            } else {
                final ListaUsuariosEntidadeQuery query = new ListaUsuariosEntidadeQuery();
                if (offset != -1) {
                    query.firstResult = offset;
                }

                if (count != -1) {
                    query.maxResults = count;
                }

                query.entCodigo = codigoEntidade;
                query.tipo = tipo;
                query.perCodigo = (String) filtro.getAttribute(Columns.PER_CODIGO);
                query.perDescricao = (String) filtro.getAttribute(Columns.PER_DESCRICAO);
                query.usuCodigo = (String) filtro.getAttribute(Columns.USU_CODIGO);
                query.usuLogin = (String) filtro.getAttribute(Columns.USU_LOGIN);
                query.usuNome = (String) filtro.getAttribute(Columns.USU_NOME);
                query.usuCpf = (String) filtro.getAttribute(Columns.USU_CPF);
                query.stuCodigo = filtro.getAttribute(Columns.USU_STU_CODIGO);
                query.usuEmail = (String) filtro.getAttribute(Columns.USU_EMAIL);
                if (filtro.getAttribute("OCULTA_USU_VISIVEL") != null) {
                    query.ocultaUsuVisivel = (Boolean) filtro.getAttribute("OCULTA_USU_VISIVEL");
                }

                return query.executarDTO();
            }

        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public int countUsuarios(String tipo, String codigo, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException {
        return countUsuarios("0", tipo, codigo, filtro, responsavel);
    }

    @Override
    public int listCountUsuarios(String tipo, String codigo, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException {
        return countUsuarios("1", tipo, codigo, filtro, responsavel);
    }

    @Override
    public int countUsuarios(String opcao, String tipo, String codigoEntidade, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException {
        if (!responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_CSE) &&
            !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_CSA) &&
            !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_COR) &&
            !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_ORG) &&
            !responsavel.temPermissao(CodedValues.FUN_CONS_USUARIOS_SUP)) {

            return 0;
        }

        // somente usuários de suporte podem listar usuários de papel suporte
        if (AcessoSistema.ENTIDADE_SUP.equals(tipo) && !responsavel.isSup()) {
            return 0;
        }

        try {
            if ("1".equals(opcao)) {
                final ListaUsuariosQuery query = new ListaUsuariosQuery();
                query.responsavel = responsavel;

                query.count = true;
                query.tipo = tipo;
                query.entCodigo = codigoEntidade;

                if (filtro != null) {
                    query.cseNome = (String) filtro.getAttribute(Columns.CSE_NOME);
                    query.usuCodigo = (String) filtro.getAttribute(Columns.USU_CODIGO);
                    query.usuLogin = (String) filtro.getAttribute(Columns.USU_LOGIN);
                    query.usuNome = (String) filtro.getAttribute(Columns.USU_NOME);
                    query.usuCpf = (String) filtro.getAttribute(Columns.USU_CPF);
                    query.stuCodigo = filtro.getAttribute(Columns.USU_STU_CODIGO);
                    query.orgNome = (String) filtro.getAttribute(Columns.ORG_NOME);
                    query.csaNome = (String) filtro.getAttribute(Columns.CSA_NOME + CodedValues.OR_KEY + Columns.CSA_NOME_ABREV);
                    query.csaNomeAbrev = (String) filtro.getAttribute(Columns.CSA_NOME + CodedValues.OR_KEY + Columns.CSA_NOME_ABREV);
                    query.corNome = (String) filtro.getAttribute(Columns.COR_NOME);
                    query.orgNome = (String) filtro.getAttribute(Columns.ORG_NOME);
                    query.usuCseUsuCodigo = (String) filtro.getAttribute(Columns.UCE_USU_CODIGO);
                    query.usuCsaUsuCodigo = (String) filtro.getAttribute(Columns.UCA_USU_CODIGO);
                    query.usuCorUsuCodigo = (String) filtro.getAttribute(Columns.UCO_USU_CODIGO);
                    query.usuOrgUsuCodigo = (String) filtro.getAttribute(Columns.UOR_USU_CODIGO);
                    if (filtro.getAttribute("OCULTA_USU_VISIVEL") != null) {
                        query.ocultaUsuVisivel = (Boolean) filtro.getAttribute("OCULTA_USU_VISIVEL");
                    }
                }

                return query.executarContador();
            } else {
                final ListaUsuariosEntidadeQuery query = new ListaUsuariosEntidadeQuery();
                query.entCodigo = codigoEntidade;
                query.tipo = tipo;
                query.perCodigo = (String) filtro.getAttribute(Columns.PER_CODIGO);
                query.perDescricao = (String) filtro.getAttribute(Columns.PER_DESCRICAO);
                query.usuCodigo = (String) filtro.getAttribute(Columns.USU_CODIGO);
                query.usuLogin = (String) filtro.getAttribute(Columns.USU_LOGIN);
                query.usuNome = (String) filtro.getAttribute(Columns.USU_NOME);
                query.usuCpf = (String) filtro.getAttribute(Columns.USU_CPF);
                query.stuCodigo = filtro.getAttribute(Columns.USU_STU_CODIGO);
                if (filtro.getAttribute("OCULTA_USU_VISIVEL") != null) {
                    query.ocultaUsuVisivel = (Boolean) filtro.getAttribute("OCULTA_USU_VISIVEL");
                }
                query.count = true;

                return query.executarContador();
            }

        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /** LISTAGEM DE USUÁRIOS SERVIDORES ---------------------------------------------------------------------- **/

    @Override
    public List<TransferObject> lstUsuariosSerByRseCodigo(String rseCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuariosSerQuery query = new ListaUsuariosSerQuery();
            query.rseCodigo = rseCodigo;
            return query.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public List<TransferObject> lstUsuariosSerByRseCodigos(List<String> rseCodigos, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuariosSerRseQuery query = new ListaUsuariosSerRseQuery();
            query.rseCodigos = rseCodigos;
            return query.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public List<TransferObject> lstUsuariosSer(String serCpf, String rseMatricula, String estIdentificador, String orgIdentificador, AcessoSistema responsavel) throws UsuarioControllerException {
        return lstUsuariosSer(serCpf, rseMatricula, estIdentificador, orgIdentificador, -1, -1, responsavel);
    }

    @Override
    public List<TransferObject> lstUsuariosSer(String serCpf, String rseMatricula, String estIdentificador, String orgIdentificador, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuariosSerQuery query = new ListaUsuariosSerQuery();

            if (offset != -1) {
                query.firstResult = offset;
            }

            if (count != -1) {
                query.maxResults = count;
            }

            query.serCpf = serCpf;
            query.rseMatricula = rseMatricula;
            query.estIdentificador = estIdentificador;
            query.orgIdentificador = orgIdentificador;

            return query.executarDTO();

        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /**
     *
     * @param usuLogin
     * @param rseMatricula
     * @param serCpf
     * @param estIdentificador
     * @param orgIdentificador
     * @param serSomenteAtivo
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public List<TransferObject> lstUsuariosSerLoginComCpf(String usuLogin, String rseMatricula, String serCpf, String estIdentificador, String orgIdentificador, boolean serSomenteAtivo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuariosServidorLoginQuery listaUsuariosServidorLoginQuery = new ListaUsuariosServidorLoginQuery();
            listaUsuariosServidorLoginQuery.usuLogin = usuLogin;
            listaUsuariosServidorLoginQuery.rseMatricula = rseMatricula;
            listaUsuariosServidorLoginQuery.serCpf = serCpf;
            listaUsuariosServidorLoginQuery.estIdentificador = estIdentificador;
            listaUsuariosServidorLoginQuery.orgIdentificador = orgIdentificador;
            listaUsuariosServidorLoginQuery.serSomenteAtivo = serSomenteAtivo;

            return listaUsuariosServidorLoginQuery.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /**
     * Retorna as funções associadas ao perfil personalizado do usuário, porém
     * somente as funções que podem ser repassadas do usuário responsavel para
     * o usuário usuCodigo.
     * @param usuCodigo : usuário que está sendo editado
     * @param tipo : tipo do usuário que está sendo editado
     * @param responsavel : responsável pela edição do usuário
     * @return A lista de funCodigos
     * @throws UsuarioControllerException
     */
    @Override
    public List<String> getUsuarioFuncoes(String usuCodigo, String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if (AcessoSistema.ENTIDADE_SER.equals(tipo)) {
                // DESENV-15096 : usuário servidor não tem mais perfil personalizado
                return new ArrayList<>();
            }

            final ListaFuncoesUsuarioQuery query = new ListaFuncoesUsuarioQuery();

            query.tipo = tipo;
            query.usuCodigo = usuCodigo;
            query.papCodigoDestino = UsuarioHelper.getPapCodigo(tipo);
            query.papCodigoOrigem = UsuarioHelper.getPapCodigo(responsavel.getTipoEntidade());

            return query.executarLista();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public Funcao findFuncao(String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            return FuncaoHome.findByPrimaryKey(funCodigo);
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public String createFuncao(String grfCodigo, String funDescricao, String funPermiteBloqueio, String funExigeTmo, String funExigeSegundaSenhaCse, String funExigeSegundaSenhaSup, String funExigeSegundaSenhaOrg, String funExigeSegundaSenhaCsa, String funExigeSegundaSenhaCor, String funExigeSegundaSenhaSer, String funAuditavel, List<String> papCodigos, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final Funcao funcao = FuncaoHome.create(grfCodigo, funDescricao, funPermiteBloqueio, funExigeTmo, funExigeSegundaSenhaCse, funExigeSegundaSenhaSup, funExigeSegundaSenhaOrg, funExigeSegundaSenhaCsa, funExigeSegundaSenhaCor, funExigeSegundaSenhaSer, funAuditavel);
            final String funCodigo = funcao.getFunCodigo();

            createPapelFuncao(papCodigos, funCodigo, responsavel);

            final LogDelegate logDelegate = new LogDelegate(responsavel, Log.FUNCAO, Log.CREATE, Log.LOG_INFORMACAO);
            logDelegate.setFuncao(funCodigo);
            logDelegate.setGrupoFuncao(grfCodigo);
            logDelegate.write();

            return funCodigo;
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(ex);
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
        }
    }

    private void createPapelFuncao(List<String> papCodigos, String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if ((papCodigos != null) && !papCodigos.isEmpty()) {
                for (final String papCodigo : papCodigos) {
                    PapelFuncaoHome.create(funCodigo, papCodigo);
                }
            }
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public void updateFuncao(TransferObject funcaoTO, List<String> papCodigos, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final String funCodigo = funcaoTO.getAttribute(Columns.FUN_CODIGO).toString();

            final Funcao funcao = FuncaoHome.findByPrimaryKey(funCodigo);
            final TransferObject cache = new CustomTransferObject();
            cache.setAttribute(Columns.FUN_CODIGO, funcao.getFunCodigo());
            cache.setAttribute(Columns.FUN_DESCRICAO, funcao.getFunDescricao());
            cache.setAttribute(Columns.FUN_AUDITAVEL, funcao.getFunAuditavel());
            cache.setAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_CSE, funcao.getFunExigeSegundaSenhaCse());
            cache.setAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_SUP, funcao.getFunExigeSegundaSenhaSup());
            cache.setAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_ORG, funcao.getFunExigeSegundaSenhaOrg());
            cache.setAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_CSA, funcao.getFunExigeSegundaSenhaCsa());
            cache.setAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_COR, funcao.getFunExigeSegundaSenhaCor());
            cache.setAttribute(Columns.FUN_EXIGE_TMO, funcao.getFunExigeTmo());
            cache.setAttribute(Columns.FUN_GRF_CODIGO, funcao.getGrupoFuncao().getGrfCodigo());
            cache.setAttribute(Columns.FUN_PERMITE_BLOQUEIO, funcao.getFunPermiteBloqueio());

            final LogDelegate log = new LogDelegate(responsavel, Log.FUNCAO, Log.UPDATE, Log.LOG_INFORMACAO);
            log.setFuncao(funCodigo);

            /* Compara a versão do cache com a passada por parâmetro */
            final CustomTransferObject merge = log.getUpdatedFields(funcaoTO.getAtributos(), cache.getAtributos());
            if (merge.getAtributos().containsKey(Columns.FUN_DESCRICAO)) {
                funcao.setFunDescricao((String) merge.getAttribute(Columns.FUN_DESCRICAO));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_AUDITAVEL)) {
                funcao.setFunAuditavel((String) merge.getAttribute(Columns.FUN_AUDITAVEL));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_EXIGE_SEGUNDA_SENHA_CSE)) {
                funcao.setFunExigeSegundaSenhaCse((String) merge.getAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_CSE));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_EXIGE_SEGUNDA_SENHA_SUP)) {
                funcao.setFunExigeSegundaSenhaSup((String) merge.getAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_SUP));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_EXIGE_SEGUNDA_SENHA_ORG)) {
                funcao.setFunExigeSegundaSenhaOrg((String) merge.getAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_ORG));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_EXIGE_SEGUNDA_SENHA_CSA)) {
                funcao.setFunExigeSegundaSenhaCsa((String) merge.getAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_CSA));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_EXIGE_SEGUNDA_SENHA_COR)) {
                funcao.setFunExigeSegundaSenhaCor((String) merge.getAttribute(Columns.FUN_EXIGE_SEGUNDA_SENHA_COR));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_EXIGE_TMO)) {
                funcao.setFunExigeTmo((String) merge.getAttribute(Columns.FUN_EXIGE_TMO));
            }
            if (merge.getAtributos().containsKey(Columns.FUN_GRF_CODIGO)) {
                funcao.setGrupoFuncao(GrupoFuncaoHome.findByPrimaryKey((String) merge.getAttribute(Columns.FUN_GRF_CODIGO)));
                if (!TextHelper.isNull(merge.getAttribute(Columns.FUN_GRF_CODIGO))) {
                    log.setGrupoFuncao((String) merge.getAttribute(Columns.FUN_GRF_CODIGO));
                }
            }
            if (merge.getAtributos().containsKey(Columns.FUN_PERMITE_BLOQUEIO)) {
                funcao.setFunPermiteBloqueio((String) merge.getAttribute(Columns.FUN_PERMITE_BLOQUEIO));
            }
            AbstractEntityHome.update(funcao);

            if ((papCodigos != null) && !papCodigos.isEmpty()) {
                // Remove os papeis função antigos e insere novos papeis para a função
                removePapelFuncao(funCodigo, responsavel);
                createPapelFuncao(papCodigos, funCodigo, responsavel);

                removeVinculoFuncao(funCodigo, papCodigos, responsavel);
            }

        } catch (FindException | UpdateException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(e);
        } catch (final LogControllerException e) {
            LOG.error(e.getMessage(), e);
            throw new UsuarioControllerException(e);
        }
    }

    @Override
    public void removeFuncao(String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final Funcao funcao = FuncaoHome.findByPrimaryKey(funCodigo);

            removeVinculoFuncao(funCodigo, null, responsavel);

            removePapelFuncao(funCodigo, responsavel);

            AbstractEntityHome.remove(funcao);

            final LogDelegate logDelegate = new LogDelegate(responsavel, Log.FUNCAO, Log.DELETE, Log.LOG_INFORMACAO);
            logDelegate.setFuncao(funCodigo);
            logDelegate.write();

        } catch (FindException | RemoveException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(e);
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
        }
    }

    private void removePapelFuncao(String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final Collection<PapelFuncao> papeis = PapelFuncaoHome.findByFunCodigo(funCodigo);
            for (final PapelFuncao papel : papeis) {
                AbstractEntityHome.remove(papel);
            }
        } catch (FindException | RemoveException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(e);
        }
    }

    @Override
    public int countFuncao(TransferObject criterio, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListarFuncaoQuery query = new ListarFuncaoQuery();
            query.count = true;

            if ((criterio != null) && !TextHelper.isNull(criterio.getAttribute(Columns.FUN_DESCRICAO))) {
                query.funDescricao = criterio.getAttribute(Columns.FUN_DESCRICAO).toString();
            }

            if ((criterio != null) && !TextHelper.isNull(criterio.getAttribute(Columns.GRF_DESCRICAO))) {
                query.grfDescricao = criterio.getAttribute(Columns.GRF_DESCRICAO).toString();
            }

            return query.executarContador();

        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public List<TransferObject> listFuncao(TransferObject criterio, int offset, int size, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListarFuncaoQuery query = new ListarFuncaoQuery();

            if ((criterio != null) && !TextHelper.isNull(criterio.getAttribute(Columns.FUN_DESCRICAO))) {
                query.funDescricao = criterio.getAttribute(Columns.FUN_DESCRICAO).toString();
            }

            if ((criterio != null) && !TextHelper.isNull(criterio.getAttribute(Columns.GRF_DESCRICAO))) {
                query.grfDescricao = criterio.getAttribute(Columns.GRF_DESCRICAO).toString();
            }

            if (offset != -1) {
                query.firstResult = offset;
            }

            if (size != -1) {
                query.maxResults = size;
            }

            return query.executarDTO();

        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /**
     * Retorna um Mapa com as funções associadas ao perfil do usuário (tanto personalizado
     * quanto perfil fixo). Todas as funções são retornadas independente de bloqueio de repasse.
     * @param usuCodigo
     * @param entidade
     * @param tipo
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */

    @Override
    public Map<String, EnderecoFuncaoTransferObject> selectFuncoes(String usuCodigo, String entidade, String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        return selectFuncoes(usuCodigo, entidade, tipo, null, -1, -1, responsavel);
    }

    /**
     * Retorna um Mapa com as funções associadas ao perfil do usuário (tanto personalizado
     * quanto perfil fixo). Todas as funções são retornadas independente de bloqueio de repasse.
     * @param usuCodigo
     * @param entidade
     * @param tipo
     * @param filtro
     * @param offset
     * @param count
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public Map<String, EnderecoFuncaoTransferObject> selectFuncoes(String usuCodigo, String entidade, String tipo, CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException {
        List<EnderecoFuncaoTransferObject> listResult = null;
        final Map<String, EnderecoFuncaoTransferObject> mapResult = new LinkedHashMap<>(); // Necessário manter ordenação para exibição
        String funCodigo = null, funDescricao = null;
        if ((filtro != null) && !filtro.getAtributos().isEmpty()) {
            funCodigo = (String) filtro.getAttribute(Columns.FUN_CODIGO);
            funDescricao = (String) filtro.getAttribute(Columns.FUN_DESCRICAO);
        }

        try {
            LOG.debug("usuCodigo: " + usuCodigo);

            try {
                if (TextHelper.isNull(usuCodigo)) {
                    throw new FindException("mensagem.erro.entidade.nao.encontrada", (AcessoSistema) null);
                }
                final PerfilUsuario upeBean = PerfilUsuarioHome.findByPrimaryKey(usuCodigo);

                // Busca as funções do perfil
                final FuncoesPerfilQuery query = new FuncoesPerfilQuery();
                query.perCodigo = upeBean.getPerfil().getPerCodigo();
                query.usuCodigo = usuCodigo;
                query.funCodigo = funCodigo;
                query.funDescricao = funDescricao;
                if (offset != -1) {
                    query.firstResult = offset;
                }

                if (count != -1) {
                    query.maxResults = count;
                }
                listResult = query.executarDTO(EnderecoFuncaoTransferObject.class);

            } catch (final FindException e) {
                if (AcessoSistema.ENTIDADE_SER.equals(tipo)) {
                    // DESENV-15096 : usuário servidor não tem mais perfil personalizado
                    listResult = new ArrayList<>();

                } else {
                    // Busca as funções p/ perfil personalizado
                    final FuncoesPersonalizadasQuery query = new FuncoesPersonalizadasQuery();
                    query.usuCodigo = usuCodigo;
                    query.entidade = entidade;
                    query.tipo = tipo;
                    query.funCodigo = funCodigo;
                    query.funDescricao = funDescricao;
                    if (offset != -1) {
                        query.firstResult = offset;
                    }

                    if (count != -1) {
                        query.maxResults = count;
                    }
                    listResult = query.executarDTO(EnderecoFuncaoTransferObject.class);
                }
            }
        } catch (final DAOException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }

        // Cria um mapa para facilitar a manter a compatibilidade com a estrutura (Map<String, String>, onde a chave era funCodigo e o valor era funDescricao)
        // e métodos anteriores reduzindo o impacto da alteração.
        for (final EnderecoFuncaoTransferObject enderecoFuncaoTo : listResult) {
            mapResult.put((String) enderecoFuncaoTo.getAttribute(Columns.FUN_CODIGO), enderecoFuncaoTo);
        }
        return mapResult;
    }

    /**
     * Retorna um Mapa com as funções associadas ao perfil do usuário para retrição de acesso (tanto personalizado
     * quanto perfil fixo). Somente funções com acesso_recurso e papel associados
     * @param usuCodigo
     * @param entidade
     * @param tipo
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public Map<String, String> selectFuncoesRestricaoAcesso(String usuCodigo, String entidade, String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        Map<String, String> result = null;
        try {
            LOG.debug("usuCodigo: " + usuCodigo);

            try {
                final PerfilUsuario upeBean = PerfilUsuarioHome.findByPrimaryKey(usuCodigo);

                // Busca as funções do perfil
                final FuncoesPerfilRestricaoAcessoQuery query = new FuncoesPerfilRestricaoAcessoQuery();
                query.perCodigo = upeBean.getPerfil().getPerCodigo();
                query.papel = responsavel.getPapCodigo();
                result = query.executarMapa();

            } catch (final FindException e) {
                if (!TextHelper.isNull(tipo) && AcessoSistema.ENTIDADE_SER.equals(tipo)) {
                    // DESENV-15096 : usuário servidor não tem mais perfil personalizado
                    return new HashMap<>();
                }

                // Busca as funções p/ perfil personalizado
                final FuncoesPersonalizadasRestricaoAcessoQuery query = new FuncoesPersonalizadasRestricaoAcessoQuery();
                query.usuCodigo = usuCodigo;
                query.entidade = entidade;
                query.tipo = tipo;
                query.papel = responsavel.getPapCodigo();
                result = query.executarMapa();
            }
        } catch (final DAOException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }

        return result;
    }

    @Override
    public List<TransferObject> selectFuncoes(String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesPermitidasPapelQuery funcoesQuery = new ListaFuncoesPermitidasPapelQuery();
            funcoesQuery.papCodigoOrigem = UsuarioHelper.getPapCodigo(responsavel.getTipoEntidade());
            funcoesQuery.papCodigoDestino = UsuarioHelper.getPapCodigo(tipo);
            return funcoesQuery.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    /**
     * Recupera todas funções permitidas por natureza de consignatária
     * @param ncaCodigo
     * @return
     * @throws UsuarioControllerException
     */
    private List<String> selectFuncoesPermitidasNca(String ncaCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final List<String> resultado = new ArrayList<>();
            final ListaFuncoesPermitidasNcaQuery funcoesQuery = new ListaFuncoesPermitidasNcaQuery();
            funcoesQuery.ncaCodigo = ncaCodigo;
            final List<TransferObject> funcoes = funcoesQuery.executarDTO();
            for (final TransferObject funcao : funcoes) {
                resultado.add((String) funcao.getAttribute(Columns.FPN_FUN_CODIGO));
            }
            return resultado;
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public List<TransferObject> selectFuncoesSensiveisCsa(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            return new ListaFuncoesSensiveisCsaQuery().executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /**
     * Lista as permissões de função por natureza de consignatária.
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public List<TransferObject> selectFuncoesPermitidasNca(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesPermitidasNcaQuery funcoesQuery = new ListaFuncoesPermitidasNcaQuery();
            return funcoesQuery.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    /**
     * Recupera todos os papeis do sistema.
     *
     * @return Retorna uma lista com todos os papeis do sistema.
     * @throws UsuarioControllerException
     */
    @Override
    public List<TransferObject> lstPapel(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaPapeisQuery query = new ListaPapeisQuery();
            return query.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    /** BLOQUEIO DE FUNÇÕES ---------------------------------------------------------------------------------- **/

    @Override
    public List<TransferObject> lstFuncoes(String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesQuery query = new ListaFuncoesQuery();
            query.tipo = tipo;
            return query.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public Map<String, String> getMapFuncoes(String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesQuery query = new ListaFuncoesQuery();
            query.tipo = tipo;
            return query.executarMapa();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public List<TransferObject> lstFuncoesBloqueaveis(String tipo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesBloqueaveisQuery funcoesBloqQuery = new ListaFuncoesBloqueaveisQuery();
            funcoesBloqQuery.tipo = tipo;
            return funcoesBloqQuery.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public List<TransferObject> findFuncoesRegraTaxa(String funCodigos, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesRegraTaxaQuery funcoesRegraTaxa = new ListaFuncoesRegraTaxaQuery();
            funcoesRegraTaxa.funCodigos = funCodigos;
            return funcoesRegraTaxa.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public List<TransferObject> selectFuncoesBloqueadas(String usuario, AcessoSistema responsavel) throws UsuarioControllerException {
        return selectFuncoesBloqueadas(usuario, null, responsavel);
    }

    @Override
    public List<TransferObject> selectFuncoesBloqueadas(String usuario, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesBloqueadasQuery funcoesBloqueadasQuery = new ListaFuncoesBloqueadasQuery();
            funcoesBloqueadasQuery.usuCodigo = usuario;
            funcoesBloqueadasQuery.tipoEntidade = tipoEntidade;
            return funcoesBloqueadasQuery.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public void insereBloqueiosFuncoes(String usuCodigo, List<TransferObject> bloqueios, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            // Remove as funções antigas bloqueadas
            final List<BloqueioUsuFunSvc> blocToRemove = BloqueioUsuFunSvcHome.findByUsuCodigo(usuCodigo);
            for (final BloqueioUsuFunSvc bloqueio : blocToRemove) {
                AbstractEntityHome.remove(bloqueio);

                final LogDelegate log = new LogDelegate(responsavel, Log.BLOQUEIO_FUNCAO_USU_SVC, Log.DELETE, Log.LOG_INFORMACAO);
                log.setUsuario(usuCodigo);
                log.setServico(bloqueio.getServico().getSvcCodigo());
                log.setFuncao(bloqueio.getFuncao().getFunCodigo());
                log.write();
            }

            // Insere as novas funções bloqueadas
            if ((bloqueios != null) && !bloqueios.isEmpty()) {
                for (final TransferObject bloqueio : bloqueios) {
                    final String svcCodigo = bloqueio.getAttribute(Columns.BUF_SVC_CODIGO).toString();
                    final String funCodigo = bloqueio.getAttribute(Columns.BUF_FUN_CODIGO).toString();
                    BloqueioUsuFunSvcHome.create(funCodigo, usuCodigo, svcCodigo);

                    final LogDelegate log = new LogDelegate(responsavel, Log.BLOQUEIO_FUNCAO_USU_SVC, Log.CREATE, Log.LOG_INFORMACAO);
                    log.setUsuario(usuCodigo);
                    log.setServico(svcCodigo);
                    log.setFuncao(funCodigo);
                    log.write();
                }
            }

            if (!blocToRemove.isEmpty() || ((bloqueios != null) && !bloqueios.isEmpty())) {
                // Cria ocorrência de alteração de perfil de usuário
                final CustomTransferObject ocorrencia = new CustomTransferObject();
                ocorrencia.setAttribute(Columns.OUS_USU_CODIGO, usuCodigo);
                ocorrencia.setAttribute(Columns.OUS_TOC_CODIGO, CodedValues.TOC_ALTERACAO_PERFIL_USUARIO);
                ocorrencia.setAttribute(Columns.OUS_OUS_USU_CODIGO, responsavel.getUsuCodigo());
                ocorrencia.setAttribute(Columns.OUS_OBS, ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.perfil.usuario", responsavel));
                ocorrencia.setAttribute(Columns.OUS_IP_ACESSO, responsavel.getIpUsuario());

                createOcorrenciaUsuario(ocorrencia, responsavel);
            }
        } catch (CreateException | RemoveException | FindException | LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public boolean usuarioTemBloqueioFuncao(String usuCodigo, String funCodigo, String svcCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        final CustomTransferObject funcao = getFuncao(funCodigo, responsavel);

        if (funcao == null) {
            return true;
        }

        if (funcao.getAttribute(Columns.FUN_PERMITE_BLOQUEIO) == null) {
            return false;
        }

        if (CodedValues.TPC_SIM.equals(funcao.getAttribute(Columns.FUN_PERMITE_BLOQUEIO).toString())) {
            final List<TransferObject> bloqueiosUsuario = selectFuncoesBloqueadas(usuCodigo, responsavel);
            for (final TransferObject bloqueio : bloqueiosUsuario) {
                if (bloqueio.getAttribute(Columns.BUF_USU_CODIGO).toString().equals(usuCodigo) && bloqueio.getAttribute(Columns.BUF_FUN_CODIGO).toString().equals(funCodigo) && bloqueio.getAttribute(Columns.BUF_SVC_CODIGO).toString().equals(svcCodigo)) {
                    return true;
                }
            }
        } else {
        }

        return false;
    }

    @Override
    public List<TransferObject> lstFuncaoExigeTmo(String funExigeTmo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemFuncaoQuery funQuery = new ObtemFuncaoQuery();
            funQuery.funExigeTmo = funExigeTmo;
            return funQuery.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    /** EDIÇÃO DE PERFIL -------------------------------------------------------------------------------------- **/

    @Override
    public Perfil findPerfil(String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            return PerfilHome.findByPrimaryKey(perCodigo);
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, "");
        }
    }

    @Override
    public Short getPerfilStatus(String perCodigo, String tipo, String entCodigo, AcessoSistema responsavel) throws FindException, UsuarioControllerException {
        try {
            if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                final PerfilCse perCse = PerfilCseHome.findByPrimaryKey(new PerfilCseId(entCodigo, perCodigo));
                return perCse.getPceAtivo();
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                final PerfilCsa perCsa = PerfilCsaHome.findByPrimaryKey(new PerfilCsaId(entCodigo, perCodigo));
                return perCsa.getPcaAtivo();
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                final PerfilOrg perOrg = PerfilOrgHome.findByPrimaryKey(new PerfilOrgId(entCodigo, perCodigo));
                return perOrg.getPorAtivo();
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                final PerfilCor perCor = PerfilCorHome.findByPrimaryKey(new PerfilCorId(entCodigo, perCodigo));
                return perCor.getPcoAtivo();
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                final PerfilSup perSup = PerfilSupHome.findByPrimaryKey(new PerfilSupId(entCodigo, perCodigo));
                return perSup.getPsuAtivo();
            } else {
                return null;
            }
        } catch (final FindException fex) {
            throw fex;
        } catch (final Exception ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.recuperar.perfil", responsavel);
        }
    }

    @Override
    public String createPerfil(String tipoEntidade, String codigoEntidade, String perDescricao, String perVisivel, java.util.Date perDataExpiracao, String perEntAltera, String perOrigem, String perAutoDesbloqueio, List<String> funCodigo, String perIpAcesso, String perDdnsAcesso, AcessoSistema responsavel) throws UsuarioControllerException {
        return createPerfil(tipoEntidade, codigoEntidade, perDescricao, perVisivel, perDataExpiracao, perEntAltera, perOrigem, perAutoDesbloqueio, funCodigo, null, perIpAcesso, perDdnsAcesso, responsavel);
    }

    @Override
    public String createPerfil(String tipoEntidade, String codigoEntidade, String perDescricao, String perVisivel, java.util.Date perDataExpiracao, String perEntAltera, String perOrigem, String perAutoDesbloqueio, List<String> funCodigo, Boolean pcaPerfilPadrao, String perIpAcesso, String perDdnsAcesso, AcessoSistema responsavel) throws UsuarioControllerException {
        String perCodigo = null;
        try {
            final String papCodigo = UsuarioHelper.getPapCodigo(tipoEntidade);
            final Short status = CodedValues.STS_ATIVO;
            if (TextHelper.isNull(perEntAltera)) {
                perEntAltera = CodedValues.TPA_SIM;
            }

            if (TextHelper.isNull(perAutoDesbloqueio)) {
                perAutoDesbloqueio = CodedValues.TPA_NAO;
            }

            // Cria o perfil
            final Perfil perBean = PerfilHome.create(papCodigo, perDescricao, perVisivel, perDataExpiracao, perAutoDesbloqueio, perEntAltera, perIpAcesso, perDdnsAcesso );
            perCodigo = perBean.getPerCodigo();

            // Se for passado um perfil de origem, as funções do perfil de origem serão replicadas para o novo perfil
            if (!TextHelper.isNull(perOrigem)) {
                funCodigo = new ArrayList<>();
                final Collection<FuncaoPerfil> funcoesPerfil = FuncaoPerfilHome.findByPerfil(perOrigem);
                if ((funcoesPerfil != null) && !funcoesPerfil.isEmpty()) {
                    for (final FuncaoPerfil funcaoPerfil : funcoesPerfil) {
                        funCodigo.add(funcaoPerfil.getFunCodigo());
                    }
                }
            }

            // Cria as funções para o perfil
            updateFuncaoPerfil(tipoEntidade, codigoEntidade, perCodigo, funCodigo, responsavel);

            // Associa o perfil a sua entidade
            if (CodedValues.PAP_CONSIGNANTE.equals(papCodigo)) { // CSE
                PerfilCseHome.create(codigoEntidade, perCodigo, status);
            } else if (CodedValues.PAP_CONSIGNATARIA.equals(papCodigo)) { // CSA
                PerfilCsaHome.create(codigoEntidade, perCodigo, status, pcaPerfilPadrao);
                updateOthersPerfils(pcaPerfilPadrao, codigoEntidade, perCodigo);
            } else if (CodedValues.PAP_ORGAO.equals(papCodigo)) { // ORG
                PerfilOrgHome.create(codigoEntidade, perCodigo, status);
            } else if (CodedValues.PAP_CORRESPONDENTE.equals(papCodigo)) { // COR
                PerfilCorHome.create(codigoEntidade, perCodigo, status);
            } else if (CodedValues.PAP_SUPORTE.equals(papCodigo)) { // SUP
                PerfilSupHome.create(codigoEntidade, perCodigo, status);
            } else {
                throw new UsuarioControllerException("mensagem.erro.arg0.tipo.entidade.invalido", responsavel, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
            }

            // Verifica se o responsável pode modificar este perfil
            usuarioPodeModificarPerfil(perCodigo, false, true, responsavel);

            // Gera o log de auditoria
            final LogDelegate logDelegate = new LogDelegate(responsavel, Log.PERFIL, Log.CREATE, Log.LOG_INFORMACAO);
            logDelegate.setPerfil(perCodigo);
            if (!TextHelper.isNull(perOrigem)) {
                logDelegate.setPerfilOrigem(perOrigem);
                logDelegate.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.perfil.criado.a.partir.das.funcoes.associadas.perfil.origem", responsavel));
            }
            logDelegate.write();

            if ((funCodigo != null) && funCodigo.isEmpty()) {
                criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.criado", responsavel), null, responsavel);
            }

        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.interno.do.sistema.ao.criar.perfil", responsavel);
        } catch (final Exception ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();

            if (ex instanceof UsuarioControllerException) {
                throw (UsuarioControllerException) ex;
            } else {
                throw new UsuarioControllerException("mensagem.erro.interno.do.sistema.ao.criar.perfil", responsavel);
            }
        }

        return perCodigo;
    }

    @Override
    public void updatePerfil(String tipoEntidade, String codigoEntidade, String perCodigo, String perDescricao, String perVisivel, java.util.Date perDataExpiracao, String perEntAltera, Short status, String perAutDesbloqueio, String perIpAcesso, String perDdnsAcesso, Boolean pcaPerfilPadrao, List<String> funcoes, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if (usuarioPodeModificarPerfil(perCodigo, true, true, responsavel)) {
                final String papCodigo = UsuarioHelper.getPapCodigo(tipoEntidade);

                // Busca o perfil
                final Perfil perBean = PerfilHome.findByPrimaryKey(perCodigo);
                boolean alterou = false;

                // Cria log de edição do perfil
                final LogDelegate logDelegate = new LogDelegate(responsavel, Log.PERFIL, Log.UPDATE, Log.LOG_INFORMACAO);
                logDelegate.setPerfil(perCodigo);

                // Altera a descrição do perfil
                if ((perDescricao != null) && !perDescricao.equals(perBean.getPerDescricao())) {
                    logDelegate.addChangedField(Columns.PER_DESCRICAO, perDescricao, perBean.getPerDescricao());
                    perBean.setPerDescricao(perDescricao);
                    alterou = true;
                }
                if ((perVisivel != null) && !perVisivel.equals(perBean.getPerVisivel())) {
                    logDelegate.addChangedField(Columns.PER_VISIVEL, perVisivel, perBean.getPerVisivel());
                    perBean.setPerVisivel(perVisivel);
                    alterou = true;
                }
                if (((perDataExpiracao != null) && (perBean.getPerDataExpiracao() != null) && (perBean.getPerDataExpiracao().compareTo(perDataExpiracao) != 0)) || (TextHelper.isNull(perDataExpiracao) && (perBean.getPerDataExpiracao() != null)) || (!TextHelper.isNull(perDataExpiracao) && TextHelper.isNull(perBean.getPerDataExpiracao()))) {
                    logDelegate.addChangedField(Columns.PER_DATA_EXPIRACAO, perDataExpiracao, perBean.getPerDataExpiracao());
                    perBean.setPerDataExpiracao(perDataExpiracao);
                    alterou = true;
                }

                if ((perAutDesbloqueio != null) && (perBean.getPerAutoDesbloqueio() != null) && (perBean.getPerAutoDesbloqueio().compareTo(perAutDesbloqueio) != 0)) {
                    logDelegate.addChangedField(Columns.PER_AUTO_DESBLOQUEIO, perAutDesbloqueio, perBean.getPerAutoDesbloqueio());
                    perBean.setPerAutoDesbloqueio(perAutDesbloqueio);
                    alterou = true;
                }

                if ((perEntAltera != null) && !perEntAltera.equals(perBean.getPerEntAltera())) {
                    perBean.setPerEntAltera(perEntAltera);
                    alterou = true;
                }

                //Altera ip do perfil.
                if((perIpAcesso != null) && !perIpAcesso.equals(perBean.getPerIpAcesso())) {
                    perBean.setPerIpAcesso(perIpAcesso);
                    alterou = true;
                }

                //Altera ddns do perfil.
                if((perDdnsAcesso != null) && !perDdnsAcesso.equals(perBean.getPerDdnsAcesso())) {
                    perBean.setPerDdnsAcesso(perDdnsAcesso);
                    alterou = true;
                }

                if (alterou) {
                    AbstractEntityHome.update(perBean);
                }

                // Altera o perfil nas tabelas de entidades
                if (!TextHelper.isNull(papCodigo)) {
                    if (CodedValues.PAP_CONSIGNANTE.equals(papCodigo)) { // CSE
                        updatePcaCseBean(codigoEntidade, perCodigo, status, logDelegate);
                    } else if (CodedValues.PAP_CONSIGNATARIA.equals(papCodigo)) { // CSA
                        updatePcaCsaBean(codigoEntidade, perCodigo, status, pcaPerfilPadrao, logDelegate);
                    } else if (CodedValues.PAP_ORGAO.equals(papCodigo)) { // ORG
                        updatePcaOrgBean(codigoEntidade, perCodigo, status, logDelegate);
                    } else if (CodedValues.PAP_CORRESPONDENTE.equals(papCodigo)) { // COR
                        updatePcaCorBean(codigoEntidade, perCodigo, status, logDelegate);
                    } else if (CodedValues.PAP_SUPORTE.equals(papCodigo)) { // SUP
                        updatePcaSupBean(codigoEntidade, perCodigo, status, logDelegate);
                    } else {
                        throw new UsuarioControllerException("mensagem.erro.arg0.tipo.entidade.invalido", responsavel, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
                    }
                }
                
                if (status != null) {
                    if (status.equals(CodedValues.STS_ATIVO)) {
                        criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.desbloqueio", responsavel), null, responsavel);
                    } else {
                        criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.bloqueio", responsavel), null, responsavel);
                    }
                }

                // Atualiza as funções do perfil
                final boolean funcoesAlteradas = updateFuncaoPerfil(tipoEntidade, codigoEntidade, perCodigo, funcoes, responsavel);

                // Atualiza o log
                logDelegate.write();

                if ((funcoes != null) && funcoes.isEmpty()) {
                    criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.alterado", responsavel), null, responsavel);
                }

                if (funcoesAlteradas) {
                    // Notifica as entidades da alteração do perfil de usuário
                    EnviaEmailHelper.enviarEmailAlteracaoPerfil(perCodigo, tipoEntidade, codigoEntidade, responsavel);
                }
            }
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, "");
        } catch (final UpdateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.atualizar.este.perfil.erro.interno.arg0", responsavel, ex.getMessage());
        } catch (final ZetraException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    private void updatePcaCsaBean(String codigoEntidade, String perCodigo, Short status, Boolean pcaPerfilPadrao,
            final LogDelegate logDelegate) throws FindException, UpdateException, LogControllerException {

        final PerfilCsa pcaBean = PerfilCsaHome.findByPrimaryKey(new PerfilCsaId(codigoEntidade, perCodigo));
        Boolean previousPerfilPadrao = pcaBean.getPcaPerfilPadrao();

        if (status != null) {
            pcaBean.setPcaAtivo(status);
        }

        if (isToChangePerfilPadrao(pcaPerfilPadrao, previousPerfilPadrao)) {

            pcaBean.setPcaPerfilPadrao(pcaPerfilPadrao);
            updateOthersPerfils(pcaPerfilPadrao, codigoEntidade, perCodigo);

        }

        AbstractEntityHome.update(pcaBean);
        logDelegate.addChangedField(Columns.PCA_ATIVO, status);
    }

    private boolean isToChangePerfilPadrao(Boolean pcaPerfilPadrao, Boolean previousPerfilPadrao) {
        return pcaPerfilPadrao != null && !pcaPerfilPadrao.equals(previousPerfilPadrao);
    }

    private void updateOthersPerfils(Boolean pcaPerfilPadrao, String codigoEntidade, String perCodigo) throws FindException, UpdateException {
        
        if (pcaPerfilPadrao != null && pcaPerfilPadrao) {

            List<PerfilCsa> perfilCsas = PerfilCsaHome.listByCsaCodigo(codigoEntidade);

            for (PerfilCsa perfilCsa : perfilCsas) {

                if (!perCodigo.equals(perfilCsa.getPerCodigo())) {
                    perfilCsa.setPcaPerfilPadrao(false);
                    PerfilCsaHome.update(perfilCsa);
                }

            }

        }


    }

    private void updatePcaSupBean(String codigoEntidade, String perCodigo, Short status, final LogDelegate logDelegate)
            throws FindException, UpdateException, LogControllerException {

        if (status != null) {
            final PerfilSup psuBean = PerfilSupHome.findByPrimaryKey(new PerfilSupId(codigoEntidade, perCodigo));
            psuBean.setPsuAtivo(status);
            AbstractEntityHome.update(psuBean);
            logDelegate.addChangedField(Columns.PSU_ATIVO, status);
        }
        
    }

    private void updatePcaCorBean(String codigoEntidade, String perCodigo, Short status, final LogDelegate logDelegate)
            throws FindException, UpdateException, LogControllerException {
        
        if (status != null) {
            final PerfilCor pcoBean = PerfilCorHome.findByPrimaryKey(new PerfilCorId(codigoEntidade, perCodigo));
            pcoBean.setPcoAtivo(status);
            AbstractEntityHome.update(pcoBean);
            logDelegate.addChangedField(Columns.PCO_ATIVO, status);
        }

    }

    private void updatePcaOrgBean(String codigoEntidade, String perCodigo, Short status, final LogDelegate logDelegate)
            throws FindException, UpdateException, LogControllerException {
        
        if (status != null) {
            final PerfilOrg porBean = PerfilOrgHome.findByPrimaryKey(new PerfilOrgId(codigoEntidade, perCodigo));
            porBean.setPorAtivo(status);
            AbstractEntityHome.update(porBean);
            logDelegate.addChangedField(Columns.POR_ATIVO, status);
        }

    }

    private void updatePcaCseBean(String codigoEntidade, String perCodigo, Short status, final LogDelegate logDelegate)
            throws FindException, UpdateException, LogControllerException {

        if (status != null) {
            final PerfilCse pceBean = PerfilCseHome.findByPrimaryKey(new PerfilCseId(codigoEntidade, perCodigo));
            pceBean.setPceAtivo(status);
            AbstractEntityHome.update(pceBean);
            logDelegate.addChangedField(Columns.PCE_ATIVO, status);
        }

    }

    private boolean updateFuncaoPerfil(String tipoEntidade, String codigoEntidade, String perCodigo, List<String> funcoes, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            // Altera as funções deste perfil
            if (funcoes != null) {
                final List<String> funcoesNovas = new ArrayList<>();
                final List<String> funcoesRemovidas = new ArrayList<>();

                FuncaoPerfil fperBean = null;

                // Navega nas funções antigas deste perfil
                final List<String> funcoesOld = getFuncaoPerfil(tipoEntidade, codigoEntidade, perCodigo, responsavel);

                // Funções permitidas para o usuário
                final List<String> funcoesPermitidas = new ArrayList<>();
                final List<TransferObject> funPermUsu = lstFuncoesPermitidasPerfil(tipoEntidade, codigoEntidade, responsavel);
                if ((funPermUsu != null) && !funPermUsu.isEmpty()) {
                    for (final TransferObject transferObject : funPermUsu) {
                        funcoesPermitidas.add(transferObject.getAttribute(Columns.FUN_CODIGO).toString());
                    }
                }

                if (funcoes != null) {
                    for (final String funPermitida : funcoesPermitidas) {
                        if (funcoesOld.contains(funPermitida) && !funcoes.contains(funPermitida)) {
                            fperBean = FuncaoPerfilHome.findByPrimaryKey(new FuncaoPerfilId(funPermitida, perCodigo));

                            // se a função a ser removida é a de usuário auditor, verifica se os usuários do perfil
                            // são os únicos auditores do sistema. caso sim, não é permitido remover esta permissão
                            if (CodedValues.FUN_USUARIO_AUDITOR.equals(funPermitida)) {
                                final ListaUsuariosAuditoresQuery lstAuditores = new ListaUsuariosAuditoresQuery();
                                final List<String> perCodigos = new ArrayList<>();
                                perCodigos.add(CodedValues.NOT_EQUAL_KEY);
                                perCodigos.add(perCodigo);
                                lstAuditores.perCodigo = perCodigos;
                                lstAuditores.codigoEntidade = codigoEntidade;
                                lstAuditores.tipo = tipoEntidade;
                                lstAuditores.count = true;

                                try {
                                    final int auditoresQntd = lstAuditores.executarContador();
                                    if (auditoresQntd <= 0) {
                                        final ListaFuncoesAuditadasQuery funcAuditadasEnt = new ListaFuncoesAuditadasQuery();
                                        funcAuditadasEnt.codigoEntidade = codigoEntidade;
                                        funcAuditadasEnt.tipo = tipoEntidade;
                                        funcAuditadasEnt.count = true;

                                        final int numFuncAuditadas = funcAuditadasEnt.executarContador();
                                        if (numFuncAuditadas > 0) {
                                            throw new UsuarioControllerException("mensagem.erro.permissao.auditoria.nao.pode.remover", responsavel);
                                        }
                                    }
                                } catch (final HQueryException e) {
                                    throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
                                }

                                AbstractEntityHome.remove(fperBean);
                                funcoesRemovidas.add(funPermitida);
                            } else {
                                AbstractEntityHome.remove(fperBean);
                                funcoesRemovidas.add(funPermitida);
                            }
                        } else if (funcoesOld.contains(funPermitida) && funcoes.contains(funPermitida)) {
                            // Usuário já possui a função, não precisa incluir
                            continue;
                        } else if (!funcoesOld.contains(funPermitida) && funcoes.contains(funPermitida)) {
                            funcoesNovas.add(funPermitida);
                        }
                    }
                }

                // todos os usuários do perfil devem ter e-mail cadastrado ao adicionar permissão de usuário auditor
                if (funcoesNovas.contains(CodedValues.FUN_USUARIO_AUDITOR)) {
                    final CustomTransferObject filtro = new CustomTransferObject();
                    filtro.setAttribute(Columns.PER_CODIGO, perCodigo);

                    final List<TransferObject> listUsuarios = lstUsuarios("0", tipoEntidade, codigoEntidade, filtro, responsavel);
                    if (!listUsuarios.isEmpty()) {
                        for (final TransferObject usuario : listUsuarios) {
                            if (TextHelper.isNull(usuario.getAttribute(Columns.USU_EMAIL))) {
                                throw new UsuarioControllerException("mensagem.erro.todos.usuarios.perfil.devem.possuir.email.valido.cadastrado.para.atribuir.permissao.auditor", responsavel);
                            }
                        }
                    }
                }

                // Insere as novas funções
                if (funcoesNovas.size() > 0) {
                    createFuncaoPerfil(funcoesNovas, perCodigo, responsavel);
                }

                // Grava log das funções removidas
                if ((funcoesRemovidas != null) && (funcoesRemovidas.size() > 0)) {
                    final LogDelegate log = new LogDelegate(responsavel, Log.FUNCAO_PERFIL, Log.DELETE, Log.LOG_INFORMACAO);
                    log.setPerfil(perCodigo);
                    for (final String funcaoRemovida : funcoesRemovidas) {
                        log.setFuncao(funcaoRemovida);
                        log.write();
                    }
                }

                // Insere ocorrência de inclusão ou alteração para o perfil
                String funcoesInseridas = "";
                String funcoesRetiradas = "";

                if ((funcoesNovas != null) && !funcoesNovas.isEmpty()) {
                    for (final String funcao : funcoesNovas) {
                        funcoesInseridas += funcao + ", ";
                    }
                }

                if ((funcoesRemovidas != null) && !funcoesRemovidas.isEmpty()) {
                    for (final String funcao : funcoesRemovidas) {
                        funcoesRetiradas += funcao + ", ";
                    }
                }

                if ((funcoesNovas != null) && !funcoesNovas.isEmpty() && ((funcoesOld == null) || funcoesOld.isEmpty())) {
                    criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.inclusao", responsavel, funcoesInseridas.substring(0, funcoesInseridas.length() - 2)), null, responsavel);
                } else if ((funcoesNovas != null) && !funcoesNovas.isEmpty() && ((funcoesRemovidas == null) || funcoesRemovidas.isEmpty())) {
                    criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.alteracao", responsavel, funcoesInseridas.substring(0, funcoesInseridas.length() - 2)), null, responsavel);
                } else if ((funcoesNovas != null) && !funcoesNovas.isEmpty() && (funcoesRemovidas != null) && !funcoesRemovidas.isEmpty()) {
                    criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.alteracao.remocao.inclusao", responsavel, funcoesInseridas.substring(0, funcoesInseridas.length() - 2), funcoesRetiradas.substring(0, funcoesRetiradas.length() - 2)), null, responsavel);
                } else if (((funcoesNovas == null) || funcoesNovas.isEmpty()) && (funcoesRemovidas != null) && !funcoesRemovidas.isEmpty()) {
                    criaOcorrenciaPerfil(perCodigo, CodedValues.TOC_ALTERA_PERFIL, ApplicationResourcesHelper.getMessage("mensagem.perfil.ocorrencia.remocao", responsavel, funcoesRetiradas.substring(0, funcoesRetiradas.length() - 2)), null, responsavel);
                }

                return ((funcoesNovas != null) && !funcoesNovas.isEmpty()) || ((funcoesRemovidas != null) && !funcoesRemovidas.isEmpty());
            }
            return false;
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, "");
        } catch (final RemoveException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.atualizar.este.perfil.erro.interno.arg0", responsavel, ex.getMessage());
        }
    }

    @Override
    public void removePerfil(String tipoEntidade, String codigoEntidade, String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if (usuarioPodeModificarPerfil(perCodigo, true, true, responsavel)) {
                final String papCodigo = UsuarioHelper.getPapCodigo(tipoEntidade);

                // verifica se este perfil tem usuários ligados a ele antes de remover
                final List<PerfilUsuario> usuarios = PerfilUsuarioHome.findByPerfil(perCodigo);
                if ((usuarios != null) && (usuarios.size() > 0)) {
                    throw new UsuarioControllerException("mensagem.erro.nao.possivel.remover.perfil.pois.existem.usuarios.associados", responsavel);
                }

                // Remove as funções deste perfil
                final List<FuncaoPerfil> funcoes = FuncaoPerfilHome.findByPerfil(perCodigo);
                for (final FuncaoPerfil fperBean : funcoes) {
                    AbstractEntityHome.remove(fperBean);
                }

                // Remove a associação do perfil com a entidade criadora
                if (CodedValues.PAP_CONSIGNANTE.equals(papCodigo)) { // CSE
                    final PerfilCse pceBean = PerfilCseHome.findByPrimaryKey(new PerfilCseId(codigoEntidade, perCodigo));
                    AbstractEntityHome.remove(pceBean);
                } else if (CodedValues.PAP_CONSIGNATARIA.equals(papCodigo)) { // CSA
                    final PerfilCsa pcaBean = PerfilCsaHome.findByPrimaryKey(new PerfilCsaId(codigoEntidade, perCodigo));
                    AbstractEntityHome.remove(pcaBean);
                } else if (CodedValues.PAP_ORGAO.equals(papCodigo)) { // ORG
                    final PerfilOrg porBean = PerfilOrgHome.findByPrimaryKey(new PerfilOrgId(codigoEntidade, perCodigo));
                    AbstractEntityHome.remove(porBean);
                } else if (CodedValues.PAP_CORRESPONDENTE.equals(papCodigo)) { // COR
                    final PerfilCor pcoBean = PerfilCorHome.findByPrimaryKey(new PerfilCorId(codigoEntidade, perCodigo));
                    AbstractEntityHome.remove(pcoBean);
                } else if (CodedValues.PAP_SUPORTE.equals(papCodigo)) { // SUP
                    final PerfilSup psuBean = PerfilSupHome.findByPrimaryKey(new PerfilSupId(codigoEntidade, perCodigo));
                    AbstractEntityHome.remove(psuBean);
                } else {
                    throw new UsuarioControllerException("mensagem.erro.arg0.tipo.entidade.invalido", responsavel, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
                }

                // Remove Ocorrências do perfil
                OcorrenciaPerfilHome.deleteTodasOcorrenciaPerfilSelecionado(perCodigo);

                // Remove o perfil
                final Perfil perBean = PerfilHome.findByPrimaryKey(perCodigo);
                AbstractEntityHome.remove(perBean);

                final LogDelegate logDelegate = new LogDelegate(responsavel, Log.PERFIL, Log.DELETE, Log.LOG_INFORMACAO);
                logDelegate.setPerfil(perCodigo);
                logDelegate.write();
            }
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, "");
        } catch (final RemoveException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.remover.este.perfil.erro.interno.arg0", responsavel, ex.getMessage());
        }
    }

    @Override
    public void copyPerfil(String tipoEntidade, String codigoEntidade, String perOrigem, List<String> perDestino, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if (TextHelper.isNull(perOrigem)) {
                throw new UsuarioControllerException("mensagem.erro.selecione.um.perfil.origem.de.onde.funcoes.serao.copiadas", responsavel);
            }
            if ((perDestino == null) || perDestino.isEmpty()) {
                throw new UsuarioControllerException("mensagem.erro.selecione.pelo.menos.um.perfil.destino.onde.funcoes.serao.aplicadas", responsavel);
            }

            // Recupera as funções que serão copiadas
            final List<String> funcoes = new ArrayList<>();
            final Collection<FuncaoPerfil> funcoesPerfil = FuncaoPerfilHome.findByPerfil(perOrigem);
            if ((funcoesPerfil != null) && !funcoesPerfil.isEmpty()) {
                for (final FuncaoPerfil funcaoPerfil : funcoesPerfil) {
                    funcoes.add(funcaoPerfil.getFunCodigo());
                }
            }

            for (final String perCodigoDestino : perDestino) {
                if (!perCodigoDestino.equals(perOrigem)) {
                    final Perfil perfilDestino = PerfilHome.findByPrimaryKey(perCodigoDestino);
                    Short status = null;
                    if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade)) {
                        final PerfilCse perfilEntidade = PerfilCseHome.findByPrimaryKey(new PerfilCseId(codigoEntidade, perCodigoDestino));
                        status = perfilEntidade.getPceAtivo();
                    } else if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade)) {
                        final PerfilCsa perfilEntidade = PerfilCsaHome.findByPrimaryKey(new PerfilCsaId(codigoEntidade, perCodigoDestino));
                        status = perfilEntidade.getPcaAtivo();
                    } else if (AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
                        final PerfilCor perfilEntidade = PerfilCorHome.findByPrimaryKey(new PerfilCorId(codigoEntidade, perCodigoDestino));
                        status = perfilEntidade.getPcoAtivo();
                    } else if (AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade)) {
                        final PerfilOrg perfilEntidade = PerfilOrgHome.findByPrimaryKey(new PerfilOrgId(codigoEntidade, perCodigoDestino));
                        status = perfilEntidade.getPorAtivo();
                    } else if (AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
                        final PerfilSup perfilEntidade = PerfilSupHome.findByPrimaryKey(new PerfilSupId(codigoEntidade, perCodigoDestino));
                        status = perfilEntidade.getPsuAtivo();
                    }
                    if (status.equals(CodedValues.STS_INDISP)) {
                        LOG.warn("Funções não foram copiadas para o perfil ['" + perCodigoDestino + "'] porque o perfil está excluído.");
                        continue;
                    }

                    // Altera as funções do perfil
                    updatePerfil(tipoEntidade, codigoEntidade, perCodigoDestino, perfilDestino.getPerDescricao(), perfilDestino.getPerVisivel(), perfilDestino.getPerDataExpiracao(), null, status, null, null, null, null, funcoes, responsavel);

                    // Gera o log de auditoria
                    final LogDelegate logDelegate = new LogDelegate(responsavel, Log.PERFIL, Log.UPDATE, Log.LOG_INFORMACAO);
                    logDelegate.setPerfil(perCodigoDestino);
                    logDelegate.setPerfilOrigem(perOrigem);
                    logDelegate.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.perfil.alterado.a.partir.funcoes.associadas.perfil.origem", responsavel));
                    logDelegate.write();
                }
            }
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.recuperar.informacoes.para.copia.funcoes.para.perfil", responsavel);
        }
    }

    private void createFuncaoPerfil(List<String> funCodigo, String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if ((funCodigo != null) && (funCodigo.size() > 0)) {
                for (final String funcao : funCodigo) {
                    if (CodedValues.FUNCOES_NAO_PERMITIDAS_PERFIL.contains(funcao)) {
                        throw new UsuarioControllerException("mensagem.erro.nao.permitida.associacao.funcao.arg0.perfil", responsavel, funcao);
                    }
                    FuncaoPerfilHome.create(funcao, perCodigo);
                }

                final LogDelegate log = new LogDelegate(responsavel, Log.FUNCAO_PERFIL, Log.CREATE, Log.LOG_INFORMACAO);
                log.setPerfil(perCodigo);
                for (final String funcao : funCodigo) {
                    log.setFuncao(funcao);
                    log.write();
                }
            }
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.associar.funcao.perfil.erro.interno.arg0", responsavel, ex.getMessage());
        }
    }

    @Override
    public CustomTransferObject getFuncao(String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemFuncaoQuery funQuery = new ObtemFuncaoQuery();
            funQuery.funCodigo = funCodigo;

            final List<TransferObject> lstFuncao = funQuery.executarDTO();
            if (!lstFuncao.isEmpty()) {
                return (CustomTransferObject) lstFuncao.get(0);
            }
            return null;
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public List<String> getFuncaoPerfil(String tipoEntidade, String codigoEntidade, String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaFuncoesPerfilQuery funPerQuery = new ListaFuncoesPerfilQuery();
            funPerQuery.perCodigo = perCodigo;
            funPerQuery.papCodigoDestino = UsuarioHelper.getPapCodigo(tipoEntidade);
            funPerQuery.papCodigoOrigem = UsuarioHelper.getPapCodigo(responsavel.getTipoEntidade());
            return funPerQuery.executarLista();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public List<TransferObject> lstPerfil(String tipoEntidade, String codigoEntidade, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaPerfilTipoEntidadeQuery lstPerTipoEntQuery = new ListaPerfilTipoEntidadeQuery();
            lstPerTipoEntQuery.tipoEntidade = tipoEntidade;
            lstPerTipoEntQuery.codigoEntidade = codigoEntidade;
            lstPerTipoEntQuery.pceAtivo = (Short) filtro.getAttribute(Columns.PCE_ATIVO);
            lstPerTipoEntQuery.pcaAtivo = (Short) filtro.getAttribute(Columns.PCA_ATIVO);
            lstPerTipoEntQuery.pcoAtivo = (Short) filtro.getAttribute(Columns.PCO_ATIVO);
            lstPerTipoEntQuery.porAtivo = (Short) filtro.getAttribute(Columns.POR_ATIVO);
            lstPerTipoEntQuery.psuAtivo = (Short) filtro.getAttribute(Columns.PSU_ATIVO);
            lstPerTipoEntQuery.perDescricao = (String) filtro.getAttribute(Columns.PER_DESCRICAO);
            lstPerTipoEntQuery.responsavel = responsavel;

            return lstPerTipoEntQuery.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public List<TransferObject> lstPerfilSemBloqueioRepasse(String tipoEntidade, String codigoEntidade, String usuCodigoEdt, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaPerfilSemBloqueioRepasseQuery perSemBloqRepQuery = new ListaPerfilSemBloqueioRepasseQuery();
            perSemBloqRepQuery.tipoEntidade = tipoEntidade;
            perSemBloqRepQuery.papCodigoDestino = UsuarioHelper.getPapCodigo(tipoEntidade);
            perSemBloqRepQuery.papCodigoOrigem = UsuarioHelper.getPapCodigo(responsavel.getTipoEntidade());
            perSemBloqRepQuery.usuCodigoEdt = usuCodigoEdt;
            perSemBloqRepQuery.codigoEntidade = codigoEntidade;
            perSemBloqRepQuery.responsavel = responsavel;

            return perSemBloqRepQuery.executarDTO();
        } catch (final HQueryException hex) {
            LOG.error(hex.getMessage(), hex);
            throw new UsuarioControllerException(hex);
        }
    }

    @Override
    public Short getStatusPerfil(String tipoEntidade, String codigoEntidade, String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final String papCodigo = UsuarioHelper.getPapCodigo(tipoEntidade);

            // Remove a associação do perfil com a entidade criadora
            if (CodedValues.PAP_CONSIGNANTE.equals(papCodigo)) { // CSE
                final PerfilCse pceBean = PerfilCseHome.findByPrimaryKey(new PerfilCseId(codigoEntidade, perCodigo));
                return pceBean.getPceAtivo();
            } else if (CodedValues.PAP_CONSIGNATARIA.equals(papCodigo)) { // CSA
                final PerfilCsa pcaBean = PerfilCsaHome.findByPrimaryKey(new PerfilCsaId(codigoEntidade, perCodigo));
                return pcaBean.getPcaAtivo();
            } else if (CodedValues.PAP_ORGAO.equals(papCodigo)) { // ORG
                final PerfilOrg porBean = PerfilOrgHome.findByPrimaryKey(new PerfilOrgId(codigoEntidade, perCodigo));
                return porBean.getPorAtivo();
            } else if (CodedValues.PAP_CORRESPONDENTE.equals(papCodigo)) { // COR
                final PerfilCor pcoBean = PerfilCorHome.findByPrimaryKey(new PerfilCorId(codigoEntidade, perCodigo));
                return pcoBean.getPcoAtivo();
            } else if (CodedValues.PAP_SUPORTE.equals(papCodigo)) { // SUP
                final PerfilSup psuBean = PerfilSupHome.findByPrimaryKey(new PerfilSupId(codigoEntidade, perCodigo));
                return psuBean.getPsuAtivo();
            } else if (CodedValues.PAP_SERVIDOR.equals(papCodigo)) { // SER
                return CodedValues.STS_ATIVO; // PerfilSer não existe, portanto considera o perfil ativo
            } else {
                throw new UsuarioControllerException("mensagem.erro.arg0.tipo.entidade.invalido", responsavel, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
            }
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, ex, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
        }
    }

    /**
     * Verifica se o usuário tem permissão para executar a função identificada pelo funCodigo.
     * ATENÇÃO: Não utilizar este método, a não ser que seja necessário verificar se um terceiro
     * usuário tenha permissão para realizar uma operação. Caso seja para verificar sobre o próprio
     * usuário, utilize a função AcessoSistema.temPermissao()
     * @param usuCodigo : código do usuário
     * @param funCodigo : código da função
     * @param tipoEntidade : CSE, CSA, ORG, COR ou SER, null para todos
     * @param responsavel : responsável pela verificaçãp
     * @return True se o usuário tem a permissão, falso caso contrário
     * @throws UsuarioControllerException
     */
    @Override
    public boolean usuarioTemPermissao(String usuCodigo, String funCodigo, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            // Grava Log de Acesso
            final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.FIND, Log.LOG_INFORMACAO);
            log.setUsuario(usuCodigo);
            log.setFuncao(funCodigo);
            log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.verificando.se.usuario.tem.permissao.para.funcao", responsavel));
            log.write();
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
        }

        // Faz a busca pelo perfil do usuário
        try {
            // busca as funções do perfil
            final PerfilUsuario upeBean = PerfilUsuarioHome.findByPrimaryKey(usuCodigo);
            final FuncaoPerfilId pk = new FuncaoPerfilId(funCodigo, upeBean.getPerfil().getPerCodigo());
            FuncaoPerfilHome.findByPrimaryKey(pk);
            LOG.debug("Usuario Com Perfil Com Permissão Para " + funCodigo + ".");
            return true;

        } catch (final FindException ex) {
            // Busca as funções p/ perfil personalizado

            if ((tipoEntidade == null) || AcessoSistema.ENTIDADE_COR.equalsIgnoreCase(tipoEntidade)) {
                try {
                    final List<FuncaoPerfilCor> perfil = FuncaoPerfilCorHome.findByUsuFunCodigo(usuCodigo, funCodigo);
                    if ((perfil != null) && (perfil.size() > 0)) {
                        return true;
                    }
                } catch (final FindException e) {
                    LOG.error(e.getMessage(), e);
                    throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, e, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
                }
            }

            if ((tipoEntidade == null) || AcessoSistema.ENTIDADE_CSA.equalsIgnoreCase(tipoEntidade)) {
                try {
                    final List<FuncaoPerfilCsa> perfil = FuncaoPerfilCsaHome.findByUsuFunCodigo(usuCodigo, funCodigo);
                    if ((perfil != null) && (perfil.size() > 0)) {
                        return true;
                    }
                } catch (final FindException e) {
                    LOG.error(e.getMessage(), e);
                    throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, e, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
                }
            }

            if ((tipoEntidade == null) || AcessoSistema.ENTIDADE_ORG.equalsIgnoreCase(tipoEntidade)) {
                try {
                    final List<FuncaoPerfilOrg> perfil = FuncaoPerfilOrgHome.findByUsuFunCodigo(usuCodigo, funCodigo);
                    if ((perfil != null) && (perfil.size() > 0)) {
                        return true;
                    }
                } catch (final FindException e) {
                    LOG.error(e.getMessage(), e);
                    throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, e, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
                }
            }

            if ((tipoEntidade == null) || AcessoSistema.ENTIDADE_CSE.equalsIgnoreCase(tipoEntidade)) {
                try {
                    final List<FuncaoPerfilCse> perfil = FuncaoPerfilCseHome.findByUsuFunCodigo(usuCodigo, funCodigo);
                    if ((perfil != null) && (perfil.size() > 0)) {
                        return true;
                    }
                } catch (final FindException e) {
                    LOG.error(e.getMessage(), e);
                    throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, e, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
                }
            }

            if ((tipoEntidade == null) || AcessoSistema.ENTIDADE_SUP.equalsIgnoreCase(tipoEntidade)) {
                try {
                    final List<FuncaoPerfilSup> perfil = FuncaoPerfilSupHome.findByUsuFunCodigo(usuCodigo, funCodigo);
                    if ((perfil != null) && (perfil.size() > 0)) {
                        return true;
                    }
                } catch (final FindException e) {
                    LOG.error(e.getMessage(), e);
                    throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, e, ApplicationResourcesHelper.getMessage(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel) + " ");
                }
            }
        }

        return false;
    }

    /**
     * Verifica se um usuário tem permissão de realizar operações no usuário
     * informada pelo parâmetro "usuCodigo",  de acordo com sua entidade.
     * @param usuCodigo : usuário que está sendo afetado
     * @param gravaLog : determina se será gravado log de erro, caso não tenha permissão
     * @param lancaExcecao : determina se será lançado uma exceção, caso não tenha permissão
     * @param responsavel : responsável pela operação de modificação do usuário
     * @return boolean
     * @throws AutorizacaoControllerException
     */
    private boolean usuarioPodeModificarUsu(String usuCodigo, boolean gravaLog, boolean lancaExcecao, AcessoSistema responsavel) throws UsuarioControllerException {
        final boolean podeModificar = entidadeUsuarioPodeModificarUsu(usuCodigo, responsavel);
        if (!podeModificar) {
            if (gravaLog) {
                try {
                    // Grava log de Erro
                    final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_ERRO_SEGURANCA);
                    log.setUsuario(usuCodigo);
                    log.add(ApplicationResourcesHelper.getMessage("rotulo.erro.upper.arg0", responsavel, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.tem.permissao.para.modificar.este.usuario", responsavel)));
                    log.write();
                } catch (final LogControllerException ex) {
                    LOG.error(ex.getMessage(), ex);
                    throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
                }
            }

            if (lancaExcecao) {
                throw new UsuarioControllerException("mensagem.erro.usuario.nao.tem.permissao.para.modificar.este.usuario", responsavel);
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * Retorna TRUE se o usuário, representado pelo parâmetro "responsavel", pertence a uma
     * entidade, seja CSE/ORG/SUP/CSA/COR/SER, que tenha permissão de realizar operações
     * sobre o usuário, representada pelo parâmetro "usuCodigo".
     * @param usuCodigo String
     * @param responsavel AcessoSistema
     * @return
     * @throws UsuarioControllerException
     */
    private boolean entidadeUsuarioPodeModificarUsu(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            boolean podeModificar = false;

            // DESENV-10480: correção da DESENV-9892 para sempre retornar true se houver o parâmetro de sistema de autodesbloqueio e for a respectiva ação do tipo de usuário correspondente
            if (responsavel.getUsuCodigo().equals(usuCodigo) && (
                    (ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_CSE_ORG, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema()) && !TextHelper.isNull(responsavel.getFunCodigo()) && CodedValues.FUN_AUTODESBLOQUEIO_CSE_ORG.equals(responsavel.getFunCodigo())) ||
                    (ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_CSA, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema()) && !TextHelper.isNull(responsavel.getFunCodigo()) && CodedValues.FUN_AUTODESBLOQUEIO_CSA_COR.equals(responsavel.getFunCodigo())) ||
                    (ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_COR, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema()) && !TextHelper.isNull(responsavel.getFunCodigo()) && CodedValues.FUN_AUTODESBLOQUEIO_CSA_COR.equals(responsavel.getFunCodigo())) ||
                    (ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_SUP, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema()) && !TextHelper.isNull(responsavel.getFunCodigo()) && CodedValues.FUN_AUTODESBLOQUEIO_SUP.equals(responsavel.getFunCodigo())))) {

                return true;
            } else if (!TextHelper.isNull(responsavel.getFunCodigo()) && (
                    CodedValues.FUN_AUTODESBLOQUEIO_CSE_ORG.equals(responsavel.getFunCodigo()) ||
                    CodedValues.FUN_AUTODESBLOQUEIO_CSA_COR.equals(responsavel.getFunCodigo()) ||
                    CodedValues.FUN_AUTODESBLOQUEIO_SUP.equals(responsavel.getFunCodigo()))) {
                // é ação de desbloqueio, porém não tem o respectivo parâmetro de sistema como S.
                return false;
            }

            if (responsavel.isSistema() || responsavel.isSup()) {
                // O sistema e usuários de suporte, podem modificar quaisquer usuários
                podeModificar = true;

            } else if (responsavel.isCse()) {
                // Usuário de gestor pode modificar quaisquer usuários exceto os de suporte
                final UsuarioCsePodeModificarUsuQuery query = new UsuarioCsePodeModificarUsuQuery();
                query.usuCodigoAfetado = usuCodigo;
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isOrg() && responsavel.temPermissao(CodedValues.FUN_ACE_CONSIG_ESTABELECIMENTO)) {
                // Usuário de "estabelecimento" pode modificar apenas usuários do próprio órgão, usuários servidores
                // dos órgãos do mesmo estabelecimento e usuários de consignatárias
                final UsuarioEstPodeModificarUsuQuery query = new UsuarioEstPodeModificarUsuQuery();
                query.usuCodigoAfetado = usuCodigo;
                query.usuCodigoResponsavel = responsavel.getUsuCodigo();
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isOrg() && !responsavel.temPermissao(CodedValues.FUN_ACE_CONSIG_ESTABELECIMENTO)) {
                // Usuário de órgão pode modificar apenas usuários do próprio órgão, usuários servidores
                // do próprio órgão e usuários de consignatárias
                final UsuarioOrgPodeModificarUsuQuery query = new UsuarioOrgPodeModificarUsuQuery();
                query.usuCodigoAfetado = usuCodigo;
                query.usuCodigoResponsavel = responsavel.getUsuCodigo();
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isCsa()) {
                // Usuário de consignatária pode modificar usuários da próprio consignatária e de seus correspondentes
                final UsuarioCsaPodeModificarUsuQuery query = new UsuarioCsaPodeModificarUsuQuery();
                query.usuCodigoAfetado = usuCodigo;
                query.usuCodigoResponsavel = responsavel.getUsuCodigo();
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isCor()) {
                // Usuário de correspondente pode modificar apenas usuários do próprio correspondente
                final UsuarioCorPodeModificarUsuQuery query = new UsuarioCorPodeModificarUsuQuery();
                query.usuCodigoAfetado = usuCodigo;
                query.usuCodigoResponsavel = responsavel.getUsuCodigo();
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isSer()) {
                if (ParamSist.paramEquals(CodedValues.TPC_ALTERA_SENHA_TODOS_LOGINS_SERVIDOR, CodedValues.TPC_SIM, responsavel) ||
                        (ParamSist.paramEquals(CodedValues.TPC_RECUPERACAO_SENHA_USU_SERVIDOR_CPF, CodedValues.TPC_SIM, responsavel))) {
                    final Usuario usuarioSer = UsuarioHome.findByPrimaryKey(usuCodigo);
                    final Servidor responsavelServidor = ServidorHome.findByUsuCodigo(responsavel.getUsuCodigo());

                    // Usuário servidor pode modificar outros usuários servidores com o mesmo cpf
                    podeModificar = responsavelServidor.getSerCpf().equals(usuarioSer.getUsuCpf());
                } else {
                    // Usuário servidor pode modificar apenas seu próprio usuário
                    podeModificar = responsavel.getUsuCodigo().equals(usuCodigo);
                }
            }

            return podeModificar;
        } catch (HQueryException | FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /**
     * Verifica se um usuário tem permissão de realizar operações no perfil
     * informada pelo parâmetro "perCodigo",  de acordo com sua entidade.
     * @param perCodigo : perfil que está sendo afetado
     * @param gravaLog : determina se será gravado log de erro, caso não tenha permissão
     * @param lancaExcecao : determina se será lançado uma exceção, caso não tenha permissão
     * @param responsavel : responsável pela operação de modificação do perfil
     * @return boolean
     * @throws AutorizacaoControllerException
     */
    private boolean usuarioPodeModificarPerfil(String perCodigo, boolean gravaLog, boolean lancaExcecao, AcessoSistema responsavel) throws UsuarioControllerException {
        final boolean podeModificar = entidadeUsuarioPodeModificarPerfil(perCodigo, responsavel);
        if (!podeModificar) {
            if (gravaLog) {
                try {
                    // Grava log de Erro
                    final LogDelegate log = new LogDelegate(responsavel, Log.PERFIL, Log.UPDATE, Log.LOG_ERRO_SEGURANCA);
                    log.setPerfil(perCodigo);
                    log.add(ApplicationResourcesHelper.getMessage("rotulo.erro.upper.arg0", responsavel, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.tem.permissao.para.modificar.este.perfil", responsavel)));
                    log.write();
                } catch (final LogControllerException ex) {
                    LOG.error(ex.getMessage(), ex);
                    throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
                }
            }

            if (lancaExcecao) {
                throw new UsuarioControllerException("mensagem.erro.usuario.nao.tem.permissao.para.modificar.este.perfil", responsavel);
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * Retorna TRUE se o usuário, representado pelo parâmetro "responsavel", pertence a uma
     * entidade, seja CSE/ORG/SUP/CSA/COR/SER, que tenha permissão de realizar operações
     * sobre o perfil, representada pelo parâmetro "perCodigo".
     * @param usuCodigo String
     * @param responsavel AcessoSistema
     * @return
     * @throws UsuarioControllerException
     */
    private boolean entidadeUsuarioPodeModificarPerfil(String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            boolean podeModificar = false;

            if (responsavel.isSistema() || responsavel.isCse() || responsavel.isSup()) {
                // O sistema, usuários de gestor ou suporte, podem modificar quaisquer usuários
                podeModificar = true;

            } else if (responsavel.isOrg()) {
                // Usuário de órgão pode modificar apenas perfil do próprio órgão e perfil de consignatárias
                final UsuarioOrgPodeModificarPerfilQuery query = new UsuarioOrgPodeModificarPerfilQuery();
                query.perCodigoAfetado = perCodigo;
                query.usuCodigoResponsavel = responsavel.getUsuCodigo();
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isCsa()) {
                // Usuário de consignatária pode modificar usuários da próprio consignatária e de seus correspondentes
                final UsuarioCsaPodeModificarPerfilQuery query = new UsuarioCsaPodeModificarPerfilQuery();
                query.perCodigoAfetado = perCodigo;
                query.usuCodigoResponsavel = responsavel.getUsuCodigo();
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isCor()) {
                // Usuário de correspondente pode modificar apenas usuários do próprio correspondente
                final UsuarioCorPodeModificarPerfilQuery query = new UsuarioCorPodeModificarPerfilQuery();
                query.perCodigoAfetado = perCodigo;
                query.usuCodigoResponsavel = responsavel.getUsuCodigo();
                final List<?> result = query.executarLista();
                podeModificar = (result != null) && (result.size() > 0);

            } else if (responsavel.isSer()) {
                // Usuário servidor não pode modificar nenhum perfil
                podeModificar = false;
            }

            return podeModificar;
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /** SENHA DE SERVIDOR ------------------------------------------------------------------------------------- **/

    @Override
    public TransferObject getSenhaServidor(String rseCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemSenhaServidorQuery query = new ObtemSenhaServidorQuery();
            query.rseCodigo = rseCodigo;

            final List<TransferObject> usuarios = query.executarDTO();

            if (usuarios.size() == 0) {
                return null;
            }
            return usuarios.get(0);
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /** OCORRÊNCIA DE USUÁRIO --------------------------------------------------------------------------------- **/

    @Override
    public String createOcorrenciaUsuario(CustomTransferObject ocorrencia, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final OcorrenciaUsuario ocoUsuarioBean = OcorrenciaUsuarioHome.create(ocorrencia.getAttribute(Columns.OUS_TOC_CODIGO).toString(), (String) ocorrencia.getAttribute(Columns.OUS_USU_CODIGO), DateHelper.getSystemDatetime(), (String) ocorrencia.getAttribute(Columns.OUS_OBS), (String) ocorrencia.getAttribute(Columns.OUS_OUS_USU_CODIGO), (String) ocorrencia.getAttribute(Columns.OUS_IP_ACESSO), (String) ocorrencia.getAttribute(Columns.OUS_TMO_CODIGO));

            return ocoUsuarioBean.getOusCodigo();

        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.criar.ocorrencia.para.este.usuario.erro.interno.arg0", responsavel, ex.getMessage());
        }
    }

    @Override
    public List<TransferObject> lstOcorrenciaUsuario(CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaOcorrenciaUsuarioQuery query = new ListaOcorrenciaUsuarioQuery();
            if (offset != -1) {
                query.firstResult = offset;
            }
            if (count != -1) {
                query.maxResults = count;
            }
            if (filtro != null) {
                query.ousUsuCodigo = (String) filtro.getAttribute(Columns.OUS_USU_CODIGO);
                query.tocCodigos = (List<String>) filtro.getAttribute("tocCodigos");
            }
            return query.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public int countOcorrenciaUsuario(CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaOcorrenciaUsuarioQuery query = new ListaOcorrenciaUsuarioQuery();
            query.count = true;
            if (filtro != null) {
                query.ousUsuCodigo = (String) filtro.getAttribute(Columns.OUS_USU_CODIGO);
                query.tocCodigos = (List<String>) filtro.getAttribute("tocCodigos");
            }
            return query.executarContador();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /**
     * Verifica se um usuário é usuário de órgão
     * @param usuCodigo : código do usuário
     * @return O código do órgão, caso o usuário seja de órgão, ou nulo caso contrário
     * @throws UsuarioControllerException
     */
    @Override
    public String isOrg(String usuCodigo) throws UsuarioControllerException {
        try {
            final UsuarioOrg usuBean = UsuarioOrgHome.findByUsuCodigo(usuCodigo);
            return usuBean.getOrgao().getOrgCodigo();
        } catch (final FindException ex) {
            LOG.error(ex.getMessage());
            return null;
        }
    }

    /**
     * Cadastra chave para validação TOTP e associa ao usuário responsável
     * @param usuChaveValidacaoTotp
     * @param operacoesValidacaoTotp
     * @param permiteValidacaoTotp
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public String cadastrarChaveValidacaoTotp(String usuChaveValidacaoTotp, OperacaoValidacaoTotpEnum operacoesValidacaoTotp, PermiteValidacaoTotpEnum permiteValidacaoTotp, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if (permiteValidacaoTotp == null || permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.DESABILITADO)) {
                throw new UsuarioControllerException("mensagem.usoIncorretoSistema", responsavel);
            }

            final UsuarioTransferObject usuario = findUsuario(new UsuarioTransferObject(responsavel.getUsuCodigo()), AcessoSistema.ENTIDADE_USU, responsavel);
            usuario.setUsuChaveValidacaoTotp(usuChaveValidacaoTotp);
            usuario.setUsuOperacoesValidacaoTotp(operacoesValidacaoTotp.getCodigo());
            usuario.setUsuPermiteValidacaoTotp(permiteValidacaoTotp.getCodigo());

            if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) || permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS)) {
                // Apaga o OTP usado para cadastrar a chave
                usuario.setUsuOtpCodigo(null);
                usuario.setUsuOtpDataCadastro(null);
            }
            
            updateUsuario(usuario, null, responsavel);

            final LogDelegate logDelegate = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_INFORMACAO);
            logDelegate.setUsuario(responsavel.getUsuCodigo());
            logDelegate.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.cadastro.chave.validacao.totp", responsavel));
            logDelegate.write();

            return usuChaveValidacaoTotp;
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    /**
     * Gera chave para validação TOTP e associa ao usuário responsável
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public void removerChaveValidacaoTotp(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final UsuarioTransferObject usuario = findUsuario(new UsuarioTransferObject(responsavel.getUsuCodigo()), AcessoSistema.ENTIDADE_USU, responsavel);
            final PermiteValidacaoTotpEnum permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(usuario.getUsuPermiteValidacaoTotp())).orElse(PermiteValidacaoTotpEnum.DESABILITADO);
            if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.DESABILITADO)) {
                throw new UsuarioControllerException("mensagem.usoIncorretoSistema", responsavel);
            }

            usuario.setUsuChaveValidacaoTotp(null);
            usuario.setUsuPermiteValidacaoTotp(PermiteValidacaoTotpEnum.DESABILITADO.getCodigo());

            if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) || permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS)) {
                // Apaga o OTP usado para cadastrar a chave
                usuario.setUsuOtpCodigo(null);
                usuario.setUsuOtpDataCadastro(null);
            }

            updateUsuario(usuario, null, responsavel);

            final LogDelegate logDelegate = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_INFORMACAO);
            logDelegate.setUsuario(responsavel.getUsuCodigo());
            logDelegate.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.remocao.chave.validacao.totp", responsavel));
            logDelegate.write();

        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public void alterarSenha(String usuCodigo, String senhaNova, String dicaSenha, boolean expiracaoImediata, boolean reiniciacao, boolean senhaCriptografada, String senhaAtualAberta, AcessoSistema responsavel) throws UsuarioControllerException {
        alterarSenha(usuCodigo, senhaNova, dicaSenha, expiracaoImediata, reiniciacao, senhaCriptografada, null, senhaAtualAberta, responsavel);
    }

    /**
     * Altera a senha do usuário.
     * @param usuCodigo
     * @param senhaNova
     * @param dicaSenha
     * @param responsavel
     * @param expiracaoImediata Indica se a senha deve expirar imediatamente,
     *        ou se o prazo de validade deve ser determinado pelo parâmetro de sistema.
     * @param reiniciacao Indica se a alteração é por motivo de reiniciação de senha.
     * @param tipoMotivoOperacao Indo o motivo da operação que será gravado junto com a ocorrência
     * @throws UsuarioControllerException
     */
    @Override
    public void alterarSenha(String usuCodigo, String senhaNova, String dicaSenha, boolean expiracaoImediata, boolean reiniciacao, boolean senhaCriptografada, CustomTransferObject tipoMotivoOperacao, String senhaAtualAberta, AcessoSistema responsavel) throws UsuarioControllerException {
        this.alterarSenha(usuCodigo, senhaNova, null, dicaSenha, expiracaoImediata, reiniciacao, false, senhaCriptografada, null, tipoMotivoOperacao, false, false, senhaAtualAberta, responsavel);
    }

    /**
     * Altera a senha do usuário.
     * @param usuCodigo : Código do usuário.
     * @param senhaNova : Nova senha (O flag senhaCriptografada determina se está ou não criptografada).
     * @param senhaUtilizada : Senha utilizada e que será removida. (O flag senhaCriptografada determina se está ou não criptografada).
     * @param dicaSenha : Dica da senha, se houver.
     * @param expiracaoImediata : Indica se a senha expira imediatamente.
     * @param reiniciacao : Indica se trata-se de reiniciação.
     * @param senhaAutorizacaoServidor : Informa se a senha sendo alterada é a de autorização do servidor.
     * @param senhaCriptografada : especifica se a senha passada pelo param 'senhaNova' já está criptografada ou não.
     * @param tocCodigo : Tipo de ocorrência ser gravada.
     * @param tipoMotivoOperacao : Dados do motivo da operação.
     * @param responsavel : Responsável.
     * @throws UsuarioControllerException
     */
    private void alterarSenha(String usuCodigo, String senhaNova, String senhaUtilizada, String dicaSenha, boolean expiracaoImediata, boolean reiniciacao, boolean senhaAutorizacaoServidor, boolean senhaCriptografada, String tocCodigo, CustomTransferObject tipoMotivoOperacao, AcessoSistema responsavel) throws UsuarioControllerException {
        this.alterarSenha(usuCodigo, senhaNova, senhaUtilizada, dicaSenha, expiracaoImediata, reiniciacao, senhaAutorizacaoServidor, senhaCriptografada, tocCodigo, tipoMotivoOperacao, false, false, null, responsavel);
    }

    /**
     * Altera a senha do usuário, seja por uma alteração manual, reinicialização,
     * consumo ou cancelamento de senha de autorização.
     * @param usuCodigo : Código do usuário.
     * @param senhaNova : Nova senha (O flag senhaCriptografada determina se está ou não criptografada).
     * @param senhaUtilizada : Senha utilizada e que será removida. (O flag senhaCriptografada determina se está ou não criptografada).
     * @param dicaSenha : Dica da senha, se houver.
     * @param expiracaoImediata : Indica se a senha expira imediatamente.
     * @param reiniciacao : Indica se trata-se de reiniciação.
     * @param senhaAutorizacaoServidor : Informa se a senha sendo alterada é a de autorização do servidor.
     * @param senhaCriptografada : especifica se a senha passada pelo param 'senhaNova' já está criptografada ou não.
     * @param tocCodigo : Tipo de ocorrência ser gravada.
     * @param tipoMotivoOperacao : Dados do motivo da operação.
     * @param naoComunicarServidor : Não enviar email para o servidor com a nova senha
     * @param senhaAtualAberta : Senha atual do usuário aberta para ser validada antes da alteração da senha atual.
     * @param responsavel : Responsável.
     * @throws UsuarioControllerException
     */
    private void alterarSenha(String usuCodigo, String senhaNova, String senhaUtilizada, String dicaSenha, boolean expiracaoImediata, boolean reiniciacao, boolean senhaAutorizacaoServidor, boolean senhaCriptografada, String tocCodigo, CustomTransferObject tipoMotivoOperacao, boolean naoComunicarServidor, boolean senhaApp, String senhaAtualAberta, AcessoSistema responsavel) throws UsuarioControllerException {
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        boolean usuarioSer = false;

        try {
            // Tenta buscar por um usuario servidor.
            usuario = this.findUsuario(usuario, AcessoSistema.ENTIDADE_SER, responsavel);
            usuarioSer = true;
        } catch (final UsuarioControllerException ex) {
            if (senhaAutorizacaoServidor) {
                throw new UsuarioControllerException("mensagem.erro.usuario.nao.servidor", responsavel);
            }

            // Se não foi possível localizar um usuário servidor, trata-se de outro tipo de usuário.
            usuario = this.findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);
            usuarioSer = false;
        }

        // Se autenticação foi realizada pelo SSO e o usuário está alterando a sua própria senha, alteração de senha deve ser no SSO também
        final boolean autenticacaoSSO = UsuarioHelper.usuarioAutenticaSso(findTipoUsuarioByCodigo(usuCodigo, responsavel), responsavel);

        // Se é usuário servidor e utiliza senha de autorização, verifica se o parâmetro de múltiplas senhas
        // está habilitado, pois neste caso as senhas estarão armazenadas na tabela tb_senha_autorizacao_servidor,
        // e não na tb_usuario.usu_senha_2.
        final boolean usaMultiplasSenhasAut = usuarioSer && senhaAutorizacaoServidor && ParamSist.paramEquals(CodedValues.TPC_USA_MULTIPLAS_SENHAS_AUTORIZACAO_SERVIDOR, CodedValues.TPC_SIM, responsavel);

        if (!senhaAutorizacaoServidor && !reiniciacao) {
            SenhaHelper.validarForcaSenha(senhaNova, usuarioSer, responsavel);
        }

        // Criptografa a nova senha para armazenamento no banco.
        String senhaNovaCrypt = null;
        if (senhaNova != null) {
            if (!senhaCriptografada) {
                senhaNovaCrypt = SenhaHelper.criptografarSenha(usuario.getUsuLogin(), senhaNova, usuarioSer, responsavel);
            } else {
                senhaNovaCrypt = senhaNova;
            }
        }
        // Criptografa a senha utilizada para ser cancelada/consumida. Para SaltedMD5, a senha deve chegar aqui criptografada
        String senhaUtilizadaCrypt = null;
        if (usaMultiplasSenhasAut && (senhaUtilizada != null)) {
            if (!senhaCriptografada) {
                senhaUtilizadaCrypt = SenhaHelper.criptografarSenha(usuario.getUsuLogin(), senhaUtilizada, usuarioSer, responsavel);
            } else {
                senhaUtilizadaCrypt = senhaUtilizada;
            }
        }

        if (!reiniciacao) {
            // O padrão é não permitir senhas de consulta e autorização iguais.
            if (usuarioSer && (senhaNovaCrypt != null) && !ParamSist.paramEquals(CodedValues.TPC_PERMITE_SENHAS_SERVIDOR_IGUAIS, CodedValues.TPC_SIM, responsavel)) {
                if (senhaAutorizacaoServidor) {
                    // Se está alterando a senha de autorização, testa o valor da senha de consulta.
                    if (JCrypt.verificaSenha(senhaNova, usuario.getUsuSenha())) {
                        throw new UsuarioControllerException("mensagem.erro.senha.servidor.autorizacao.deve.ser.diferente.de.senha.servidor.consulta", responsavel);
                    }
                } else // Se não está alterando a senha de autorização, verifica se o sistema trabalha com ela. Caso positivo, compara seu valor.
                if (ParamSist.paramEquals(CodedValues.TPC_USA_SENHA_AUTORIZACAO_DESC_SERVIDOR, CodedValues.TPC_SIM, responsavel) && JCrypt.verificaSenha(senhaNova, usuario.getUsuSenha2())) {
                    throw new UsuarioControllerException("mensagem.erro.senha.servidor.autorizacao.deve.ser.diferente.de.senha.servidor.consulta", responsavel);
                }
            }

            // Verifica a senha com relação às anteriores
            validaSenhasAnteriores(usuCodigo, senhaNova, senhaNovaCrypt, senhaAutorizacaoServidor, responsavel);
        }

        try {
            // Calcula a data de expiração da senha.
            Calendar dataExpiracaoSenhaCalc = null;
            if (senhaNova != null) {
                if (!expiracaoImediata) {
                    dataExpiracaoSenhaCalc = calculaDataExpiracaoSenha(senhaAutorizacaoServidor, usuario, usuarioSer, responsavel);
                } else {
                    dataExpiracaoSenhaCalc = Calendar.getInstance();
                }
            }
            // Recupera a data de expiração apenas com a parte da data (SQL Date)
            final java.sql.Date dataExpiracaoSenha = dataExpiracaoSenhaCalc != null ? new java.sql.Date(dataExpiracaoSenhaCalc.getTimeInMillis()) : null;

            // Salva a alteração de senha.
            if (!reiniciacao && (dicaSenha != null) && !senhaAutorizacaoServidor) {
                usuario.setUsuDicaSenha(dicaSenha);
            }

            if (!senhaAutorizacaoServidor) {
                if (senhaNovaCrypt != null) {
                    if (senhaApp) {
                        usuario.setUsuSenhaApp(senhaNovaCrypt);
                    } else {
                        usuario.setUsuSenha(senhaNovaCrypt);
                    }
                } else {
                    usuario.setUsuSenha(CodedValues.USU_SENHA_SERVIDOR_CANCELADA);
                }
                if (senhaApp) {
                    usuario.setUsuDataExpSenhaApp(dataExpiracaoSenha);
                } else {
                    usuario.setUsuDataExpSenha(dataExpiracaoSenha);
                }

            } else {
                // Se nova senha de autorização foi definida, verifica o parâmetro com a quantidade
                // de operações permitidas para a nova senha 2: Default 1 (uma operação).
                final String paramQtdOperacoes = (String) ParamSist.getInstance().getParam(CodedValues.TPC_QTD_OPERACOES_VALIDADE_SENHA_AUTORIZACAO, responsavel);
                final Short qtdOperacoes = !TextHelper.isNull(paramQtdOperacoes) ? Short.valueOf(paramQtdOperacoes) : Short.valueOf("1");

                // Se usa múltiplas senhas, grava a nova na tabela apropriada
                if (usaMultiplasSenhasAut) {
                    if (senhaNovaCrypt != null) {
                        // Gerando senha múltipla de autorização
                        try {
                            SenhaAutorizacaoServidorHome.create(usuCodigo, senhaNovaCrypt, dataExpiracaoSenha, qtdOperacoes);
                        } catch (final CreateException ex) {
                            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                            throw new UsuarioControllerException("mensagem.erro.interno.criacao.nova.senha.autorizacao.usuario", responsavel, ex);
                        }
                    } else {
                        // Cancelando/Consumindo senha múltipla de autorização
                        try {
                            final SenhaAutorizacaoServidor sas = SenhaAutorizacaoServidorHome.findPrimeiroByUsuarioSenha(usuCodigo, senhaUtilizadaCrypt);
                            AbstractEntityHome.remove(sas);
                        } catch (final FindException ex) {
                            throw new UsuarioControllerException("mensagem.erro.nao.possivel.localizar.senha.autorizacao.para.executar.operacao", responsavel, ex);
                        } catch (final RemoveException ex) {
                            throw new UsuarioControllerException("mensagem.erro.interno.consumir.cancelar.senha.autorizacao.para.usuario", responsavel, ex);
                        }
                    }
                } else {
                    usuario.setUsuSenha2(senhaNovaCrypt);
                    usuario.setUsuDataExpSenha2(dataExpiracaoSenha);
                    if (senhaNovaCrypt != null) {
                        usuario.setUsuOperacoesSenha2(qtdOperacoes);
                    } else {
                        usuario.setUsuOperacoesSenha2(Short.valueOf("0"));
                    }
                }
            }

            // Determina parâmetros da ocorrência de usuário a ser gravada.
            String tocCodigoOcorrencia = null;
            String ousObs = null;
            if (!senhaAutorizacaoServidor) {
                if (tocCodigo != null) {
                    tocCodigoOcorrencia = tocCodigo;
                } else {
                    tocCodigoOcorrencia = CodedValues.TOC_ALTERACAO_SENHA_USUARIO;
                }

                if (CodedValues.TOC_CANCELAMENTO_SENHA_NAO_UTILIZADA.equals(tocCodigoOcorrencia)) {
                    ousObs = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.cancelamento.senha.nao.utilizada", responsavel);
                } else {
                    ousObs = ApplicationResourcesHelper.getMessage(reiniciacao ? "mensagem.ocorrencia.ous.obs.reinicializacao.senha.usuario" : "mensagem.ocorrencia.ous.obs.alteracao.senha.usuario", responsavel);
                }
            } else {
                if (tocCodigo != null) {
                    tocCodigoOcorrencia = tocCodigo;
                } else {
                    tocCodigoOcorrencia = CodedValues.TOC_ALTERACAO_SENHA_AUTORIZACAO;
                }

                if (CodedValues.TOC_UTILIZACAO_SENHA_AUTORIZACAO.equals(tocCodigoOcorrencia)) {
                    ousObs = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.utilizacao.senha.autorizacao", responsavel);
                } else if (CodedValues.TOC_CANCELAMENTO_SENHA_NAO_UTILIZADA.equals(tocCodigoOcorrencia)) {
                    ousObs = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.cancelamento.senha.2.nao.utilizada", responsavel);
                } else if (CodedValues.TOC_ALTERACAO_SENHA_AUTORIZACAO_TOTEM.equals(tocCodigoOcorrencia)) {
                    ousObs = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.senha.autorizacao.host.a.host", responsavel);
                } else {
                    ousObs = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.senha.autorizacao", responsavel);
                }
            }

            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setUsuCodigo(usuCodigo);
            ocorrencia.setTocCodigo(tocCodigoOcorrencia);
            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setOusObs(ousObs);
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
            if (tipoMotivoOperacao != null) {
                ocorrencia.setOusObs(ocorrencia.getOusObs() + (ocorrencia.getOusObs().lastIndexOf(".") == (ocorrencia.getOusObs().length() - 1) ? " " : ". ") + tipoMotivoOperacao.getAttribute(Columns.OUS_OBS));
                ocorrencia.setAttribute(Columns.OUS_TMO_CODIGO, tipoMotivoOperacao.getAttribute(Columns.TMO_CODIGO));
            }
            if (senhaAutorizacaoServidor && CodedValues.TOC_UTILIZACAO_SENHA_AUTORIZACAO.equals(tocCodigo)) {
                ocorrencia.setUtilizacaoSenhaAutServidor(true);
            }

            // Altera usuário com ocorrência e log
            updateUsuario(usuario, ocorrencia, responsavel);

            // Caso autenticação seja no SSO, altera no SSO também
            if (autenticacaoSSO && !atualizaSenhaSSO(usuario, senhaNova, senhaAtualAberta, responsavel)) {
                LOG.error("Erro ao atualizar senha do usuário no SSO.");
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException("mensagem.erro.alterar.senha.usuario", responsavel);
            }

            if (!senhaAutorizacaoServidor && usuarioSer && ParamSist.paramEquals(CodedValues.TPC_ALTERA_SENHA_TODOS_LOGINS_SERVIDOR, CodedValues.TPC_SIM, responsavel)) {
                //Replica a senha para todos o logins do servidor.
                matriculasUsuariosServidores(usuCodigo, senhaNovaCrypt, true, responsavel);
            }

            // Se for um usuário servidor.
            if (usuarioSer) {
                final String login = usuario.getUsuLogin();
                final int primeiroSeparador = login.indexOf('-');
                final int segundoSeparador = login.indexOf('-', primeiroSeparador + 1);

                final String estabelecimento = login.substring(0, primeiroSeparador > 0 ? primeiroSeparador : 0);
                final String matricula = login.substring((ParamSist.paramEquals(CodedValues.TPC_LOGIN_USU_SERVIDOR_COM_EST_ORG_ID, CodedValues.TPC_SIM, responsavel) ? segundoSeparador : primeiroSeparador) + 1, login.length());

                // Verifica parâmetros de sistema que informam se há senha externa e se deve ser atualizada.
                if (!senhaAutorizacaoServidor && ParamSist.paramEquals(CodedValues.TPC_SENHA_EXTERNA, CodedValues.TPC_SIM, responsavel) && ParamSist.paramEquals(CodedValues.TPC_ATUALIZA_SENHA_EXTERNA, CodedValues.TPC_SIM, responsavel)) {
                    // Se existir, reinicia a senha externa do servidor.
                    try {
                        final String[] parametros = { senhaNovaCrypt != null ? senhaNovaCrypt : CodedValues.USU_SENHA_SERVIDOR_CANCELADA, estabelecimento, matricula };
                        SenhaExterna.getInstance().atualizarSenha(parametros);
                    } catch (final UsuarioControllerException ex) {
                        LOG.error("Erro ao atualizar senha externa do servidor", ex);
                        throw new UsuarioControllerException("mensagem.erro.atualizar.senha.externa.servidor", responsavel, ex);
                    }
                }

                // Verifica se a alteração de senha deve ser comunicada.
                if ((senhaNova != null) && !naoComunicarServidor) {
                    if ((!senhaAutorizacaoServidor && ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_USUARIO_SER, CodedValues.TPC_SIM, responsavel) && (!reiniciacao || !ParamSist.paramEquals(CodedValues.TPC_EMAIL_REINICIALIZACAO_SENHA, CodedValues.TPC_SIM, responsavel))) ||
                        (senhaAutorizacaoServidor && (ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_ENVIA_EMAIL, responsavel) || ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_EMAIL_OU_TELA, responsavel) || ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_SMS, responsavel) ||
                                                      ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_SMS_E_EMAIL, responsavel) || ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_EMAIL_E_TELA, responsavel)))) {
                        try {
                            comunicaAlteracaoSenhaServidor(usuario.getUsuCodigo(), matricula, senhaNova, reiniciacao, senhaAutorizacaoServidor, false, responsavel);
                        } catch (final UsuarioControllerException e) {
                            // Falha no envio da comunicação não impede a alteração da senha.
                            LOG.error(e.getMessage(), e);
                        }
                    }
                }
            }
        } catch (UsuarioControllerException | SSOException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.alterar.senha.usuario", responsavel, ex);
        }
    }

    private boolean atualizaSenhaSSO(UsuarioTransferObject usuario, String senhaNova, String senhaAtualAberta,
                                     AcessoSistema responsavel) throws SSOException {
        // Se o token foi setado, é porque o usuário não estava com a senha expirada
        if (!responsavel.getUsuCodigo().equals(usuario.getUsuCodigo()) || (!TextHelper.isNull(responsavel.getSsoToken()) && !TextHelper.isNull(responsavel.getSsoToken().access_token))) {
            if (usuario.getUsuCodigo().equals(responsavel.getUsuCodigo())) {
                return ssoClient.updatePassword(responsavel.getSsoToken(), senhaNova, senhaAtualAberta);
            } else { // se o usuário responsável não é o mesmo que está tendo a senha alterada, deve-se usar a API de alteração de senha com usuário admin.
                // Logar usuário admin para inclusão de novo usuário
                return ssoClient.updatePasswordAsAdmin(usuario.getUsuEmail(), senhaNova);
            }
        } else if (!TextHelper.isNull(senhaAtualAberta)) {
            return ssoClient.updateExpiredPassword(usuario.getUsuEmail(), senhaNova, senhaAtualAberta);
        } else {
            // se senha atual vazia, significa que é uma reinicialização de senha.
            return ssoClient.updatePasswordAsAdmin(usuario.getUsuEmail(), senhaNova);
        }
    }

    /**
     * Sobrecarga do método "alterarSenhaApp()".
     * @param usuCodigo
     * @param senhaNova
     * @param senhaCriptografada
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void alterarSenhaApp(String usuCodigo, String senhaNova, boolean senhaCriptografada, AcessoSistema responsavel) throws UsuarioControllerException {
        alterarSenhaApp(usuCodigo, senhaNova, senhaCriptografada, false, responsavel);
    }

    /**
     * Altera a senha do App.
     * @param usuCodigo
     * @param senhaNova
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void alterarSenhaApp(String usuCodigo, String senhaNova, boolean senhaCriptografada, boolean chamadaMobile, AcessoSistema responsavel) throws UsuarioControllerException {
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);

        try {
            // Tenta buscar por um usuario servidor.
            usuario = this.findUsuario(usuario, AcessoSistema.ENTIDADE_SER, responsavel);
        } catch (final UsuarioControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.alterar.senha.usuario", responsavel, ex);
        }

        SenhaHelper.validarForcaSenha(senhaNova, true, responsavel);

        // Criptografa a nova senha para armazenamento no banco.
        String senhaNovaCrypt = null;
        if (senhaNova != null) {
            if (!senhaCriptografada) {
                senhaNovaCrypt = SenhaHelper.criptografarSenha(usuario.getUsuLogin(), senhaNova, true, responsavel);
            } else {
                senhaNovaCrypt = senhaNova;
            }
        }

        try {
            final boolean habilitaSenhaApp = ParamSist.paramEquals(CodedValues.TPC_HABILITA_SENHA_APP, CodedValues.TPC_SIM, responsavel);

            if (chamadaMobile && habilitaSenhaApp) {
                usuario.setUsuSenhaApp(senhaNovaCrypt);
                usuario.setUsuDataExpSenhaApp(new Date(calculaDataExpiracaoSenha(false, usuario, true, responsavel).getTimeInMillis()));
            } else {
                usuario.setUsuSenha(senhaNovaCrypt);
                usuario.setUsuDataExpSenha(new Date(calculaDataExpiracaoSenha(false, usuario, true, responsavel).getTimeInMillis()));
            }

            // Determina parâmetros da ocorrência de usuário a ser gravada.
            final String tocCodigoOcorrencia = CodedValues.TOC_ALTERACAO_SENHA_APP;
            final String ousObs = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.senha.app.usuario", responsavel);

            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setUsuCodigo(usuCodigo);
            ocorrencia.setTocCodigo(tocCodigoOcorrencia);
            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setOusObs(ousObs);
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

            updateUsuario(usuario, ocorrencia, responsavel);

            final String matricula = usuario.getUsuLogin().substring(usuario.getUsuLogin().lastIndexOf('-') + 1, usuario.getUsuLogin().length());

            // Verifica se a alteração de senha deve ser comunicada.
            if ((senhaNova != null) && ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_USUARIO_SER, CodedValues.TPC_SIM, responsavel)) {
                try {
                    comunicaAlteracaoSenhaServidor(usuario.getUsuCodigo(), matricula, senhaNova, false, false, true, responsavel);
                } catch (final UsuarioControllerException e) {
                    // Falha no envio da comunicação não impede a alteração da senha.
                    LOG.error(e.getMessage(), e);
                }
            }
        } catch (final UsuarioControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.alterar.senha.usuario", responsavel, ex);
        }
    }

    /**
     * Valida a nova senha de acordo com as anteriores já salvas
     * @param usuCodigo
     * @param senhaNova
     * @param senhaNovaCrypt
     * @param senhaAutorizacaoServidor
     * @param responsavel
     * @throws UsuarioControllerException
     */
    private void validaSenhasAnteriores(String usuCodigo, String senhaNova, String senhaNovaCrypt, boolean senhaAutorizacaoServidor, AcessoSistema responsavel) throws UsuarioControllerException {
        final TransferObject usuario = obtemUsuarioTipo(usuCodigo, null, responsavel);
        final String tipo = !TextHelper.isNull(usuario.getAttribute("TIPO")) ? usuario.getAttribute("TIPO").toString() : "";
        final String senhaAntigaCrypt = (String) usuario.getAttribute(Columns.USU_SENHA);

        Integer qtdeSenhasAntigasUsuPodeRepetir = 0;
        if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
            qtdeSenhasAntigasUsuPodeRepetir = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_SENHAS_ANT_USU_CSE_NAO_REPETE, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_SENHAS_ANT_USU_CSE_NAO_REPETE, responsavel).toString()) : 0;
        } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) {
            qtdeSenhasAntigasUsuPodeRepetir = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_SENHAS_ANT_USU_CSA_NAO_REPETE, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_SENHAS_ANT_USU_CSA_NAO_REPETE, responsavel).toString()) : 0;
        } else if (AcessoSistema.ENTIDADE_SER.equals(tipo)) {
            qtdeSenhasAntigasUsuPodeRepetir = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_SENHAS_ANT_USU_SER_NAO_REPETE, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_SENHAS_ANT_USU_SER_NAO_REPETE, responsavel).toString()) : 0;
        } else {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
        }

        // Se for servidor e a senha a ser validada é a de autorização, não requer validação
        if (AcessoSistema.ENTIDADE_SER.equals(tipo) && senhaAutorizacaoServidor) {
            return;
        }

        if (qtdeSenhasAntigasUsuPodeRepetir.compareTo(0) > 0) {
            final List<TransferObject> senhasAntigas = lstSenhasAnterioresUsuarios(usuCodigo, responsavel);

            // Caso não possua nenhuma senha antiga cadastrada e o parâmetro for maior que 1, cadastra a senha anterior
            if (senhasAntigas.isEmpty() && (qtdeSenhasAntigasUsuPodeRepetir.compareTo(1) > 0)) {
                try {
                    SenhaAnteriorHome.create(usuCodigo, senhaAntigaCrypt, DateHelper.getSystemDatetime());
                } catch (final CreateException e) {
                    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                    throw new UsuarioControllerException("mensagem.erro.nao.possivel.armazenar.senha.anterior", responsavel);
                }
            }

            while (qtdeSenhasAntigasUsuPodeRepetir.compareTo(senhasAntigas.size()) < 0) {
                // Se a quantidade senhas anteriores for maior que o parâmetro deve excluir as N mais antigas
                try {
                    final TransferObject excluir = senhasAntigas.remove(0);
                    final SenhaAnteriorId pk = new SenhaAnteriorId(usuCodigo, excluir.getAttribute(Columns.SEA_SENHA).toString());
                    final SenhaAnterior senhaAnterior = SenhaAnteriorHome.findByPrimaryKey(pk);
                    AbstractEntityHome.remove(senhaAnterior);
                } catch (final FindException e) {
                    throw new UsuarioControllerException("mensagem.erro.interno.nao.possivel.validar.senha.anterior", responsavel);
                } catch (final RemoveException e) {
                    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                    throw new UsuarioControllerException("mensagem.erro.interno.nao.possivel.validar.senha.anterior", responsavel);
                }
            }

            for (final TransferObject senhaAntiga : senhasAntigas) {
                // Se a nova senha for igual a uma das senhas anteriores lança uma exceção
                if (JCrypt.verificaSenha(senhaNova, (String) senhaAntiga.getAttribute(Columns.SEA_SENHA))) {
                    throw new UsuarioControllerException("mensagem.erro.nova.senha.deve.ser.diferente.das.ultimas.arg0.senhas.definidas", responsavel, qtdeSenhasAntigasUsuPodeRepetir.toString());
                }
            }

            // Armazena a nova senha como senha anterior
            try {
                SenhaAnteriorHome.create(usuCodigo, senhaNovaCrypt, DateHelper.getSystemDatetime());
            } catch (final CreateException e) {
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.armazenar.senha.anterior", responsavel);
            }

            // Se estiver criando a X senha antiga, excluir a mais antiga
            if (qtdeSenhasAntigasUsuPodeRepetir.compareTo(senhasAntigas.size()) == 0) {
                try {
                    final TransferObject excluir = senhasAntigas.remove(0);
                    final SenhaAnteriorId pk = new SenhaAnteriorId(usuCodigo, excluir.getAttribute(Columns.SEA_SENHA).toString());
                    final SenhaAnterior senhaAnterior = SenhaAnteriorHome.findByPrimaryKey(pk);
                    AbstractEntityHome.remove(senhaAnterior);
                } catch (final FindException e) {
                    throw new UsuarioControllerException("mensagem.erro.interno.nao.possivel.validar.senha.anterior", responsavel);
                } catch (final RemoveException e) {
                    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                    throw new UsuarioControllerException("mensagem.erro.interno.nao.possivel.excluir.senha.anterior", responsavel);
                }
            }
        }
    }

    /**
     * Comunica ao usuário servidor sobre a alteração de sua senha.
     * @param usuCodigo : Código do usuário
     * @param matricula : Mátricula do servidor
     * @param novaSenha : Nova senha
     * @param reiniciacao : Indica se a senha foi reiniciada ou alterada
     * @param senhaAutorizacaoServidor : Indica que é senha de autorização (senha 2)
     * @param responsavel : Responsável
     * @throws UsuarioControllerException
     */
    private void comunicaAlteracaoSenhaServidor(String usuCodigo, String matricula, String novaSenha, boolean reiniciacao, boolean senhaAutorizacaoServidor, boolean senhaApp, AcessoSistema responsavel) throws UsuarioControllerException {
        String emailDestinatario = null;
        String celularDestinatario = null;
        final String modoEntrega = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, responsavel)) ? ParamSist.getInstance().getParam(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, responsavel).toString() : CodedValues.ALTERACAO_SENHA_AUT_SER_ENVIA_EMAIL;

        final ObtemUsuarioServidorQuery query = new ObtemUsuarioServidorQuery();
        query.usuCodigo = usuCodigo;
        query.rseMatricula = matricula;

        List<TransferObject> servidores = null;
        try {
            servidores = query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.encontrar.servidor", responsavel, e);
        }

        if (ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_ENVIA_EMAIL, responsavel) || ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_EXIBE_TELA, responsavel) || ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_EMAIL_OU_TELA, responsavel) || ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_EMAIL_E_TELA, responsavel)) {
            if ((servidores != null) && (servidores.size() == 1)) {
                emailDestinatario = consultarEmailServidor(true, (String) servidores.get(0).getAttribute(Columns.SER_CPF), (String) servidores.get(0).getAttribute(Columns.SER_EMAIL), modoEntrega, responsavel);
            } else {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.encontrar.servidor", responsavel);
            }

            if (!TextHelper.isNull(emailDestinatario)) {
                try {
                    EnviaEmailHelper.enviarEmailAlteracaoSenhaServidor(emailDestinatario, matricula, novaSenha, reiniciacao, senhaAutorizacaoServidor, senhaApp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.enviar.email.servidor", responsavel, e);
                }
            }

        } else if (ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_SMS, responsavel)) {

            if ((servidores != null) && (servidores.size() == 1)) {
                celularDestinatario = (String) servidores.get(0).getAttribute(Columns.SER_CELULAR);
            } else {
                throw new UsuarioControllerException("", responsavel);
            }

            if (!TextHelper.isNull(celularDestinatario)) {
                try {
                    EnviaSMSHelper.enviarSMSSenhaAutorizacao(celularDestinatario, matricula, novaSenha, reiniciacao, senhaAutorizacaoServidor, senhaApp, responsavel);
                } catch (final ZetraException e) {
                    throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, e);
                }
            }

        } else if (ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_SMS_E_EMAIL, responsavel)) {
            if ((servidores != null) && (servidores.size() == 1)) {
                celularDestinatario = (String) servidores.get(0).getAttribute(Columns.SER_CELULAR);
            	emailDestinatario = consultarEmailServidor(true, (String) servidores.get(0).getAttribute(Columns.SER_CPF), (String) servidores.get(0).getAttribute(Columns.SER_EMAIL), modoEntrega, responsavel);
            } else {
                throw new UsuarioControllerException("", responsavel);
            }

            if (!TextHelper.isNull(emailDestinatario)) {
                try {
                    EnviaEmailHelper.enviarEmailAlteracaoSenhaServidor(emailDestinatario, matricula, novaSenha, reiniciacao, senhaAutorizacaoServidor, senhaApp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.enviar.email.servidor", responsavel, e);
                }
            }

            if (!TextHelper.isNull(celularDestinatario)) {
                try {
                    EnviaSMSHelper.enviarSMSSenhaAutorizacao(celularDestinatario, matricula, novaSenha, reiniciacao, senhaAutorizacaoServidor, senhaApp, responsavel);
                } catch (final ZetraException e) {
                    throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, e);
                }
            }
        }
    }

    @Override
    public String gerarSenhaAutorizacaoOtp(String rseCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        return gerarSenhaAutorizacaoOtp(rseCodigo, null, responsavel);
    }

    /**
     * Gera nova senha de autorização do servidor OTP e envia por email e/ou SMS.
     * @param usuCodigo
     * @param tocCodigo
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public String gerarSenhaAutorizacaoOtp(String rseCodigo, String modoEntrega, AcessoSistema responsavel) throws UsuarioControllerException {

        if (!ParamSist.paramEquals(CodedValues.TPC_USA_SENHA_AUTORIZACAO_DESC_SERVIDOR, CodedValues.TPC_SIM, responsavel)) {
            throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
        }

        ServidorTransferObject servidor = null;
        try {
            servidor = servidorController.findServidorByRseCodigo(rseCodigo, responsavel);
        } catch (final ServidorControllerException e) {
            throw new UsuarioControllerException(e);
        }

        final List<TransferObject> usuarios = lstUsuariosSerByRseCodigo(rseCodigo, responsavel);

        if ((usuarios == null) || usuarios.isEmpty() || (usuarios.size() > 1)) {
            throw new UsuarioControllerException("mensagem.erro.servidor.usuario.nao.encontrado", responsavel);
        }

        final String serNome = servidor.getSerNome();
        final String usuCodigo = usuarios.get(0).getAttribute(Columns.USU_CODIGO).toString();

        if (TextHelper.isNull(modoEntrega)) {
            modoEntrega = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, responsavel)) ? ParamSist.getInstance().getParam(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, responsavel).toString() : CodedValues.ALTERACAO_SENHA_AUT_SER_ENVIA_EMAIL;
        }

        boolean enviou = false;
        boolean enviaEmail = false;
        boolean enviaCelular = false;
        boolean reconhecimentoFacial = false;

        switch (modoEntrega) {
            case CodedValues.ALTERACAO_SENHA_AUT_SER_ENVIA_EMAIL:
                enviaEmail = true;
                break;

            case CodedValues.ALTERACAO_SENHA_AUT_SER_EXIBE_TELA:
            case CodedValues.ALTERACAO_SENHA_AUT_SER_EMAIL_OU_TELA:
            case CodedValues.ALTERACAO_SENHA_AUT_SER_EMAIL_E_TELA:
                enviaEmail = true;
                break;

            case CodedValues.ALTERACAO_SENHA_AUT_SER_SMS:
                enviaCelular = true;
                break;

            case CodedValues.ALTERACAO_SENHA_AUT_SER_SMS_E_EMAIL:
                enviaCelular = true;
                enviaEmail = true;
                break;

            case CodedValues.ALTERACAO_SENHA_AUT_SER_RECONHECIMENTO_FACIAL:
                reconhecimentoFacial = true;
                break;

            default:
                enviaEmail = true;
                break;
        }

        final String novaSenhaPlana = gerarSenhaAutorizacao(usuCodigo, false, true, true, responsavel);

        if (reconhecimentoFacial) {
            return novaSenhaPlana;
        }

        final String email = consultarEmailServidor(enviaEmail, servidor.getSerCpf(), servidor.getSerEmail(), modoEntrega, responsavel);

        final String celular = servidor.getSerCelular();

        // Envia mensagem
        if (enviaCelular && !TextHelper.isNull(celular)) {
            try {
                EnviaSMSHelper.enviarSMSOTP(celular, novaSenhaPlana, responsavel);
                enviou = true;
            } catch (final ZetraException e) {
                // Se deu erro ao enviar, espera possível envio por email
            }
        }

        if (enviaEmail && !TextHelper.isNull(email)) {
            try {
                EnviaEmailHelper.enviarEmailOTPServidor(serNome, email, novaSenhaPlana, responsavel);
                enviou = true;
            } catch (final ViewHelperException e) {
                // Se deu erro ao enviar, mensagem de erro será setada no próximo tratamento
            }
        }

        if (!enviou) {
            if (enviaCelular && enviaEmail) {
                throw new UsuarioControllerException("mensagem.erro.sms.ou.email.enviar", responsavel);
            } else if (enviaCelular) {
                throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel);
            } else if (enviaEmail) {
                throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel);
            }
        }

        return novaSenhaPlana;
    }

    /**
     * Gera nova senha de autorização do servidor.
     * @param usuCodigo
     * @param tocCodigo
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public String gerarSenhaAutorizacao(String usuCodigo, boolean totem, AcessoSistema responsavel) throws UsuarioControllerException {
        return gerarSenhaAutorizacao(usuCodigo, totem, false, true, responsavel);
    }

    /**
     * Gera nova senha de autorização do servidor.
     * @param usuCodigo
     * @param tocCodigo
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public String gerarSenhaAutorizacao(String usuCodigo, boolean totem, boolean naoComunicarServidor, boolean validaQtdeSenhaAutorizacao, AcessoSistema responsavel) throws UsuarioControllerException {
        if (validaQtdeSenhaAutorizacao) {
            // Valida a quantidade máxima de senhas de autorização múltiplas que podem ser geradas para um servidor
            validaQtdeSenhaAutorizacao(usuCodigo, responsavel);
        }

        final TransferObject servidor = obtemServidorPorUsuario(usuCodigo, responsavel);
        final String srsCodigo = servidor.getAttribute(Columns.SRS_CODIGO).toString();
        if (!CodedValues.SRS_ATIVO.equals(srsCodigo)) {
            throw new UsuarioControllerException("mensagem.senha.servidor.autorizacao.erro.servidor.bloqueado", responsavel);
        }

        // Tamanho máximo da senha de autorização
        final int tamMaxSenhaServidor = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_AUT_SERVIDOR, responsavel)) ? Integer.parseInt(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_AUT_SERVIDOR, responsavel).toString()) : 8;

        // Gera nova senha plana: verifica se deve ser apenas numérica
        final boolean senhaAutNumerica = ParamSist.paramEquals(CodedValues.TPC_SENHA_AUT_SERVIDOR_SOMENTE_NUMERICA, CodedValues.TPC_SIM, responsavel);
        final String novaSenhaPlana = senhaAutNumerica ? GeradorSenhaUtil.getPasswordNumber(tamMaxSenhaServidor, responsavel) : GeradorSenhaUtil.getPassword(tamMaxSenhaServidor, AcessoSistema.ENTIDADE_SER, responsavel);

        final String tocCodigo = totem ? CodedValues.TOC_ALTERACAO_SENHA_AUTORIZACAO_TOTEM : CodedValues.TOC_ALTERACAO_SENHA_AUTORIZACAO;
        // Altera a senha de autorização do servidor
        this.alterarSenha(usuCodigo, novaSenhaPlana, null, null, false, true, true, false, tocCodigo, null, naoComunicarServidor, false, null, responsavel);

        // Retorna a senha gerada
        return novaSenhaPlana;
    }

    /**
     * Gera nova senha de autorização do servidor (REST)
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public String gerarSenhaAutorizacaoRest(AcessoSistema responsavel) throws UsuarioControllerException {
        final String senhaPlana = gerarSenhaAutorizacao(responsavel.getUsuCodigo(), false, responsavel);

        //No mobile a senha deve ser sempre enviada por e-mail, independente do tpc 362, por isso enviamos o e-mail caso o parâmetro esteja habilitado somente para exibir na tela
        //Caso esteja as duas outras opções o método anterior já enviou o e-mail
        if (!TextHelper.isNull(responsavel.getSerEmail()) && (senhaPlana != null) && ParamSist.paramEquals(CodedValues.TPC_EMAIL_ALTERACAO_SENHA_AUT_SERVIDOR, CodedValues.ALTERACAO_SENHA_AUT_SER_EXIBE_TELA, responsavel)) {
            try {
                comunicaAlteracaoSenhaServidor(responsavel.getUsuCodigo(), responsavel.getRseMatricula(), senhaPlana, false, true, false, responsavel);
            } catch (final UsuarioControllerException e) {
                // Falha no envio da comunicação não impede a alteração da senha.
                LOG.error(e.getMessage(), e);
            }
        }

        return senhaPlana;
    }

    /**
     * Valida a quantidade máxima de senhas de autorização múltiplas que podem ser geradas para um servidor.
     * Validação somente é executada caso o sistema utilize senhas múltiplas de autorização.
     *
     * @param usuCodigo
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void validaQtdeSenhaAutorizacao(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        // Verifica se utiliza múltiplas senhas de autorização, e caso utilize
        // se é possível gerar nova senha de autorização
        if (ParamSist.paramEquals(CodedValues.TPC_USA_MULTIPLAS_SENHAS_AUTORIZACAO_SERVIDOR, CodedValues.TPC_SIM, responsavel)) {
            int qtdMaxSenhaAut = 5;
            try {
                // Obtém parâmetro com a quantidade máxima de senhas de autorização: Default = 5
                final Object qtdMaxSenhaAutParam = ParamSist.getInstance().getParam(CodedValues.TPC_QTD_MAX_MULTIPLAS_SENHAS_AUTORIZACAO, responsavel);
                qtdMaxSenhaAut = !TextHelper.isNull(qtdMaxSenhaAutParam) ? Integer.parseInt(qtdMaxSenhaAutParam.toString()) : 5;
            } catch (final NumberFormatException ex) {
                LOG.warn("Valor incorreto para o parâmetro de sistema: " + CodedValues.TPC_QTD_MAX_MULTIPLAS_SENHAS_AUTORIZACAO);
                qtdMaxSenhaAut = 5;
            }
            try {
                // Recupera as senhas de autorização do servidor
                final ListaSenhaAutorizacaoServidorQuery query = new ListaSenhaAutorizacaoServidorQuery();
                query.usuCodigo = usuCodigo;
                query.count = true;
                final int total = query.executarContador();
                // Caso já exceda o total, não permite geração de nova senha
                if (total >= qtdMaxSenhaAut) {
                    throw new UsuarioControllerException("mensagem.senha.servidor.autorizacao.erro.qtd.excedida", responsavel);
                }
            } catch (final HQueryException ex) {
                throw new UsuarioControllerException("mensagem.erro.interno.listar.senhas.autorizacao.usuario", responsavel, ex);
            }
        }
    }

    /**
     * Altera a senha de autorização do servidor.
     * @param usuCodigo
     * @param senhaNova
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void alterarSenhaAutorizacao(String usuCodigo, String senhaNova, AcessoSistema responsavel) throws UsuarioControllerException {
        this.alterarSenha(usuCodigo, senhaNova, null, null, false, false, true, false, CodedValues.TOC_ALTERACAO_SENHA_AUTORIZACAO, null, responsavel);
    }

    /**
     * Registra a utilização da senha de autorização do servidor através de sua remoção.
     * @param usuCodigo : Código do usuário servidor.
     * @param senhaUtilizada : Senha utilizada que será consumida
     * @param responsavel : Responsável pela operação
     * @throws UsuarioControllerException
     */
    @Override
    public void consomeSenhaAutorizacao(String usuCodigo, String senhaUtilizada, AcessoSistema responsavel) throws UsuarioControllerException {
        this.alterarSenha(usuCodigo, null, senhaUtilizada, null, false, true, true, true, CodedValues.TOC_UTILIZACAO_SENHA_AUTORIZACAO, null, responsavel);
    }

    /**
     * Cancela a senha de autorização do servidor.
     * @param usuCodigo : Código do usuário servidor.
     * @param senhaUtilizada : Senha não utilizada que será cancelada (criptografada)
     * @param responsavel : Responsável pela operação
     * @throws UsuarioControllerException
     */
    @Override
    public void cancelaSenhaAutorizacao(String usuCodigo, String senhaNaoUtilizada, AcessoSistema responsavel) throws UsuarioControllerException {
        this.alterarSenha(usuCodigo, null, senhaNaoUtilizada, null, false, true, true, true, CodedValues.TOC_CANCELAMENTO_SENHA_NAO_UTILIZADA, null, responsavel);
    }

    /**
     * Cancela a senha de autorização do servidor. (REST)
     * @param dataCriacao : Data de criação da senha que será cancelada (criptografada)
     * @param responsavel : Responsável pela operação
     * @throws UsuarioControllerException
     */
    @Override
    public void cancelaSenhaAutorizacaoRest(java.util.Date dataCriacao, AcessoSistema responsavel) throws UsuarioControllerException {
        SenhaAutorizacaoServidor senha = new SenhaAutorizacaoServidor();
        try {
            senha = SenhaAutorizacaoServidorHome.findByPrimaryKey(new SenhaAutorizacaoServidorId(responsavel.getUsuCodigo(), dataCriacao));
        } catch (final FindException e) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.localizar.senha.autorizacao.para.executar.operacao", responsavel, e);
        }

        this.alterarSenha(responsavel.getUsuCodigo(), null, senha.getSasSenha(), null, false, true, true, true, CodedValues.TOC_CANCELAMENTO_SENHA_NAO_UTILIZADA, null, responsavel);
    }

    /**
     * Altera a quantidade de operações disponíveis para a senha de autorização do servidor
     * @param usuCodigo
     * @param qtdOperacoes
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void alterarOperacoesSenhaAutorizacao(String usuCodigo, Short qtdOperacoes, String senhaUtilizada, AcessoSistema responsavel) throws UsuarioControllerException {
        // Verifica se utiliza múltiplas senhas de autorização
        final boolean usaMultiplasSenhasAut = ParamSist.paramEquals(CodedValues.TPC_USA_MULTIPLAS_SENHAS_AUTORIZACAO_SERVIDOR, CodedValues.TPC_SIM, responsavel);

        // Busca o registro do usuário servidor a ser alterado
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        usuario = this.findUsuario(usuario, AcessoSistema.ENTIDADE_SER, responsavel);
        Short qtdOperacoesAtual = null;
        SenhaAutorizacaoServidor sas = null;

        if (usaMultiplasSenhasAut) {
            try {
                final List<SenhaAutorizacaoServidor> senhasAut = SenhaAutorizacaoServidorHome.findByUsuCodigo(usuCodigo);
                for (final SenhaAutorizacaoServidor senhaAut : senhasAut) {
                    if (JCrypt.verificaSenha(senhaUtilizada, senhaAut.getSasSenha())) {
                        sas = senhaAut;
                        qtdOperacoesAtual = sas.getSasQtdOperacoes();
                        break;
                    }
                }
                if (sas == null) {
                    throw new UsuarioControllerException("mensagem.senha.servidor.autorizacao.nao.encontrada", responsavel);
                }
            } catch (final FindException ex) {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.localizar.senha.autorizacao.para.executar.operacao", responsavel, ex);
            }
        } else {
            qtdOperacoesAtual = usuario.getUsuOperacoesSenha2();
        }

        // Se a quantidade de operações é maior que zero e está sendo reduzida,
        // cria ocorrência de utilização da senha, pois ela ainda está válida e
        // não será "consumida" pela operação
        OcorrenciaUsuarioTransferObject ocorrencia = null;
        if ((qtdOperacoes != null) && (qtdOperacoesAtual != null) && (qtdOperacoes > 0) && (qtdOperacoesAtual > qtdOperacoes)) {
            ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setUsuCodigo(usuCodigo);
            ocorrencia.setTocCodigo(CodedValues.TOC_UTILIZACAO_SENHA_AUTORIZACAO);
            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.utilizacao.senha.autorizacao", responsavel));
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
            ocorrencia.setUtilizacaoSenhaAutServidor(true);
        }

        if (usaMultiplasSenhasAut) {
            try {
                sas.setSasQtdOperacoes(qtdOperacoes);
                AbstractEntityHome.update(sas);
                if (ocorrencia != null) {
                    createOcorrenciaUsuario(ocorrencia, responsavel);
                }
            } catch (final UpdateException ex) {
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.atualizar.senha.autorizacao", responsavel, ex);
            }
        } else {
            // Atualiza o registro no usuário
            usuario.setUsuOperacoesSenha2(qtdOperacoes);
            updateUsuario(usuario, ocorrencia, responsavel);
        }
    }

    /**
     * Lista as senhas de autorização do servidor não expiradas e com qtd
     * de operações maior que zero.
     * @param usuCodigo : código do usuário servidor
     * @param responsavel : responsável pela operação
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public List<TransferObject> lstSenhaAutorizacaoServidor(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaSenhaAutorizacaoServidorQuery query = new ListaSenhaAutorizacaoServidorQuery();
            query.usuCodigo = usuCodigo;
            return query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.interno.listar.senhas.autorizacao.usuario", responsavel, e);
        }
    }

    /**
     * Lista as senhas de autorização do servidor não expiradas e com qtd (REST)
     * de operações maior que zero.
     * @param responsavel : responsável pela operação
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public List<TransferObject> lstSenhaAutorizacaoServidorRest(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaSenhaAutorizacaoServidorQuery query = new ListaSenhaAutorizacaoServidorQuery();
            query.usuCodigo = responsavel.getUsuCodigo();
            return query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.interno.listar.senhas.autorizacao.usuario", responsavel, e);
        }
    }

    /**
     * Retorna a quantidade de senha de autorização de usuário servidor gerada no dia atual via host a host.
     *
     * @param usuCodigo
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public int qtdeSenhaAutorizacaoUsuSerDiaHostAHost(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaOcorrenciaUsuSerSenhaAutorizacaoViaTotemQuery query = new ListaOcorrenciaUsuSerSenhaAutorizacaoViaTotemQuery();
            query.usuCodigo = usuCodigo;
            return query.executarContador();
        } catch (final HQueryException e) {
            // TODO Alterar mensagem da exceção
            throw new UsuarioControllerException("mensagem.erro.interno.listar.senhas.autorizacao.usuario", responsavel, e);
        }
    }

    /**
     * Recupera os dados da senha de autorização do servidor.
     * @param usuCodigo : código do usuário servidor
     * @param sasSenha : senha criptografada
     * @param responsavel : responsável pela operação
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public TransferObject obtemSenhaAutorizacaoServidor(String usuCodigo, String senha, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaSenhaAutorizacaoServidorQuery query = new ListaSenhaAutorizacaoServidorQuery();
            query.usuCodigo = usuCodigo;
            query.sasSenha = null;
            query.senhasValidas = false;
            //query.maxResults = 1;
            final List<TransferObject> senhasAutServidor = query.executarDTO();
            if ((senhasAutServidor != null) && (senhasAutServidor.size() > 0)) {
                for (final TransferObject autorizacao : senhasAutServidor) {
                    final String sasSenha = (String) autorizacao.getAttribute(Columns.SAS_SENHA);
                    if (JCrypt.verificaSenha(senha, sasSenha)) {
                        return autorizacao;
                    }
                }
            }
            return null;
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.interno.listar.senhas.autorizacao.usuario", responsavel, e);
        }
    }

    /**
     * Cria o protocolo de senha de autorização do servidor.
     *
     * @param psaCodigo
     * @param usuCodigoResponsavel
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public String createProtocoloSenhaAutorizacao(String psaCodigo, String usuCodigoAfetado, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            ProtocoloSenhaAutorizacaoHome.create(psaCodigo, usuCodigoAfetado, responsavel.getUsuCodigo());

            return psaCodigo;
        } catch (final CreateException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
        }
    }

    /**
     * Retorna protocolo de senha de autorização.
     *
     * @param psaCodigo
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public TransferObject getProtocoloSenhaAutorizacao(String psaCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemProtocoloSenhaAutorizacaoQuery query = new ObtemProtocoloSenhaAutorizacaoQuery();
            query.psaCodigo = psaCodigo;
            final List<TransferObject> lista = query.executarDTO();
            return (lista != null) && !lista.isEmpty() ? lista.get(0) : null;
        } catch (final HQueryException e) {
            LOG.error(e.getMessage(), e);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
        }
    }

    /**
     * Invalida as senhas de autorização dos servidores de acordo com o prazo de validade
     * definido no parâmetro de sistema.
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public List<TransferObject> listarSenhasExpiradasCancelamentoAut(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            List<TransferObject> senhasAutorizacaoExpiradas = null;
            if (ParamSist.paramEquals(CodedValues.TPC_USA_MULTIPLAS_SENHAS_AUTORIZACAO_SERVIDOR, CodedValues.TPC_SIM, responsavel)) {
                // Recupera a lista de senhas de autorização já expiradas
                final ListaSenhaAutorizacaoServidorExpiradaQuery query = new ListaSenhaAutorizacaoServidorExpiradaQuery();
                senhasAutorizacaoExpiradas = query.executarDTO();

            } else {
                // Recupera a lista de usuários com senha de autorização vencida.
                final ListaUsuarioSerSenhaAutExpiradaQuery query = new ListaUsuarioSerSenhaAutExpiradaQuery();
                senhasAutorizacaoExpiradas = query.executarDTO();
            }
            return senhasAutorizacaoExpiradas;
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.recuperar.senhas.nao.utilizadas", responsavel, ex);
        }
    }

    /**
     * Altera a chave de recuperação de senha do usuário.
     * @param usuCodigo : Código do usuário
     * @param codSenha  : Código de recuperação de senha
     * @param responsavel : Usuário que está realizando a recuperação de senha
     * @throws UsuarioControllerException
     */
    @Override
    public void alteraChaveRecupSenha(String usuCodigo, String codSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        // Busca o usuário pela chave primária
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        usuario = findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);

        if (!CodedValues.STU_ATIVO.equals(usuario.getStuCodigo())) {
            throw new UsuarioControllerException("mensagem.usuarioBloqueado", responsavel);
        }

        try {
            // Salva chave para recuperação de senha.
            usuario.setUsuChaveRecuperarSenha(codSenha);

            if (!TextHelper.isNull(codSenha)) {
                usuario.setUsuDataRecSenha(DateHelper.getSystemDatetime());
            } else {
                usuario.setUsuDataRecSenha(null);
            }

            // Determina parâmetros da ocorrência de usuário a ser gravada.
            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_SENHA_USUARIO);
            ocorrencia.setUsuCodigo(usuCodigo);
            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
            if (!TextHelper.isNull(codSenha)) {
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.chave.recup.senha.usuario", responsavel));
            } else {
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.utilizacao.chave.recup.senha.usuario", responsavel));
            }

            updateUsuario(usuario, ocorrencia, responsavel);

        } catch (final UsuarioControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.alterar.chave.recuperacao.senha.usuario", responsavel, ex);
        }
    }

    /**
     * Altera a chave de recuperação de senha do usuário no auto-desbloqueio
     * @param usuCodigo : Código do usuário
     * @param codSenha  : Código de recuperação de senha
     * @param responsavel : Usuário que está realizando a recuperação de senha
     * @throws UsuarioControllerException
     */
    @Override
    public void alteraChaveRecupSenhaAutoDesbloqueio(String usuCodigo, String codSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        // Busca o usuário pela chave primária
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        usuario = findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);

        if (!CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE.equals(usuario.getStuCodigo())) {
            throw new UsuarioControllerException("mensagem.auto.desbloqueio.servidor.nao.pode.desbloqueado", responsavel);
        }

        try {
            // Salva chave para recuperação de senha.
            usuario.setUsuChaveRecuperarSenha(codSenha);

            if (!TextHelper.isNull(codSenha)) {
                usuario.setUsuDataRecSenha(DateHelper.getSystemDatetime());
            } else {
                usuario.setUsuDataRecSenha(null);
            }

            // Determina parâmetros da ocorrência de usuário a ser gravada.
            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_SENHA_USUARIO);
            ocorrencia.setUsuCodigo(usuCodigo);
            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
            if (!TextHelper.isNull(codSenha)) {
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.chave.recup.senha.usuario", responsavel));
            } else {
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.utilizacao.chave.recup.senha.usuario", responsavel));
            }

            updateUsuario(usuario, ocorrencia, responsavel);

        } catch (final UsuarioControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.alterar.chave.recuperacao.senha.usuario", responsavel, ex);
        }
    }

    private boolean validarChaveRecupSenha(String usuCodigo, String codSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        usuario = findUsuario(usuario, responsavel.getTipoEntidade(), responsavel);

        if (!CodedValues.STU_ATIVO.equals(usuario.getStuCodigo())) {
            throw new UsuarioControllerException("mensagem.usuarioBloqueado", responsavel);
        }

        // Busca chave do usuario salvo em banco de dados.
        final String usuChave = usuario.getUsuChaveRecuperarSenha() == null ? "" : usuario.getUsuChaveRecuperarSenha();
        // Verificar se os codigos de recuperação são iguais.
        if (usuChave.equals(codSenha) && !"".equals(usuChave) && !"".equals(codSenha)) {
            // verifica se chave de recuperação já passou do limite de 1 dia para ser consumida
            final java.util.Date dataCriacaoChave = usuario.getUsuDataRecSenha();
            if (DateHelper.dayDiff(DateHelper.getSystemDatetime(), dataCriacaoChave) > 1) {
                return false;
            }

            alteraChaveRecupSenha(usuCodigo, "", responsavel);
            return true;
        } else {
            return false;
        }
    }

    private boolean validarChaveRecupSenhaAutoDesbloqueio(String usuCodigo, String codSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        usuario = findUsuario(usuario, responsavel.getTipoEntidade(), responsavel);

        if (!CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE.equals(usuario.getStuCodigo())) {
            throw new UsuarioControllerException("mensagem.auto.desbloqueio.servidor.nao.pode.desbloqueado", responsavel);
        }

        // Busca chave do usuario salvo em banco de dados.
        final String usuChave = usuario.getUsuChaveRecuperarSenha() == null ? "" : usuario.getUsuChaveRecuperarSenha();
        // Verificar se os codigos de recuperação são iguais.
        if (usuChave.equals(codSenha) && !"".equals(usuChave) && !"".equals(codSenha)) {
            // verifica se chave de recuperação já passou do limite de 1 dia para ser consumida
            final java.util.Date dataCriacaoChave = usuario.getUsuDataRecSenha();
            if (DateHelper.dayDiff(DateHelper.getSystemDatetime(), dataCriacaoChave) > 1) {
                return false;
            }

            alteraChaveRecupSenhaAutoDesbloqueio(usuCodigo, "", responsavel);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Envia ao usuário servidor link para reinicializar a senha na recuperação de senha.
     * @param usuCodigo Código do usuário
     * @param matricula Mátricula do servidor
     * @param link Link para recuperar senha
     * @param codigo Codigo para verificação do usuario
     * @param responsavel Responsável
     * @throws UsuarioControllerException
     */
    @Override
    public void enviaLinkReinicializarSenhaSer(String usuCodigo, String matricula, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException {
        String emailDestinatario = null;
        String[] serNome = null;
        String serPrimeiroNome = null;

        final ObtemUsuarioServidorQuery query = new ObtemUsuarioServidorQuery();

        query.usuCodigo = usuCodigo;
        query.rseMatricula = matricula;
        link = link + "&tipo=recuperar&cod_recuperar=" + codigo;

        List<TransferObject> servidores = null;
        try {
            servidores = query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.recuperar.email.servidor", responsavel, e);
        }

        if ((servidores != null) && (servidores.size() == 1)) {
            emailDestinatario = (String) servidores.get(0).getAttribute(Columns.SER_EMAIL);
            serNome = TextHelper.split((String) servidores.get(0).getAttribute(Columns.SER_NOME), " ");
            serPrimeiroNome = serNome[0].trim().toString();
        } else {
            throw new UsuarioControllerException("mensagem.erro.recuperar.email.servidor", responsavel);
        }

        if (!TextHelper.isNull(emailDestinatario)) {
            try {
                EnviaEmailHelper.enviarLinkRecuperacaoSenhaServidor(emailDestinatario, serPrimeiroNome, link, responsavel);
            } catch (final ViewHelperException e) {
                throw new UsuarioControllerException("mensagem.erro.enviar.email.servidor", responsavel, e);
            }
        }
    }

    /**
     * Envia ao usuário servidor link para reinicializar a senha na recuperação de senha.
     * @param usuCodigo Código do usuário
     * @param matricula Mátricula do servidor
     * @param novaSenha Nova senha
     * @param reiniciacao Indica se a senha foi reiniciada ou alterada.
     * @param responsavel Responsável
     * @throws UsuarioControllerException
     */
    @Override
    public void enviaLinkReinicializarSenhaUsu(String usuCodigo, String login, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException {
        enviaLinkReinicializarSenhaUsuEmail(usuCodigo, login, link, codigo, null, responsavel);
    }

    private void enviaLinkReinicializarSenhaUsuEmail(String usuCodigo, String login, String link, String codigo, String emailDestinatario, AcessoSistema responsavel) throws UsuarioControllerException {

        link = link + "&tipo=recuperar&cod_recuperar=" + codigo;

        if (emailDestinatario == null) {
            final ObtemUsuarioQuery query = new ObtemUsuarioQuery();
            query.usuCodigo = usuCodigo;

            List<TransferObject> usuario = null;
            try {
                usuario = query.executarDTO();
            } catch (final HQueryException e) {
                throw new UsuarioControllerException("mensagem.erro.recuperar.email.usuario", responsavel, e);
            }

            if ((usuario != null) && (usuario.size() == 1)) {
                emailDestinatario = (String) usuario.get(0).getAttribute(Columns.USU_EMAIL);
            } else {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.encontrar.usuario", responsavel);
            }
        }

        if (!TextHelper.isNull(emailDestinatario)) {
            try {
                EnviaEmailHelper.enviarEmailLinkRecuperarSenha(emailDestinatario, login, link, responsavel);
            } catch (final ViewHelperException e) {
                throw new UsuarioControllerException("mensagem.erro.falha.enviar.email", responsavel, e);
            }
        }
    }

    /**
     * Envia ao novo usuário cirado link para definir a senha de acessi ao sistema
     * @param usuCodigo
     * @param emailDestinatario
     * @param usuLogin - Login do novo usuáro criado
     * @param usuNome - Nome do novo usuário criado
     * @param entidadeNome - Nome da entidade na qual o usuário foi criado.
     * @param link - link a ser enviado no e-mail que direciona para a página de definição de senha.
     * @param codigo - token de fluxo de acesso da URL
     * @param responsavel
     * @throws UsuarioControllerException
     */
    private void enviaLinkIniciacaoSenhaNovoUsuario(String usuCodigo, String emailDestinatario, String usuLogin, String usuNome, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException {
        link = link + "&tipo=recuperar&cod_recuperar=" + codigo;

        if (!TextHelper.isNull(emailDestinatario)) {
            try {
                EnviaEmailHelper.enviarEmailLinkDefinirSenhaNovoUsuario(emailDestinatario, usuLogin, usuNome, link, responsavel);
            } catch (final ViewHelperException e) {
                throw new UsuarioControllerException("mensagem.erro.falha.enviar.email", responsavel, e);
            }
        }
    }

    /**
     * Envia ao usuário servidor link para reinicializar a senha no auto desbloqueio
     * @param usuCodigo Código do usuário
     * @param matricula Mátricula do servidor
     * @param link Link para recuperar senha
     * @param codigo Codigo para verificação do usuario
     * @param responsavel Responsável
     * @throws UsuarioControllerException
     */
    @Override
    public void enviaLinkReinicializarSenhaSerAutoDesbloqueio(String usuCodigo, String matricula, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException {
        String emailDestinatario = null;

        final ObtemUsuarioServidorQuery query = new ObtemUsuarioServidorQuery();

        query.usuCodigo = usuCodigo;
        query.rseMatricula = matricula;
        link = link + "&tipo=recuperar&cod_recuperar=" + codigo + "&autodesbloqueio=true";

        List<TransferObject> servidores = null;
        try {
            servidores = query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.recuperar.email.servidor", responsavel, e);
        }

        if ((servidores != null) && (servidores.size() == 1)) {
            emailDestinatario = (String) servidores.get(0).getAttribute(Columns.SER_EMAIL);
        } else {
            throw new UsuarioControllerException("mensagem.erro.recuperar.email.servidor", responsavel);
        }

        if (!TextHelper.isNull(emailDestinatario)) {
            try {
                EnviaEmailHelper.enviarEmailLinkRecuperarSenhaAutoDesbloqueio(emailDestinatario, matricula, link, responsavel);
            } catch (final ViewHelperException e) {
                throw new UsuarioControllerException("mensagem.erro.enviar.email.servidor", responsavel, e);
            }
        }
    }

    /**
     * Envia ao usuário de outras entidades que não servidor um link para reinicializar a senha no auto desbloqueio
     * @param usuLogin login do usuário
     * @param link Link para recuperar senha
     * @param codigo Codigo para verificação do usuario
     * @param responsavel Responsável
     * @throws UsuarioControllerException
     */
    @Override
    public void enviaLinkReinicializarSenhaUsuAutoDesbloqueio(String usuLogin, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException {
        String emailDestinatario = null;

        final ObtemUsuarioQuery query = new ObtemUsuarioQuery();

        query.usuLogin = usuLogin;
        link = link + "&tipo=recuperar&cod_recuperar=" + codigo + "&autodesbloqueio=true";

        List<TransferObject> usuarios = null;
        try {
            usuarios = query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.recuperar.email.usuario", responsavel, e);
        }

        if ((usuarios != null) && (usuarios.size() == 1)) {
            emailDestinatario = (String) usuarios.get(0).getAttribute(Columns.USU_EMAIL);
        } else {
            throw new UsuarioControllerException("mensagem.erro.recuperar.email.usuario", responsavel);
        }

        if (!TextHelper.isNull(emailDestinatario)) {
            try {
                EnviaEmailHelper.enviarEmailLinkRecuperarSenhaAutoDesbloqueio(emailDestinatario, null, link, responsavel);
            } catch (final ViewHelperException e) {
                throw new UsuarioControllerException(e);
            }
        }
    }

    @Override
    public List<TransferObject> lstStatusLogin(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaStatusLoginQuery query = new ListaStatusLoginQuery();
            return query.executarDTO();
        } catch (final HQueryException e) {
            LOG.error(e.getMessage(), e);
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.encontrar.possiveis.status.login", responsavel, e);
        }
    }

    @Override
    public TransferObject obtemUsuarioTipo(String usuCodigo, String usuLogin, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemUsuarioTipoQuery query = new ObtemUsuarioTipoQuery();
            query.usuCodigo = usuCodigo;
            query.usuLogin = usuLogin;

            final List<TransferObject> lista = query.executarDTO();
            if ((lista == null) || lista.isEmpty()) {
                throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
            }

            return lista.get(0);
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel, e);
        }
    }

    private List<TransferObject> lstSenhasAnterioresUsuarios(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaSenhasAntigasUsuarioQuery query = new ListaSenhasAntigasUsuarioQuery();
            query.usuCodigo = usuCodigo;

            return query.executarDTO();
        } catch (final HQueryException e) {
            LOG.error(e.getMessage(), e);
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.encontrar.possiveis.status.login", responsavel, e);
        }
    }

    @Override
    public void alteraDataUltimoAcessoSistema(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final java.util.Date dataUltAcesso = DateHelper.getSystemDatetime();
            UsuarioHome.updateUsuDataUltimoAcesso(dataUltAcesso, responsavel.getUsuCodigo());
            HistoricoLoginHome.create(responsavel.getUsuCodigo(), dataUltAcesso, responsavel.getCanal());
        } catch (final UpdateException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.alterar.data.acesso.usuario", responsavel, e);
        } catch (final CreateException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
        }
    }

    /**
     * Lista usuários cujo período de inatividade excede o permitido via configuração de sistema
     * @param usuCodigo - caso se queira pesquisar um usuário específico. Caso contrário, informar null
     * @param dataLimiteBloqueio - data a se verificar com o limite de inatividade configurado no sisteema
     * @param responsavel - responsavel pela operação
     */
    @Override
    public List<TransferObject> listarBloqueiaUsuariosInativos(String usuCodigo, java.util.Date dataLimiteBloqueio, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuarioInativoQuery query = new ListaUsuarioInativoQuery();
            query.usuCodigo = usuCodigo;
            query.dataLimiteBloqueio = dataLimiteBloqueio;
            return query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.bloquear.usuarios.inativos.sistema", responsavel, e);
        }
    }

    /**
     * Verifica se exite servidor com CPF informado e matricula nao excluida.
     * @param serCpf CPF a ser pesquisado.
     * @param responsavel Responsavel pela operaca
     * @return Verdadeiro se existir.
     * @throws UsuarioControllerException Excecao padrao.
     */
    private boolean existeServidor(String serCpf, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaServidoresQuery query = new ListaServidoresQuery();
            query.serCpf = serCpf;
            final List<TransferObject> usuarios = query.executarDTO();
            return (usuarios != null) && (usuarios.size() > 0);
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", responsavel, e);
        }
    }

    /**
     * Obtem usuarios de CSA/COR que possuem um CPF igual ao informado pelo parâmetro "usuCpf",
     * em uma entidade diferente de (ou igual a) "tipoEntidade/codigoEntidade";
     * ou que possuem CPF igual a de algum servidor não excluído.
     * @param usuCodigo : Ignora o usuário representado por este código
     * @param usuCpf : CPF a ser pesquisado
     * @param validaServidor : Flag para validar se o servidor com mesmo CPF do usuario possui matricula não excluída.
     * @param tipoEntidade : tipo da entidade do usuário
     * @param codigoEntidade : código da entidade do usuário
     * @param mesmaEntidade :
     * @param responsavel: Responsavel pela operacao
     * @return Lista de usuarios csa/cor.
     * @throws UsuarioControllerException
     */
    private List<TransferObject> lstUsuarioCsaCor(String usuCodigo, String usuCpf, boolean validaServidor, String tipoEntidade, String codigoEntidade, boolean mesmaEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemUsuarioCsaCorQuery query = new ObtemUsuarioCsaCorQuery();
            query.tipoEntidade = tipoEntidade;
            query.codigoEntidade = codigoEntidade;
            query.mesmaEntidade = mesmaEntidade;
            query.usuCodigo = usuCodigo;
            query.usuCpf = usuCpf;
            query.validaServidor = validaServidor;
            return query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel, e);
        }
    }

    /**
     * Obtem usuarios de CSE/ORG que possuem um CPF igual ao informado pelo parâmetro "usuCpf".
     * @param usuCodigo: Ignora o usuário representado por este código
     * @param usuCpf: CPF a ser pesquisado
     * @param responsavel: Responsavel pela operacao
     * @return Lista de usuarios cse/org.
     * @throws UsuarioControllerException
     */
    private List<TransferObject> lstUsuarioCseOrg(String usuCodigo, String usuCpf, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemUsuarioCseOrgQuery query = new ObtemUsuarioCseOrgQuery();
            query.usuCodigo = usuCodigo;
            query.usuCpf = usuCpf;
            return query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel, e);
        }
    }

    /**
     * Obtem usuarios de SUPorte que possuem um CPF igual ao informado pelo parâmetro "usuCpf".
     * @param usuCodigo: Ignora o usuário representado por este código
     * @param usuCpf: CPF a ser pesquisado
     * @param responsavel: Responsavel pela operacao
     * @return Lista de usuarios suporte.
     * @throws UsuarioControllerException
     */
    private List<TransferObject> lstUsuarioSup(String usuCodigo, String usuCpf, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemUsuarioSupQuery query = new ObtemUsuarioSupQuery();
            query.usuCodigo = usuCodigo;
            query.usuCpf = usuCpf;
            return query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel, e);
        }
    }

    /**
     * Se o parametro exigir que o CPF cadastrado para um servidor não seja igual a um CPF de usuário CSA/COR ativo, esse usuário deve ser bloqueado.
     * @param serCpf CPF do servidor a ser pesquisado.
     * @param responsavel Responsavel pela operacao.
     * @throws UsuarioControllerException Excecao padrao.
     */
    @Override
    public void bloqueiaUsuarioCsaComCPFServidor(String serCpf, AcessoSistema responsavel) throws UsuarioControllerException {
        final boolean exigeUnicidadeCPF = ParamSist.getBoolParamSist(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_CSA_E_SER, responsavel);
        if (exigeUnicidadeCPF) {
            final List<TransferObject> usuarios = lstUsuarioCsaCor(null, serCpf, true, null, null, false, responsavel);
            for (final TransferObject to : usuarios) {
                final String usuCodigo = (String) to.getAttribute(Columns.USU_CODIGO);
                final UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
                usuario.setStuCodigo(CodedValues.STU_BLOQUEADO_POR_CSE);
                usuario.setUsuTipoBloq(ApplicationResourcesHelper.getMessage(responsavel.isSup() ? "mensagem.usuario.bloqueado.sup" : "mensagem.usuario.bloqueado.cse", responsavel));

                // Grava ocorrência de bloqueio do usuário pelo consignante
                final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                ocorrencia.setUsuCodigo(usuCodigo);
                ocorrencia.setTocCodigo(CodedValues.TOC_BLOQUEIO_USUARIO_POR_CSE);
                ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage(responsavel.isSup() ? "mensagem.ocorrencia.ous.obs.bloqueio.usuario.por.sup" : "mensagem.ocorrencia.ous.obs.bloqueio.usuario.por.cse", responsavel));
                ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

                updateUsuario(usuario, ocorrencia, responsavel);
            }
        }
    }

    /**
     * Método que encapsula verificação da obrigatoriedade de cadastro de IP na criação/atualização
     * de um usuário, assim como validação sintática do IP.
     * @param tipo
     * @param usuLogin
     * @param codigoEntidade
     * @param ipList
     * @param ddnsList
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void validaIpAcessoResponsavel(String tipo, String usuLogin, String codigoEntidade, String ipList, String ddnsList, AcessoSistema responsavel) throws UsuarioControllerException {
        // Confere se cadastro de IPs (ou DDNS) de acesso é obrigatório de acordo com o tipo da entidade
        if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
            final boolean paramExigeIpAcesso = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_CADASTRO_IP_CSE_ORG, responsavel);
            final boolean paramVerificaIpAcesso = ParamSist.getBoolParamSist(CodedValues.TPC_VERIFICA_CADASTRO_IP_CSE_ORG, responsavel);
            final boolean paramCadUsuSobrepoeGeral = !ParamSist.paramEquals(CodedValues.TPC_ENDERECO_ACESSO_USU_SOBREPOE_CSE_ORG, CodedValues.TPC_NAO, responsavel);

            // Se um dos parametros 223 ou 225 for SIM, entao deve exigir o cadastro de IP
            final boolean exigeIpAcesso = paramExigeIpAcesso || paramVerificaIpAcesso;

            if (exigeIpAcesso && ((TextHelper.isNull(ipList) && TextHelper.isNull(ddnsList)) || !paramCadUsuSobrepoeGeral)) {
                try {
                    if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                        ConsignanteTransferObject cse = null;
                        try {
                            cse = consignanteController.findConsignante(codigoEntidade, responsavel);
                        } catch (final ConsignanteControllerException ex) {
                            if (!TextHelper.isNull(usuLogin)) {
                                final CustomTransferObject usuario = findUsuario(usuLogin, responsavel);
                                final String cseCodigo = !TextHelper.isNull(usuario.getAttribute(Columns.UCE_CSE_CODIGO)) ? usuario.getAttribute(Columns.UCE_CSE_CODIGO).toString() : null;
                                if (cseCodigo != null) {
                                    cse = consignanteController.findConsignante(cseCodigo, responsavel);
                                }
                            }
                        }
                        if ((cse == null) || (TextHelper.isNull(cse.getCseIPAcesso()) && TextHelper.isNull(cse.getCseDDNSAcesso()))) {
                            throw new UsuarioControllerException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }
                    } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                        OrgaoTransferObject org = null;
                        try {
                            org = consignanteController.findOrgao(codigoEntidade, responsavel);
                        } catch (final ConsignanteControllerException ex) {
                            if (!TextHelper.isNull(usuLogin)) {
                                final CustomTransferObject usuario = findUsuario(usuLogin, responsavel);
                                final String orgCodigo = !TextHelper.isNull(usuario.getAttribute(Columns.UOR_ORG_CODIGO)) ? usuario.getAttribute(Columns.UOR_ORG_CODIGO).toString() : null;
                                if (orgCodigo != null) {
                                    org = consignanteController.findOrgao(orgCodigo, responsavel);
                                }
                            }
                        }
                        if ((org == null) || (TextHelper.isNull(org.getOrgIPAcesso()) && TextHelper.isNull(org.getOrgDDNSAcesso()))) {
                            throw new UsuarioControllerException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }
                    }
                } catch (final ConsignanteControllerException ex) {
                    throw new UsuarioControllerException(ex);
                }
            }
        } else if ((AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) && (TextHelper.isNull(ipList) && TextHelper.isNull(ddnsList))) {
            final boolean paramExigeIpAcesso = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_CADASTRO_IP_CSA_COR, responsavel);
            final boolean paramVerificaIpAcesso = ParamSist.getBoolParamSist(CodedValues.TPC_VERIFICA_CADASTRO_IP_CSA_COR, responsavel);

            // Se um dos parametros 222 ou 224 for SIM, entao deve exigir o cadastro de IP
            boolean exigeIpAcesso = paramExigeIpAcesso || paramVerificaIpAcesso;

            try {
                // Nao da erro se tiver IP (ou DDNS) cadastrado para CSA ou COR
                if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                    CorrespondenteTransferObject cor = null;
                    try {
                        cor = consignatariaController.findCorrespondente(codigoEntidade, responsavel);
                    } catch (final ConsignatariaControllerException ex) {
                        if (!TextHelper.isNull(usuLogin)) {
                            final CustomTransferObject usuario = findUsuario(usuLogin, responsavel);
                            final String corCodigo = !TextHelper.isNull(usuario.getAttribute(Columns.UCO_COR_CODIGO)) ? usuario.getAttribute(Columns.UCO_COR_CODIGO).toString() : null;
                            if (corCodigo != null) {
                                cor = consignatariaController.findCorrespondente(corCodigo, responsavel);
                            }
                        }
                    }
                    if (cor != null) {
                        // Se o campo corExigeEnderecoAcesso estiver preenchido, ele prevalece sobre os parametros 222 e 224
                        exigeIpAcesso = cor.getCorExigeEnderecoAcesso() != null ? CodedValues.TPC_SIM.equals(cor.getCorExigeEnderecoAcesso()) : exigeIpAcesso;

                        if (exigeIpAcesso && TextHelper.isNull(cor.getCorIPAcesso()) && TextHelper.isNull(cor.getCorDDNSAcesso())) {
                            throw new UsuarioControllerException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }
                    }
                } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                    ConsignatariaTransferObject csa = null;
                    try {
                        csa = consignatariaController.findConsignataria(codigoEntidade, responsavel);
                    } catch (final ConsignatariaControllerException ex) {
                        if (!TextHelper.isNull(usuLogin)) {
                            final CustomTransferObject usuario = findUsuario(usuLogin, responsavel);
                            final String csaCodigo = !TextHelper.isNull(usuario.getAttribute(Columns.UCA_CSA_CODIGO)) ? usuario.getAttribute(Columns.UCA_CSA_CODIGO).toString() : null;
                            if (csaCodigo != null) {
                                csa = consignatariaController.findConsignataria(csaCodigo, responsavel);
                            }
                        }
                    }
                    if (csa != null) {
                        // Se o campo csaExigeEnderecoAcesso estiver preenchido, ele prevalece sobre os parametros 222 e 224
                        exigeIpAcesso = csa.getCsaExigeEnderecoAcesso() != null ? CodedValues.TPC_SIM.equals(csa.getCsaExigeEnderecoAcesso().toString()) : exigeIpAcesso;

                        if (exigeIpAcesso && TextHelper.isNull(csa.getCsaIPAcesso()) && TextHelper.isNull(csa.getCsaDDNSAcesso())) {
                            throw new UsuarioControllerException("mensagem.erro.usuario.ou.sua.entidade.deve.possuir.ips.acesso.cadastrados.sistema", responsavel);
                        }
                    }
                }
            } catch (final ConsignatariaControllerException ex) {
                throw new UsuarioControllerException(ex);
            }
        }

        if (!TextHelper.isNull(ipList)) {
            final List<String> ipsAcesso = Arrays.asList(ipList.split(";"));
            if (!JspHelper.validaListaIps(ipsAcesso)) {
                throw new UsuarioControllerException("mensagem.erro.endereco.ip.invalido", responsavel);
            }
        }
    }

    @Override
    public List<TransferObject> lstFuncoesPermitidasUsuario(String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        return lstFuncoesPermitidas(tipo, false, codigoEntidade, responsavel);
    }

    @Override
    public List<TransferObject> lstFuncoesPermitidasPerfil(String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        return lstFuncoesPermitidas(tipo, true, codigoEntidade, responsavel);
    }

    private List<TransferObject> lstFuncoesPermitidas(String tipo, boolean isPerfil, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        final boolean isAdministrador = responsavel.temPermissao(CodedValues.FUN_USUARIO_ADMINISTRADOR);

        final List<TransferObject> funcoesPermitidas = new ArrayList<>();

        String ncaCodigo = null;

        // recupera a natureza da consignataria para filtrar as funções que são restritas para essa natureza
        if (!TextHelper.isNull(codigoEntidade)) {
            ConsignatariaTransferObject csa = null;
            CorrespondenteTransferObject cor = null;
            if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                try {
                    csa = consignatariaController.findConsignataria(codigoEntidade, responsavel);
                    ncaCodigo = csa.getCsaNcaNatureza();
                } catch (final ConsignatariaControllerException ex) {
                    throw new UsuarioControllerException(ex);
                }
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                try {
                    cor = consignatariaController.findCorrespondente(codigoEntidade, responsavel);
                    csa = consignatariaController.findConsignataria(cor.getCsaCodigo(), responsavel);
                    ncaCodigo = csa.getCsaNcaNatureza();
                } catch (final ConsignatariaControllerException ex) {
                    throw new UsuarioControllerException(ex);
                }
            }
        }

        List<String> funcoesPermitidasNca = null;
        if (!TextHelper.isNull(ncaCodigo)) {
            funcoesPermitidasNca = selectFuncoesPermitidasNca(ncaCodigo, responsavel);
        }

        final List<TransferObject> funcoes = selectFuncoes(tipo, responsavel);
        for (final TransferObject to : funcoes) {
            final String funCodigo = (String) to.getAttribute(Columns.FUN_CODIGO);
            final String grfCodigo = (String) to.getAttribute(Columns.FUN_GRF_CODIGO);
            final String funRestritaNca = (String) to.getAttribute(Columns.FUN_RESTRITA_NCA);

            // Verifica se a função pode ser associada a um perfil
            if (isPerfil && CodedValues.FUNCOES_NAO_PERMITIDAS_PERFIL.contains(funCodigo)) {
                continue;
            }

            // Verifica se a função é de grupo administrador: só exibe para usuários administradores
            if (!TextHelper.isNull(grfCodigo) && CodedValues.GRUPO_FUNCAO_ADMINISTRADOR.equals(grfCodigo) && !isAdministrador) {
                continue;
            }

            // Verifica se as funções são restritas por natureza de consignatária quando o tipo for CSA ou COR
            // caso sejam, verifica se a CSA/COR tem permissão para utilizar a função
            if ((AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) && "S".equals(funRestritaNca)) {
                if ((funcoesPermitidasNca == null) || funcoesPermitidasNca.isEmpty() || !funcoesPermitidasNca.contains(funCodigo)) {
                    continue;
                }
            }

            // Se usuário de CSE, ou o tipo do usuário não é o mesmo, ou tem permissão para a função, então é permitida
            if (responsavel.isCseSup() || !responsavel.getTipoEntidade().equalsIgnoreCase(tipo) || responsavel.temPermissao(funCodigo)) {
                funcoesPermitidas.add(to);
            }
        }

        return funcoesPermitidas;
    }

    @Override
    public List<TransferObject> lstUsuarioCriadoRecursivoPorResponsavel(List<String> usuCodigos, AcessoSistema responsavel) throws UsuarioControllerException {
        List<TransferObject> retorno = new ArrayList<>();
        retorno = lstUsuarioCriadoPorResponsavel(usuCodigos, responsavel);

        if ((retorno != null) && !retorno.isEmpty()) {
            final List<String> codigos = new ArrayList<>();
            for (final TransferObject to : retorno) {
                codigos.add(to.getAttribute(Columns.USU_CODIGO).toString());
            }
            retorno.addAll(lstUsuarioCriadoRecursivoPorResponsavel(codigos, responsavel));
        }

        return retorno;
    }

    @Override
    public List<TransferObject> lstUsuarioCriadoPorResponsavel(List<String> usuCodigos, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuarioCriadoPorResponsavelQuery query = new ListaUsuarioCriadoPorResponsavelQuery();
            query.responsaveis = usuCodigos;
            return query.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.localizar.usuarios.criados.pelo.responsavel", responsavel, e);
        }
    }

    @Override
    public void bloquearDesbloquearUsuario(String usuCodigo, String status, String tipo, String tmoCodigo, String ousObs, AcessoSistema responsavel) throws UsuarioControllerException {
        bloquearDesbloquearUsuario(usuCodigo, status, tipo, tmoCodigo, ousObs, responsavel, true);
    }

    @Override
    public void bloquearDesbloquearUsuario(String usuCodigo, String status, String tipo, String tmoCodigo, String ousObs, AcessoSistema responsavel, Boolean validarCpf) throws UsuarioControllerException {
        final UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        usuario.setStuCodigo(status);
        if (CodedValues.STU_ATIVO.equals(status)) {
            usuario.setUsuTipoBloq("");
        }

        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
        ocorrencia.setUsuCodigo(usuCodigo);
        ocorrencia.setTocCodigo(CodedValues.STU_ATIVO.equals(status) ? CodedValues.TOC_DESBLOQUEIO_USUARIO : responsavel.isCseSup() ? CodedValues.TOC_BLOQUEIO_USUARIO_POR_CSE : CodedValues.TOC_BLOQUEIO_USUARIO);
        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage(CodedValues.STU_ATIVO.equals(status) ? "mensagem.ocorrencia.ous.obs.desbloqueio.usuario" : responsavel.isSup() ? "mensagem.ocorrencia.ous.obs.bloqueio.usuario.por.sup" : responsavel.isCse() ? "mensagem.ocorrencia.ous.obs.bloqueio.usuario.por.cse" : "mensagem.ocorrencia.ous.obs.bloqueio.usuario", responsavel));
        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

        TransferObject tmo = null;
        // Verifica motivo da operação
        if (!TextHelper.isNull(tmoCodigo)) {
            tmo = new CustomTransferObject();
            tmo.setAttribute(Columns.USU_CODIGO, usuCodigo);
            tmo.setAttribute(Columns.TMO_CODIGO, tmoCodigo);
            tmo.setAttribute(Columns.OUS_OBS, ousObs);
        }

        updateUsuario(usuario, ocorrencia, null, null, tipo, null, tmo, responsavel, validarCpf);
    }

    @Override
    public void bloquearDesbloquearUsuario(List<TransferObject> usuarios, String status, String tmoCodigo, String ousObs, AcessoSistema responsavel) throws UsuarioControllerException {
        for (final TransferObject usuario : usuarios) {
            bloquearDesbloquearUsuario(usuario.getAttribute(Columns.USU_CODIGO).toString(), status, usuario.getAttribute("TIPO").toString(), tmoCodigo, ousObs, responsavel);
        }
    }

    @Override
    public void bloquearUsuarioMotivoSeguranca(String usuCodigo, String entidadeOperada, String operacao, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            // Monta texto a ser inserido no log de segurança contendo: funcao, entidade e operacao, caso venha a ser bloqueado
            String textoDoLog = "";

            // funcao
            if (!TextHelper.isNull(responsavel.getFunCodigo())) {
                final Funcao funcao = FuncaoHome.findByPrimaryKey(responsavel.getFunCodigo());
                textoDoLog += ApplicationResourcesHelper.getMessage("rotulo.log.funcao", responsavel) + ": " + funcao.getFunDescricao() + "; ";
            }
            // entidade
            if (!TextHelper.isNull(entidadeOperada)) {
                final TipoEntidade tipoEntidade = TipoEntidadeHome.findByPrimaryKey(entidadeOperada);
                textoDoLog += ApplicationResourcesHelper.getMessage("rotulo.log.entidade", responsavel) + ": " + tipoEntidade.getTenDescricao() + "; ";
            }
            // operação
            if (!TextHelper.isNull(operacao)) {
                textoDoLog += ApplicationResourcesHelper.getMessage("rotulo.log.acao", responsavel) + ": " + operacao;
            }

            String motivoDoBloqueio = "";
            if (!TextHelper.isNull(textoDoLog)) {
                motivoDoBloqueio = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.bloqueio.automatico.usuario.seguranca.arg0", responsavel, textoDoLog);
            } else {
                motivoDoBloqueio = ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.bloqueio.automatico.usuario.seguranca", responsavel);
            }

            // Se o limite foi alcançado, então bloqueia o usuário
            final UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
            usuario.setStuCodigo(CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE_SEGURANCA);
            usuario.setUsuTipoBloq(ApplicationResourcesHelper.getMessage("mensagem.usuario.bloqueado.automaticamente.seguranca", responsavel));

            // Grava ocorrência de bloqueio automático do usuário
            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setUsuCodigo(usuCodigo);
            ocorrencia.setTocCodigo(CodedValues.TOC_BLOQUEIO_AUTOMATICO_USUARIO);
            ocorrencia.setOusUsuCodigo(AcessoSistema.getAcessoUsuarioSistema().getUsuCodigo());
            ocorrencia.setOusObs(motivoDoBloqueio);
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

            updateUsuario(usuario, ocorrencia, responsavel);
        } catch (final FindException ex) {
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public void aprovarCadastroUsuarioSer(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        final UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        usuario.setStuCodigo(CodedValues.STU_ATIVO);
        usuario.setUsuTipoBloq("");

        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
        ocorrencia.setUsuCodigo(usuCodigo);
        ocorrencia.setTocCodigo(CodedValues.TOC_APROVACAO_CADASTRO_USUARIO_SER);
        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.aprovacao.cadastro.usuario.ser", responsavel));
        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

        updateUsuario(usuario, ocorrencia, null, null, AcessoSistema.ENTIDADE_SER, null, null, responsavel, false);
    }

    @Override
    public Map<String, List<TransferObject>> lstUsuarioAuditorEntidade(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuarioAuditorEntidadeQuery query = new ListaUsuarioAuditorEntidadeQuery();
            final List<TransferObject> lista = query.executarDTO();

            final Map<String, List<TransferObject>> retorno = new HashMap<>();
            if ((lista != null) && !lista.isEmpty()) {
                for (final TransferObject to : lista) {
                    final String codigoEntidade = to.getAttribute("CODIGO_ENTIDADE").toString();
                    final String tipoEntidade = to.getAttribute("TIPO_ENTIDADE").toString();
                    final String chave = tipoEntidade + "|" + codigoEntidade;
                    List<TransferObject> valores = retorno.get(chave);
                    if (valores == null) {
                        valores = new ArrayList<>();
                        retorno.put(chave, valores);
                    }
                    valores.add(to);
                }
            }

            return retorno;
        } catch (final HQueryException e) {
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
        }
    }

    @Override
    public List<TransferObject> lstFuncoesAuditaveis(String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        final ListaFuncoesAuditaveisPapelQuery lstFuncAuditaveis = new ListaFuncoesAuditaveisPapelQuery();

        lstFuncAuditaveis.tipo = tipo;
        lstFuncAuditaveis.codigoEntidade = codigoEntidade;

        final String papelResponsavel = AcessoSistema.ENTIDADE_CSE.equals(responsavel.getTipoEntidade()) ? CodedValues.PAP_CONSIGNANTE : AcessoSistema.ENTIDADE_CSA.equals(responsavel.getTipoEntidade()) ? CodedValues.PAP_CONSIGNATARIA : AcessoSistema.ENTIDADE_COR.equals(responsavel.getTipoEntidade()) ? CodedValues.PAP_CORRESPONDENTE : AcessoSistema.ENTIDADE_ORG.equals(responsavel.getTipoEntidade()) ? CodedValues.PAP_ORGAO : AcessoSistema.ENTIDADE_SUP.equals(responsavel.getTipoEntidade()) ? CodedValues.PAP_SUPORTE : null;

        lstFuncAuditaveis.papCodigoOrigem = papelResponsavel;

        final String papelEntidade = AcessoSistema.ENTIDADE_CSE.equals(tipo) ? CodedValues.PAP_CONSIGNANTE : AcessoSistema.ENTIDADE_CSA.equals(tipo) ? CodedValues.PAP_CONSIGNATARIA : AcessoSistema.ENTIDADE_COR.equals(tipo) ? CodedValues.PAP_CORRESPONDENTE : AcessoSistema.ENTIDADE_ORG.equals(tipo) ? CodedValues.PAP_ORGAO : AcessoSistema.ENTIDADE_SUP.equals(tipo) ? CodedValues.PAP_SUPORTE : null;

        lstFuncAuditaveis.papCodigoDestino = papelEntidade;
        lstFuncAuditaveis.usuCodigoResponsavel = responsavel.getUsuCodigo();

        final String perCodigoResnp = findUsuarioPerfil(responsavel.getUsuCodigo(), responsavel);

        if (!TextHelper.isNull(perCodigoResnp)) {
            lstFuncAuditaveis.perCodigoResponsavel = perCodigoResnp;
        }

        List<TransferObject> retorno = new ArrayList<>();
        try {
            retorno = lstFuncAuditaveis.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
        }

        return retorno;
    }

    @Override
    public List<UsuarioTransferObject> lstUsuariosAuditores(String tipo, String codigoEntidade, Object stuCodigo, int offset, int size, AcessoSistema responsavel) throws UsuarioControllerException {
        final ListaUsuariosAuditoresQuery usuAuditListQuery = new ListaUsuariosAuditoresQuery();
        usuAuditListQuery.tipo = tipo;
        usuAuditListQuery.codigoEntidade = codigoEntidade;
        usuAuditListQuery.stuCodigo = stuCodigo;

        if (offset != -1) {
            usuAuditListQuery.firstResult = offset;
        }

        if (size != -1) {
            usuAuditListQuery.maxResults = size;
        }

        try {
            return usuAuditListQuery.executarDTO(UsuarioTransferObject.class);
        } catch (final HQueryException e) {
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
        }
    }

    @Override
    public int countUsuariosAuditores(String tipo, String codigoEntidade, Object stuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        final ListaUsuariosAuditoresQuery usuAuditListQuery = new ListaUsuariosAuditoresQuery();
        usuAuditListQuery.tipo = tipo;
        usuAuditListQuery.codigoEntidade = codigoEntidade;
        usuAuditListQuery.stuCodigo = stuCodigo;
        usuAuditListQuery.count = true;

        try {
            return usuAuditListQuery.executarContador();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, e);
        }
    }

    @Override
    public void updateFuncoesAuditaveis(List<String> funcoes, String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        // LOG Verificar log que está setando funções removidas/inseridas ou perfil alterado
        LogDelegate log = null;

        //verifica se entidade possui usuários auditores. só será permitido configuração de funções auditáveis se houver pelo menos um usuário auditor
        if (funcoes != null) {
            final ListaUsuariosAuditoresQuery usuAuditoresList = new ListaUsuariosAuditoresQuery();
            usuAuditoresList.tipo = tipo;
            usuAuditoresList.codigoEntidade = codigoEntidade;
            usuAuditoresList.stuCodigo = CodedValues.STU_ATIVO;

            try {
                final List<UsuarioTransferObject> auditoresList = usuAuditoresList.executarDTO(UsuarioTransferObject.class);

                if ((auditoresList == null) || auditoresList.isEmpty()) {
                    throw new UsuarioControllerException("mensagem.erro.entidade.deve.possuir.ao.menos.um.usuario.auditor.para.configurar.auditoria", responsavel);
                } else {
                    // confere se ao menos um usuário auditor possui e-mail cadastrado
                    boolean emailCheck = false;
                    for (final UsuarioTransferObject usuAudit : auditoresList) {
                        final UsuarioTransferObject usuTO = usuAudit;
                        if (!TextHelper.isNull(usuTO.getUsuEmail())) {
                            emailCheck = true;
                            break;
                        }
                    }

                    if (!emailCheck) {
                        throw new UsuarioControllerException("mensagem.erro.entidade.deve.possuir.ao.menos.um.usuario.auditor.com.email.configurado.para.configurar.auditoria", responsavel);
                    }
                }
            } catch (final HQueryException e) {
                throw new UsuarioControllerException("mensagem.erro.consultar.usuarios.auditores", responsavel, e);
            }
        }

        Collection<String> funcAuditOld = null;

        try {
            if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                funcAuditOld = FuncaoAuditavelCseHome.findFuncoesByCseCodigo(codigoEntidade);
                log = new LogDelegate(responsavel, Log.CONSIGNANTE, Log.UPDATE, Log.LOG_INFORMACAO);
                log.setConsignante(codigoEntidade);
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                funcAuditOld = FuncaoAuditavelOrgHome.findFuncoesByOrgCodigo(codigoEntidade);
                log = new LogDelegate(responsavel, Log.ORGAO, Log.UPDATE, Log.LOG_INFORMACAO);
                log.setOrgao(codigoEntidade);
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                funcAuditOld = FuncaoAuditavelCsaHome.findFuncoesByCsaCodigo(codigoEntidade);
                log = new LogDelegate(responsavel, Log.CONSIGNATARIA, Log.UPDATE, Log.LOG_INFORMACAO);
                log.setConsignataria(codigoEntidade);
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                funcAuditOld = FuncaoAuditavelCorHome.findFuncoesByCorCodigo(codigoEntidade);
                log = new LogDelegate(responsavel, Log.CORRESPONDENTE, Log.UPDATE, Log.LOG_INFORMACAO);
                log.setCorrespondente(codigoEntidade);
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                funcAuditOld = FuncaoAuditavelSupHome.findFuncoesByCseCodigo(codigoEntidade);
                log = new LogDelegate(responsavel, Log.CONSIGNANTE, Log.UPDATE, Log.LOG_INFORMACAO);
                log.setConsignante(codigoEntidade);
            }
        } catch (final FindException e) {
            LOG.error(e.getMessage(), e);
            throw new UsuarioControllerException("mensagem.erro.entidade.nao.encontrada", responsavel, e);
        }

        final List<String> diff = new ArrayList<>();
        final List<String> excluir = new ArrayList<>();

        for (final String funcaoOld : funcAuditOld) {
            if ((funcoes == null) || !funcoes.contains(funcaoOld)) {
                excluir.add(funcaoOld);
            }
        }

        if (funcoes != null) {
            for (final String funcaoCorrente : funcoes) {
                if (!funcAuditOld.contains(funcaoCorrente)) {
                    diff.add(funcaoCorrente);
                }
            }
        }

        try {
            if (!diff.isEmpty()) {
                createFuncaoAuditavel(diff, codigoEntidade, tipo);
                log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.configurando.auditoria.para.permissoes.arg0", responsavel, TextHelper.join(diff, ",")));
            }

            if (!excluir.isEmpty()) {
                removeFuncoesAuditaveis(excluir, codigoEntidade, tipo);
                log.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.removendo.configuracoes.auditoria.para.permissoes.arg0", responsavel, TextHelper.join(excluir, ",")));
            }
            log.write();
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    private void createFuncaoAuditavel(List<String> funcoes, String codigoEntidade, String tipo) throws UsuarioControllerException {
        for (final String funcao : funcoes) {
            try {
                if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                    FuncaoAuditavelCseHome.create(codigoEntidade, funcao);
                } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                    FuncaoAuditavelOrgHome.create(codigoEntidade, funcao);
                } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                    FuncaoAuditavelCsaHome.create(codigoEntidade, funcao);
                } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                    FuncaoAuditavelCorHome.create(codigoEntidade, funcao);
                } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                    FuncaoAuditavelSupHome.create(codigoEntidade, funcao);
                }
            } catch (final CreateException ex) {
                LOG.error(ex.getMessage(), ex);
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.configurar.auditoria.para.esta.entidade.erro.interno.arg0", (AcessoSistema) null, ex.getMessage());
            }
        }
    }

    private void removeFuncoesAuditaveis(List<String> funcoes, String codigoEntidade, String tipo) throws UsuarioControllerException {
        try {
            if (AcessoSistema.ENTIDADE_CSE.equals(tipo)) {
                final Collection<FuncaoAuditavelCse> funcAuditaveis = FuncaoAuditavelCseHome.findByCseCodigo(codigoEntidade);
                for (final FuncaoAuditavelCse funAudit : funcAuditaveis) {
                    if (funcoes.contains(funAudit.getFunCodigo())) {
                        AbstractEntityHome.remove(funAudit);
                    }
                }
            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                final Collection<FuncaoAuditavelOrg> funcAuditaveis = FuncaoAuditavelOrgHome.findByOrgCodigo(codigoEntidade);
                for (final FuncaoAuditavelOrg funAudit : funcAuditaveis) {
                    if (funcoes.contains(funAudit.getFunCodigo())) {
                        AbstractEntityHome.remove(funAudit);
                    }
                }
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo)) {
                final Collection<FuncaoAuditavelCsa> funcAuditaveis = FuncaoAuditavelCsaHome.findByCsaCodigo(codigoEntidade);
                for (final FuncaoAuditavelCsa funAudit : funcAuditaveis) {
                    if (funcoes.contains(funAudit.getFunCodigo())) {
                        AbstractEntityHome.remove(funAudit);
                    }
                }
            } else if (AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                final Collection<FuncaoAuditavelCor> funcAuditaveis = FuncaoAuditavelCorHome.findByCorCodigo(codigoEntidade);
                for (final FuncaoAuditavelCor funAudit : funcAuditaveis) {
                    if (funcoes.contains(funAudit.getFunCodigo())) {
                        AbstractEntityHome.remove(funAudit);
                    }
                }
            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                final Collection<FuncaoAuditavelSup> funcAuditaveis = FuncaoAuditavelSupHome.findByCseCodigo(codigoEntidade);
                for (final FuncaoAuditavelSup funAudit : funcAuditaveis) {
                    if (funcoes.contains(funAudit.getFunCodigo())) {
                        AbstractEntityHome.remove(funAudit);
                    }
                }
            }
        } catch (FindException | RemoveException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.remover.configuracoes.auditoria.para.esta.entidade.erro.interno.arg0", (AcessoSistema) null, ex.getMessage());
        }

    }

    /**
     * gera novas senhas para usuários servidores ativos ou recém criados, de acordo com param.
     * de sistema 348, e gera arquivo compactado protegido por senha com usuários alterados.
     * @throws UsuarioControllerException
     * @return a senha plana do arquivo ZIP com os dados para exportação
     */
    @Override
    public String gerarSenhasUsuServidores(AcessoSistema responsavel) throws UsuarioControllerException {
        final String dia = DateHelper.format(new java.util.Date(), "dd-MM-yyyy");

        //Diretório raiz de arquivos eConsig
        final String absolutePath = ParamSist.getDiretorioRaizArquivos();

        final String pathConf = absolutePath + File.separatorChar + "conf";
        final String pathSaida = absolutePath + File.separatorChar + "senhaservidores";

        final File dirArqSenhas = new File(pathSaida);
        final File[] arqSenhas = dirArqSenhas.listFiles();

        // deleta qualquer arquivo de senhas geradas anteriormente no diretório
        if (arqSenhas != null) {
            for (final File arquivo : arqSenhas) {
                arquivo.delete();
            }
        }

        final Object paramValue = ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_SERVIDOR, responsavel);
        final int tamanhoSenha = paramValue != null ? Integer.parseInt(paramValue.toString()) : 8;

        // Arquivos de configuração para geração de senhas de servidores
        final String nomeArqConfSaida = "senhas_servidores_saida.xml";
        final String nomeArqConfTradutor = "senhas_servidores_tradutor.xml";

        //Arquivos de configuração default
        final String nomeArqConfSaidaDefault = pathConf + File.separatorChar + nomeArqConfSaida;
        final String nomeArqConfTradutorDefault = pathConf + File.separatorChar + nomeArqConfTradutor;

        if (!new File(nomeArqConfSaidaDefault).exists() || !new File(nomeArqConfTradutorDefault).exists()) {
            throw new UsuarioControllerException("mensagem.erro.arquivos.configuracao.layout.geracao.novas.senhas.ausentes.ou.incorretos", responsavel);
        }

        final boolean todosUsuAtivos = ParamSist.getBoolParamSist(CodedValues.TPC_GERAR_SENHA_TODOS_USU_SER_ATIVOS, responsavel);

        // define se o filtro é para todos usuários ativos ou apenas para os novos usuários
        String arqPrefix = null;
        String harObs = null;
        if (todosUsuAtivos) {
            harObs = ApplicationResourcesHelper.getMessage("mensagem.erro.novas.senhas.geradas.para.todos.servidores", responsavel);
            arqPrefix = "usuarios_" + ApplicationResourcesHelper.getMessage("rotulo.servidor.plural", responsavel) + "_ativos";
        } else {
            harObs = ApplicationResourcesHelper.getMessage("mensagem.erro.novas.senhas.geradas.para.novos.usuarios.servidores", responsavel);
            arqPrefix = "novos_usuarios_" + ApplicationResourcesHelper.getMessage("rotulo.servidor.plural", responsavel);
        }

        // Substitui caracteres inválidos em nomes de arquivos:  / \ : * ? " < > |
        arqPrefix = arqPrefix.replaceAll("[/|\\\\|:|*|?|\"|<|>|\\|| ]", "_");

        final String nomeArqSaida = pathSaida + File.separator + "novas_senhas_" + arqPrefix + "_" + dia + ".txt";

        //escritor temporário que armazenará os dados da linha da tabela usuário e
        //processar a geração da nova senha
        final HashMap<String, Object> camposLinha = new HashMap<>();
        EscritorMemoria escritor = new EscritorMemoria(camposLinha);

        EscritorArquivoTexto escritorFinal = null;
        try {
            escritorFinal = new EscritorArquivoTexto(nomeArqConfSaidaDefault, nomeArqSaida);
        } catch (final Exception fex) {
            LOG.error(fex.getMessage(), fex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, fex);
        }

        Tradutor tradutor = null;
        try {
            final ListaUsuarioServidorNovaSenhaQuery query = new ListaUsuarioServidorNovaSenhaQuery();
            query.todosUsuAtivos = todosUsuAtivos;
            final List<TransferObject> usuServidoresNovaSenha = query.executarDTO();

            // Cache usado para otimizar
            final HashMap<String, TransferObject> usuariosMap = new HashMap<>();
            for (final TransferObject usuario : usuServidoresNovaSenha) {
                usuariosMap.put((String) usuario.getAttribute("USU_CODIGO"), usuario);
            }

            final Leitor leitor = new LeitorListTO(usuServidoresNovaSenha);
            tradutor = new Tradutor(nomeArqConfTradutorDefault, leitor, escritor);
            tradutor.iniciaTraducao(false);
            escritorFinal.iniciaEscrita();

            boolean temRegistro = false;
            while (tradutor.traduzProximo()) {
                temRegistro = true;
                // gera a nova senha para a entidade usuário
                final boolean senhaNumerica = ParamSist.paramEquals(CodedValues.TPC_SENHA_CONS_SERVIDOR_SOMENTE_NUMERICA, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
                final String novaSenha = senhaNumerica ? GeradorSenhaUtil.getPasswordNumber(tamanhoSenha, responsavel) : GeradorSenhaUtil.getPassword(tamanhoSenha, AcessoSistema.ENTIDADE_SER, responsavel);

                camposLinha.put("USU_NOVA_SENHA", novaSenha);

                if (TextHelper.isNull(camposLinha.get("USU_CODIGO"))) {
                    LOG.error("Campo USU_CODIGO obrigatório no XML tradutor da geração de arquivo de exportação de senhas de usuários " + ApplicationResourcesHelper.getMessage("rotulo.servidor.plural", responsavel) + ".");
                    throw new UsuarioControllerException("mensagem.erro.arquivo.configuracao.exportacao.novas.senhas.usuarios.servidores.incorreto", responsavel);
                }

                final String usuCodigo = (String) camposLinha.get("USU_CODIGO");
                final TransferObject usuTo = usuariosMap.get(usuCodigo);
                final String senhaNovaCrypt = SenhaHelper.criptografarSenha((String) usuTo.getAttribute(Columns.USU_LOGIN), novaSenha, true, responsavel);

                UsuarioHome.updateUsuNovaSenha(senhaNovaCrypt, usuCodigo);

                final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                ocorrencia.setUsuCodigo(usuCodigo);
                ocorrencia.setTocCodigo(CodedValues.TOC_GERACAO_NOVA_SENHA);
                ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage(todosUsuAtivos ? "mensagem.informacao.geracao.senhas.para.servidores.ativos" : "mensagem.informacao.geracao.senhas.para.novos.usuarios.servidores", responsavel));
                ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

                createOcorrenciaUsuario(ocorrencia, responsavel);

                final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.GERAR_NOVA_SENHA, Log.LOG_INFORMACAO);
                log.setUsuario(usuCodigo);
                log.write();

                escritorFinal.escreve(camposLinha);

                // limpa o escritor para os dados da próxima linha
                escritor.iniciaEscrita();
            }

            if (temRegistro) {
                escritorFinal.encerraEscrita();
                escritorFinal = null;
                escritor.encerraEscrita();
                escritor = null;
                tradutor.encerraTraducao();
                tradutor = null;

                // gera histórico do arquivo de senhas de usuário servidores
                final String harResultado = CodedValues.STS_ATIVO.toString();
                final TipoArquivoEnum tipoArquivo = TipoArquivoEnum.ARQUIVO_SENHAS_SERVIDORES;
                historicoArquivoController.createHistoricoArquivo(null, null, tipoArquivo, nomeArqSaida, harObs, null, null, harResultado, responsavel);

                // comprime e encripta arquivo gerado para exportação
                final File arqNovasSenhas = new File(nomeArqSaida);
                final File arqComprimido = new File(pathSaida + File.separator + "novas_senhas_" + arqPrefix + "_" + dia + ".zip");
                final String senhaZip = GeradorSenhaUtil.getPassword(tamanhoSenha, AcessoSistema.ENTIDADE_SER, responsavel);
                FileHelper.zipAndEncrypt(arqNovasSenhas, arqComprimido, senhaZip);
                arqNovasSenhas.delete();

                return senhaZip;
            } else {
                throw new UsuarioControllerException("mensagem.nenhum.usuario.servidor.encontrado", responsavel);
            }

        } catch (final UpdateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.alterar.usuario", responsavel, ex);
        } catch (ParserException | IOException | LogControllerException | HistoricoArquivoControllerException | DAOException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        } finally {
            try {
                if (escritorFinal != null) {
                    escritorFinal.encerraEscrita();
                }
                if (escritor != null) {
                    escritor.encerraEscrita();
                }
                if (tradutor != null) {
                    tradutor.encerraTraducao();
                }
            } catch (final ParserException ex) {
                LOG.error(ex.getMessage(), ex);
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
            }
        }
    }

    /**
     * Ativar as senhas geradas automaticamente e armazenadas no campo USU_NOVA_SENHA, tornando-as a senha oficial dos
     * respectivos usuários servidores
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void ativarSenhasUsuServidores(AcessoSistema responsavel) throws UsuarioControllerException {
        final ParamSist ps = ParamSist.getInstance();
        // Diretório raiz de arquivos eConsig
        final String absolutePath = ParamSist.getDiretorioRaizArquivos();

        final String pathArquivos = absolutePath + File.separatorChar + "senhaservidores";

        final File dirArqSenhas = new File(pathArquivos);
        final File[] arqSenhas = dirArqSenhas.listFiles();

        if ((arqSenhas == null) || (arqSenhas.length == 0)) {
            throw new UsuarioControllerException("mensagem.erro.nenhum.arquivo.com.informacao.senhas.encontrado", responsavel);
        }

        final ListaUsuariosComNovaSenhaQuery servidoresList = new ListaUsuariosComNovaSenhaQuery();

        int diasParaExpiracaoNovaSenha = 0;
        try {
            diasParaExpiracaoNovaSenha = Integer.parseInt(ps.getParam(CodedValues.TPC_DIAS_EXPIRACAO_NOVA_SENHA_SERVIDOR, responsavel).toString());
        } catch (final Exception ex) {
            diasParaExpiracaoNovaSenha = 0;
        }

        try {
            final List<TransferObject> usuTo = servidoresList.executarDTO();

            for (final TransferObject servidorTo : usuTo) {
                final String usuCodigo = (String) servidorTo.getAttribute(Columns.USU_CODIGO);

                // configura o dia para expiração da senha, de acordo com parâmetro.
                java.util.Date usuDataExpSenha = null;
                if (diasParaExpiracaoNovaSenha > 0) {
                    usuDataExpSenha = DateHelper.addDays(DateHelper.getSystemDatetime(), diasParaExpiracaoNovaSenha);
                } else {
                    usuDataExpSenha = DateHelper.getSystemDatetime();
                }

                UsuarioHome.ativaUsuNovaSenha(usuDataExpSenha, usuCodigo);

                final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                ocorrencia.setUsuCodigo(usuCodigo);
                ocorrencia.setTocCodigo(CodedValues.TOC_ATIVAR_NOVA_SENHA);
                ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.informacao.ativacao.senha.para.usuario", responsavel));
                ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

                createOcorrenciaUsuario(ocorrencia, responsavel);

                final LogDelegate log = new LogDelegate(responsavel, Log.USUARIO, Log.ATIVAR_NOVA_SENHA, Log.LOG_INFORMACAO);
                log.setUsuario(usuCodigo);
                log.write();
            }

            if (arqSenhas != null) {
                for (final File arquivo : arqSenhas) {
                    arquivo.delete();
                }
            }
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.listar.usuarios.servidores", responsavel, ex);
        } catch (final UpdateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.interno.atualizar.usuario", responsavel, ex);
        } catch (final LogControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public List<TransferObject> findFuncaoAuditavelPorEntidade(String codigoEntidade, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final List<TransferObject> retorno = new ArrayList<>();
            if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade)) {
                final Collection<FuncaoAuditavelCse> colecao = FuncaoAuditavelCseHome.findByCseCodigo(codigoEntidade);
                for (final FuncaoAuditavelCse funcaoAuditavel : colecao) {
                    final TransferObject to = new CustomTransferObject();
                    final Funcao funcao = FuncaoHome.findByPrimaryKey(funcaoAuditavel.getFuncao().getFunCodigo());
                    to.setAttribute(Columns.FUN_CODIGO, funcao.getFunCodigo());
                    to.setAttribute(Columns.FUN_DESCRICAO, funcao.getFunDescricao());
                    retorno.add(to);
                }

            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade)) {
                final Collection<FuncaoAuditavelCsa> colecao = FuncaoAuditavelCsaHome.findByCsaCodigo(codigoEntidade);
                for (final FuncaoAuditavelCsa funcaoAuditavel : colecao) {
                    final TransferObject to = new CustomTransferObject();
                    final Funcao funcao = FuncaoHome.findByPrimaryKey(funcaoAuditavel.getFuncao().getFunCodigo());
                    to.setAttribute(Columns.FUN_CODIGO, funcao.getFunCodigo());
                    to.setAttribute(Columns.FUN_DESCRICAO, funcao.getFunDescricao());
                    retorno.add(to);
                }

            } else if (AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
                final Collection<FuncaoAuditavelCor> colecao = FuncaoAuditavelCorHome.findByCorCodigo(codigoEntidade);
                for (final FuncaoAuditavelCor funcaoAuditavel : colecao) {
                    final TransferObject to = new CustomTransferObject();
                    final Funcao funcao = FuncaoHome.findByPrimaryKey(funcaoAuditavel.getFuncao().getFunCodigo());
                    to.setAttribute(Columns.FUN_CODIGO, funcao.getFunCodigo());
                    to.setAttribute(Columns.FUN_DESCRICAO, funcao.getFunDescricao());
                    retorno.add(to);
                }

            } else if (AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade)) {
                final Collection<FuncaoAuditavelOrg> colecao = FuncaoAuditavelOrgHome.findByOrgCodigo(codigoEntidade);
                for (final FuncaoAuditavelOrg funcaoAuditavel : colecao) {
                    final TransferObject to = new CustomTransferObject();
                    final Funcao funcao = FuncaoHome.findByPrimaryKey(funcaoAuditavel.getFuncao().getFunCodigo());
                    to.setAttribute(Columns.FUN_CODIGO, funcao.getFunCodigo());
                    to.setAttribute(Columns.FUN_DESCRICAO, funcao.getFunDescricao());
                    retorno.add(to);
                }

            } else if (AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
                final Collection<FuncaoAuditavelSup> colecao = FuncaoAuditavelSupHome.findByCseCodigo(codigoEntidade);
                for (final FuncaoAuditavelSup funcaoAuditavel : colecao) {
                    final TransferObject to = new CustomTransferObject();
                    final Funcao funcao = FuncaoHome.findByPrimaryKey(funcaoAuditavel.getFuncao().getFunCodigo());
                    to.setAttribute(Columns.FUN_CODIGO, funcao.getFunCodigo());
                    to.setAttribute(Columns.FUN_DESCRICAO, funcao.getFunDescricao());
                    retorno.add(to);
                }

            }

            return retorno;
        } catch (final FindException e) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.recuperar.funcoes.auditaveis", responsavel);
        }
    }

    @Override
    public void bloqueiaUsuariosFimVigencia(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuarioFimVigenciaQuery query = new ListaUsuarioFimVigenciaQuery();
            final List<TransferObject> lista = query.executarDTO();

            for (final TransferObject to : lista) {
                final String usuCodigo = to.getAttribute(Columns.USU_CODIGO).toString();

                // Altera status do usuário para bloqueado automaticamente
                final UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
                usuario.setStuCodigo(CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE_FIM_VIGENCIA);
                usuario.setUsuTipoBloq(ApplicationResourcesHelper.getMessage("mensagem.usuario.bloqueado.fim.vigencia", responsavel));

                // Grava ocorrência de bloqueio automático do usuário por fim de vigencia
                final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                ocorrencia.setUsuCodigo(usuCodigo);
                ocorrencia.setTocCodigo(CodedValues.TOC_BLOQUEIO_USUARIO_FIM_VIGENCIA);
                ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo() != null ? responsavel.getUsuCodigo() : AcessoSistema.getAcessoUsuarioSistema().getUsuCodigo());
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.bloqueio.automatico.usuario.por.fim.vig", responsavel));
                ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

                updateUsuario(usuario, ocorrencia, responsavel);
            }

        } catch (final HQueryException e) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.bloquear.usuarios.por.fim.vigencia", responsavel, e);
        } catch (final UsuarioControllerException e) {
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.bloquear.usuarios.por.fim.vigencia", responsavel, e);
        }
    }

    @Override
    public String gerarChaveSessaoUsuario(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final UsuarioChaveSessao usuToken = UsuarioChaveSessaoHome.findByPrimaryKey(usuCodigo);

            if (usuToken != null) {
                return UsuarioChaveSessaoHome.updateToken(usuCodigo);
            } else {
                final UsuarioChaveSessao novoToken = UsuarioChaveSessaoHome.create(usuCodigo);
                return novoToken.getUcsToken();
            }
        } catch (final FindException e) {
            UsuarioChaveSessao chaveDispositivo = null;
            try {
                chaveDispositivo = UsuarioChaveSessaoHome.create(usuCodigo);
            } catch (final CreateException e1) {
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException("mensagem.erro.token.usuario.criar", responsavel, e);
            }
            return chaveDispositivo.getUcsToken();
        } catch (CreateException | UpdateException e) {
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.token.usuario.criar", responsavel, e);
        }
    }

    @Override
    public void cadastroDeviceToken(String usuCodigo, String tdiCodigo, String deviceToken, AcessoSistema responsavel) throws UsuarioControllerException {
        UsuarioChaveDispositivo device;
        try {
            device = UsuarioChaveDispositivoHome.findByPrimaryKey(usuCodigo);
        } catch (final FindException e) {
            device = null;
        }

        try {
            if (device != null) {
                UsuarioChaveDispositivoHome.update(usuCodigo, tdiCodigo, deviceToken);
            } else {
                UsuarioChaveDispositivoHome.create(usuCodigo, tdiCodigo, deviceToken);
            }
        } catch (final UpdateException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.chave.dispositivo.atualizar", (AcessoSistema) null);
        } catch (final CreateException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.chave.dispositivo.criar", (AcessoSistema) null);
        }
    }

    @Override
    public String findDeviceToken(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final UsuarioChaveDispositivo device = UsuarioChaveDispositivoHome.findByPrimaryKey(usuCodigo);

            if (device != null) {
                return device.getUcdToken();
            }

        } catch (final FindException e) {
        }

        return null;
    }

    /**
     * Recupera um token de acesso
     * @param token
     * @return
     * @throws FindException Se não achou o token
     */
    @Override
    public UsuarioChaveSessao findUsuarioChaveSessao(String token) throws FindException {
        return UsuarioChaveSessaoHome.findByChaveSessao(token);
    }

    /**
     * Invalida/Apaga um token de acesso
     *
     * @param token
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public void deleteUsuarioChaveSessao(String usuCodigo) throws UsuarioControllerException {
        try {
            UsuarioChaveSessaoHome.delete(usuCodigo);
        } catch (final FindException e) {
            throw new UsuarioControllerException("mensagem.erro.token.usuario.invalidar", (AcessoSistema) null);
        } catch (final RemoveException e) {
            LOG.error(e.getMessage(), e);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.token.usuario.invalidar", (AcessoSistema) null);
        }
    }

    /**
     * Recupera o token e verifica se este já está expirado ou não. Se estiver expirado, apaga o token.
     * Qualquer exceção é para negar acesso.
     * @param token
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public UsuarioChaveSessao validateToken(String token) throws UsuarioControllerException {
        UsuarioChaveSessao chave;
        try {
            chave = this.findUsuarioChaveSessao(token);
        } catch (FindException e) {
            throw new UsuarioControllerException("mensagem.erro.token.expirado",
                    AcessoSistema.getAcessoUsuarioSistema());
        }

        if (isExpiredToken(chave)) {
            throw new UsuarioControllerException("mensagem.erro.token.expirado",
                    AcessoSistema.getAcessoUsuarioSistema());
        }
        
        return chave;
    }

    private boolean isExpiredToken(UsuarioChaveSessao chave) {
        Integer tempoExpiracaoToken = 600;
        String param = (String) ParamSist.getInstance().getParam(CodedValues.TPC_TEMPO_EXPIRACAO_TOKEN_ACESSO,
                AcessoSistema.getAcessoUsuarioSistema());
        
        if (!TextHelper.isNull(param)) {
            try {
                tempoExpiracaoToken = Integer.parseInt(param.toString());
            } catch (NumberFormatException e) {
            }
        }

        Calendar dataExpiracao = Calendar.getInstance();
        dataExpiracao.setTime(chave.getUcsDataCriacao());
        dataExpiracao.add(Calendar.SECOND, tempoExpiracaoToken);
        Calendar now = Calendar.getInstance();
        if (now.compareTo(dataExpiracao) > 0) {
            try {
                this.deleteUsuarioChaveSessao(chave.getUsuCodigo());
            } catch (UsuarioControllerException e) {
            }
            return true;
        }

        return false;
    }

    /**
     * Altera/Insere a imagem do perfil de um usuário
     * @throws UsuarioControllerException
     */
    @Override
    public void insereAlteraImagemUsuario(String usuCodigo, byte[] imagem, AcessoSistema responsavel) throws UsuarioControllerException {

        ArquivoUsuario arquivo;
        // Verifica o tamanho da imagem
        if (imagem.length > (5 * 1014 * 1024)) {
            throw new UsuarioControllerException("mensagem.erro.imagem.excede.tamanho.maximo", responsavel);
        }

        // Tenta recuperar a imagem corrente
        Collection<ArquivoUsuario> lstArqs = null;
        try {
            lstArqs = ArquivoUsuarioHome.findByUsuCodigoTipoArquivo(usuCodigo, TipoArquivoEnum.ARQUIVO_IMAGEM_PERFIL_USUARIO.getCodigo());
        } catch (final FindException e) {
        }
        if ((lstArqs != null) && (lstArqs.size() > 0)) {
            // Reutiliza o arquivo existente
            arquivo = (ArquivoUsuario) lstArqs.toArray()[0];
            arquivo.setAusConteudo(imagem);
            arquivo.setAusDataCriacao(new java.util.Date());
            try {
                AbstractEntityHome.update(arquivo);
            } catch (final UpdateException e) {
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException("mensagem.erro.gravar.imagem.usuario", responsavel);
            }
        } else {
            // Cria um novo arquivo
            try {
                arquivo = ArquivoUsuarioHome.create(TipoArquivoHome.findByPrimaryKey(TipoArquivoEnum.ARQUIVO_IMAGEM_PERFIL_USUARIO.getCodigo()), usuCodigo, imagem);
            } catch (CreateException | FindException e) {
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException("mensagem.erro.gravar.imagem.usuario", responsavel);
            }
        }

        // Cria ocorrência de usuário de alteração da imagem
        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
        ocorrencia.setUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_USUARIO);
        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.imagem", responsavel));
        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
        createOcorrenciaUsuario(ocorrencia, responsavel);

    }

    @Override
    public Map<String, Object> primeiroAcesso(String id, String orgCodigo, String otp, AcessoSistema responsavel) throws UsuarioControllerException {
        // verifica se sistema valida primeiro acesso
        if (!ParamSist.getBoolParamSist(CodedValues.TPC_VALIDA_OTP_PRIMEIRO_ACESSO_USUARIO, responsavel)) {
            throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
        }

        if (TextHelper.isNull(id)) {
            throw new UsuarioControllerException("mensagem.informe.servidor.cpf", responsavel);
        }

        final boolean omiteCpf = ParamSist.getBoolParamSist(CodedValues.TPC_OMITE_CPF_SERVIDOR, responsavel);
        final Map<String, Object> retorno = new HashMap<>();
        String cpf = null;
        String serEmail = null;
        String serCelular = null;
        try {
            List<String> lstOrgId = null;
            if (!TextHelper.isNull(orgCodigo)) {
                lstOrgId = new ArrayList<>();
                lstOrgId.add(orgCodigo);
            }

            List<TransferObject> lstRegistroServidores = null;

            if (omiteCpf) {
                lstRegistroServidores = servidorController.lstRegistroServidorPorEmail(id, lstOrgId, AcessoSistema.getAcessoUsuarioSistema());
                cpf = servidorController.findServidorByRseCodigo(lstRegistroServidores.get(0).getAttribute(Columns.RSE_CODIGO).toString(), responsavel).getSerCpf();
            } else {
                lstRegistroServidores = servidorController.lstRegistroServidorPorCpf(id, lstOrgId, AcessoSistema.getAcessoUsuarioSistema());
                cpf = id;
            }

            if ((lstRegistroServidores != null) && !lstRegistroServidores.isEmpty()) {
                // inclusão de parâmetros de definição do tamanho da senha de servidor para serem usados na tela de primeiro acesso
                int tamMinSenhaServidor = 6;
                int tamMaxSenhaServidor = 8;
                try {
                    tamMinSenhaServidor = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MIN_SENHA_SERVIDOR, responsavel)) ? Integer.parseInt(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MIN_SENHA_SERVIDOR, responsavel).toString()) : 6;
                } catch (final Exception ex) {
                    tamMinSenhaServidor = 6;
                }
                try {
                    tamMaxSenhaServidor = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_SERVIDOR, responsavel)) ? Integer.parseInt(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_SERVIDOR, responsavel).toString()) : 8;
                } catch (final Exception ex) {
                    tamMaxSenhaServidor = 8;
                }
                retorno.put("tamMinSenhaServidor", tamMinSenhaServidor);
                retorno.put("tamMaxSenhaServidor", tamMaxSenhaServidor);
                if (!TextHelper.isNull(otp)) {
                    // se foi informado OTP, verifica se usuário possui permissão de cadastrar email e/ou celular
                    // para poder ser direcionado para interface de preenchimento destes dados.
                    try {
                        if (UsuarioHelper.primeiroAcessoSistema(cpf, lstRegistroServidores, null)) {
                            // verifica se usuário pode cadastrar email e/ou telefone
                            boolean usuPodeCadTelEmail = false;
                            boolean otpValido = false;
                            String usuCodigo = null;
                            outer: for (final TransferObject rse : lstRegistroServidores) {
                                final List<TransferObject> lstUsuResult = lstUsuariosSer(cpf, (String) rse.getAttribute(Columns.RSE_MATRICULA), (String) rse.getAttribute(Columns.EST_IDENTIFICADOR), (String) rse.getAttribute(Columns.ORG_IDENTIFICADOR), responsavel);
                                for (final TransferObject usuTO : lstUsuResult) {
                                    usuCodigo = (String) usuTO.getAttribute(Columns.USU_CODIGO);
                                    final String otpContraCheque = (String) usuTO.getAttribute(Columns.USU_NOVA_SENHA);
                                    if (TextHelper.isNull(otpContraCheque)) {
                                        continue;
                                    }

                                    // valida OTP do contracheque na base com o informado pelo usuário
                                    if (!JCrypt.verificaSenha(otp, otpContraCheque)) {
                                        // caso não tenha dado match, pode ser o otp de outra matrícula deste servidor. continua verificação então.
                                        continue;
                                    } else {
                                        otpValido = true;
                                        usuPodeCadTelEmail = usuarioTemPermissao(usuCodigo, CodedValues.FUN_EDT_SERVIDOR, AcessoSistema.ENTIDADE_SER, responsavel);
                                        final ServidorTransferObject serTO = servidorController.findServidor((String) rse.getAttribute(Columns.SER_CODIGO), responsavel);
                                        serEmail = serTO.getSerEmail();
                                        serCelular = serTO.getSerCelular();
                                        break outer;
                                    }
                                }

                            }

                            if (!otpValido) {
                                throw new UsuarioControllerException("mensagem.senha.servidor.otp.invalido", responsavel);
                            }

                            if (usuPodeCadTelEmail) {
                                retorno.put("usuCodigo", usuCodigo);
                                //Geração de token de fluxo de caso de uso a ser confirmado pela tela de retorno ao cliente
                                final String token = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);
                                retorno.put("token", token);

                                final UsuarioTransferObject usuTO = new UsuarioTransferObject(usuCodigo);
                                usuTO.setUsuOtpChaveSeguranca(token);
                                usuTO.setUsuCPF(cpf);
                                updateUsuario(usuTO, null, null, null, AcessoSistema.ENTIDADE_SER, null, null, responsavel);

                                retorno.put("email", serEmail);
                                retorno.put("telefone", serCelular);

                                return retorno;
                            } else {
                                throw new UsuarioControllerException("mensagem.erro.servidor.nao.autorizado", responsavel);
                            }

                        } else {
                            throw new UsuarioControllerException("mensagem.usuario.possui.cadastro.ativo", responsavel);
                        }
                    } catch (final ViewHelperException qex) {
                        LOG.error(qex.getMessage(), qex);
                        throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
                    }
                } else {
                    // se não foi informado otp, verifica se usuário possui email e/ou celular cadastrado
                    // para poder enviar um novo otp gerado.
                    boolean temCelular = false;
                    boolean temEmail = false;
                    TransferObject rseSelecionado = null;
                    for (final TransferObject rse : lstRegistroServidores) {
                        final RegistroServidorTO rseTO = servidorController.findRegistroServidor((String) rse.getAttribute(Columns.RSE_CODIGO), responsavel);
                        final ServidorTransferObject serTO = servidorController.findServidor(rseTO.getSerCodigo(), responsavel);
                        final List<TransferObject> lstUsuResult = lstUsuariosSer(cpf, (String) rse.getAttribute(Columns.RSE_MATRICULA), (String) rse.getAttribute(Columns.EST_IDENTIFICADOR), (String) rse.getAttribute(Columns.ORG_IDENTIFICADOR), responsavel);
                        if (!TextHelper.isNull(serTO.getSerCelular()) && !lstUsuResult.isEmpty()) {
                            temCelular = true;
                            rseSelecionado = rse;
                            serEmail = serTO.getSerEmail();
                            serCelular = serTO.getSerCelular();
                            break;
                        }
                        if (!TextHelper.isNull(serTO.getSerEmail()) && !lstUsuResult.isEmpty()) {
                            temEmail = true;
                            rseSelecionado = rse;
                            serEmail = serTO.getSerEmail();
                            serCelular = serTO.getSerCelular();
                            break;
                        }
                    }

                    if (!temCelular && !temEmail) {
                        throw new UsuarioControllerException("mensagem.senha.servidor.otp.erro.email.celular.invalido", responsavel);
                    }

                    try {
                        if (UsuarioHelper.primeiroAcessoSistema(cpf, lstRegistroServidores, null)) {
                            final List<TransferObject> lstUsuResult = lstUsuariosSer(cpf, (String) rseSelecionado.getAttribute(Columns.RSE_MATRICULA), (String) rseSelecionado.getAttribute(Columns.EST_IDENTIFICADOR), (String) rseSelecionado.getAttribute(Columns.ORG_IDENTIFICADOR), responsavel);
                            final String usuCodigo = (String) lstUsuResult.get(0).getAttribute(Columns.USU_CODIGO);
                            final String token = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);

                            final UsuarioTransferObject usuTO = new UsuarioTransferObject(usuCodigo);
                            usuTO.setUsuOtpChaveSeguranca(token);
                            usuTO.setUsuCPF(cpf);
                            updateUsuario(usuTO, null, null, null, AcessoSistema.ENTIDADE_SER, null, null, responsavel);

                            // Envia OTP para usuário
                            enviaOTPServidor(usuCodigo, token, null, null, AcessoSistema.getAcessoUsuarioSistema());
                            retorno.put("usuCodigo", usuCodigo);

                            retorno.put("token", token);
                            retorno.put("email", serEmail);
                            retorno.put("telefone", serCelular);

                            return retorno;
                        } else {
                            throw new UsuarioControllerException("mensagem.usuario.possui.cadastro.ativo", responsavel);
                        }
                    } catch (final ViewHelperException e) {
                        LOG.error(e.getMessage(), e);
                        throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
                    }
                }
            } else {
                throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", AcessoSistema.getAcessoUsuarioSistema());
            }
        } catch (final ServidorControllerException ex) {
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public void enviaOTPServidor(String usuCodigo, String chaveSenha, String emailOpcional, String telefoneOpcional, AcessoSistema responsavel) throws UsuarioControllerException {
        enviaOTPServidor(usuCodigo, chaveSenha, emailOpcional, telefoneOpcional, true, false, false, false, responsavel);
    }

    @Override
    public void enviaOTPServidor(String usuCodigo, String chaveSenha, String emailOpcional, String telefoneOpcional, boolean fluxoMobile, boolean fluxoAutoDesbloqueio, boolean enviaOtpEmail, boolean enviaOtpCelular, AcessoSistema responsavel) throws UsuarioControllerException {
        // Para uso do portal, não precisa validar primeiro acesso, visto que será acessado sempre usando OTP
        // ATENÇÂO: Fluxo do portal não valida alguns dados
        if (fluxoMobile) {
            final boolean primeiroAcessoOTP = ParamSist.getBoolParamSist(CodedValues.TPC_VALIDA_OTP_PRIMEIRO_ACESSO_USUARIO, responsavel);
            if (!primeiroAcessoOTP) {
                throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
            }
        }

        // Senha numérica com 6 dígitos
        final String otp = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);

        String email = emailOpcional;
        String telefone = telefoneOpcional;
        String serNome = "";

        // Buscar usuário através do usuCodigo passado
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        final Usuario usuarioBean = findUsuarioBean(usuario, AcessoSistema.ENTIDADE_SER);

        if (usuarioBean == null) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
        }

        try {
            final UsuarioSer usuarioSer = UsuarioSerHome.findByUsuCodigo(usuCodigo);
            final String serCodigo = usuarioSer.getServidor().getSerCodigo();
            final ServidorTransferObject servidor = servidorController.findServidor(serCodigo, responsavel);

            if (servidor == null) {
                throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", responsavel);
            }

            serNome = servidor.getSerNome();

            // Se possuir email cadastrado, utiliza cadastrado
            // ATENÇÂO: O portal não utiliza email
            if (fluxoMobile && !TextHelper.isNull(servidor.getSerEmail())) {
                email = servidor.getSerEmail();
            }
            // Se possuir telefone cadastrado, utiliza cadastrado
            if (!TextHelper.isNull(servidor.getSerCelular())) {
                telefone = servidor.getSerCelular();
            }

        } catch (ServidorControllerException | FindException e) {
            throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", responsavel);
        }

        // ATENÇÂO: Para uso do portal, não precisa validar primeiro acesso, visto que será acessado sempre usando OTP
        if (fluxoMobile) {

            // Valida se é primeiro acesso do usuário
            if (!TextHelper.isNull(usuarioBean.getUsuDataUltAcesso())) {
                throw new UsuarioControllerException("mensagem.usuario.possui.cadastro.ativo", responsavel);
            }

            // Valida se o REST primeiroAcesso (DESENV-6371) foi chamado anteriormente
            if (TextHelper.isNull(chaveSenha) || !chaveSenha.equalsIgnoreCase(usuarioBean.getUsuOtpChaveSeguranca())) {
                throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
            }
        }

        // Criptografa OTP antes de salvar no usuário
        final String otpCrypt = SenhaHelper.criptografarSenha(usuarioBean.getUsuLogin(), otp, true, responsavel);

        // Salva OTP gerado no campo provisório USU_CHAVE_VALIDACAO_TOTP
        usuario = this.findUsuario(usuario, AcessoSistema.ENTIDADE_SER, responsavel);
        usuario.setUsuOtpCodigo(otpCrypt);
        usuario.setUsuOtpDataCadastro(DateHelper.getSystemDatetime());

        // Cria ocorrência
        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
        ocorrencia.setUsuCodigo(usuCodigo);
        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setTocCodigo(CodedValues.TOC_INCLUSAO_OTP_USUARIO);
        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.inclusao.otp.usuario", responsavel));
        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

        // Salva OTP no usuário
        updateUsuario(usuario, ocorrencia, responsavel);

        if (!fluxoAutoDesbloqueio) {
            if (!TextHelper.isNull(telefone)) {
                try {
                    EnviaSMSHelper.enviarSMSOTP(telefone, otp, responsavel);
                } catch (final ZetraException e) {
                    if (!TextHelper.isNull(email)) {
                        try {
                            EnviaEmailHelper.enviarEmailOTPServidor(serNome, email, otp, responsavel);
                        } catch (final ViewHelperException ex) {
                            throw new UsuarioControllerException("mensagem.erro.sms.ou.email.enviar", responsavel, ex);
                        }
                    } else {
                        throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, e);
                    }
                }
            } else if (!TextHelper.isNull(email)) {
                try {
                    EnviaEmailHelper.enviarEmailOTPServidor(serNome, email, otp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel, e);
                }
            } else {
                throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
            }
        } else {
            final boolean recuperaSenhaSMS = ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_SERVIDOR, CodedValues.AUTO_DESBLOQUEIO_SERVIDOR_SMS, responsavel);
            final boolean recuperaSenhaSMSEmail = ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_SERVIDOR, CodedValues.AUTO_DESBLOQUEIO_SERVIDOR_EMAIL_SMS, responsavel);

            if (recuperaSenhaSMS) {
                if (!TextHelper.isNull(telefone)) {
                    try {
                        EnviaSMSHelper.enviarSMSOTP(telefone, otp, responsavel);
                    } catch (final ZetraException ex) {
                        throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, ex);
                    }
                }
            } else if (recuperaSenhaSMSEmail) {
                if (!TextHelper.isNull(telefone) && enviaOtpCelular) {
                    try {
                        EnviaSMSHelper.enviarSMSOTP(telefone, otp, responsavel);
                    } catch (final ZetraException ex) {
                        throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, ex);
                    }
                }

                if (!TextHelper.isNull(email) && enviaOtpEmail) {
                    try {
                        EnviaEmailHelper.enviarEmailOTPServidor(serNome, email, otp, responsavel);
                    } catch (final ViewHelperException e) {
                        throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel, e);
                    }
                }
            }
        }
    }

    /**
     * Realiza autenticação via OTP para o portal
     *
     * @param usuCodigo
     * @param otp
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public String validarOTPPortal(TransferObject usuario, String otp, AcessoSistema responsavel) throws UsuarioControllerException {
        if (isDataCadastroOptExpirado((java.util.Date) usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO), responsavel)) {
            throw new UsuarioControllerException("mensagem.senha.servidor.otp.expirado", responsavel);
        }

        // valida otp enviado via SMS ao usuário.
        if (TextHelper.isNull(usuario.getAttribute(Columns.USU_OTP_CODIGO)) || !JCrypt.verificaSenha(otp, (String) usuario.getAttribute(Columns.USU_OTP_CODIGO))) {
            return null;
        }

        return gerarChaveSessaoUsuario((String) usuario.getAttribute(Columns.USU_CODIGO), responsavel);

    }

    /**
     * Verifica se o OTP foi expirado
     *
     * @param responsavel
     * @param usuSer
     * @throws UsuarioControllerException
     */
    private boolean isDataCadastroOptExpirado(java.util.Date otpDataCadastro, AcessoSistema responsavel) throws UsuarioControllerException {
        // valida se o otp ainda é válido
        final int timeoutOtp = ParamSist.getIntParamSist(CodedValues.TPC_TEMPO_EXPIRACAO_OTP, 20, AcessoSistema.getAcessoUsuarioSistema());
        final java.util.Date dataAtual = new java.util.Date();
        // verifica se passou o limite do tempo em milisegundos
        if ((otpDataCadastro == null) || ((dataAtual.getTime() - otpDataCadastro.getTime()) > (timeoutOtp * (6 * Math.pow(10, 4))))) {
            return true;
        }

        return false;
    }

    /**
     * Valida OTP de primeiro acesso de servidor
     * @param usuCodigo - código do usuário servidor
     * @param novaSenha - senha digitada pelo usuário que será sua nova senha de acesso
     * @param senhaCriptografada - informa se senha está vindo criptografada ou não
     * @param otp - otp enviado por SMS ou e-mail para validação de primeiro acesso
     * @param emailOpcional
     * @param telefoneOpcional
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public List<TransferObject> validaOTPServidor(String usuCodigo, String novaSenha, boolean senhaCriptografada, String otp, String emailOpcional, String telefoneOpcional, boolean senhaApp, AcessoSistema responsavel) throws UsuarioControllerException {
        final AcessoSistema respValidacao = AcessoSistema.getAcessoUsuarioSistema();

        // verifica se sistema valida primeiro acesso
        if (!ParamSist.getBoolParamSist(CodedValues.TPC_VALIDA_OTP_PRIMEIRO_ACESSO_USUARIO, respValidacao)) {
            throw new UsuarioControllerException("mensagem.operacaoInvalida", respValidacao);
        }

        TransferObject usuSer = null;
        try {
            usuSer = pesquisarServidorController.buscaUsuarioServidor(usuCodigo, respValidacao);

            // Valida se é primeiro acesso do usuário
            if (!TextHelper.isNull(usuSer.getAttribute(Columns.USU_DATA_ULT_ACESSO))) {
                throw new UsuarioControllerException("mensagem.usuario.possui.cadastro.ativo", responsavel);
            }

            if (isDataCadastroOptExpirado((java.util.Date) usuSer.getAttribute(Columns.USU_OTP_DATA_CADASTRO), respValidacao)) {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.expirado", respValidacao);
            }

            // valida otp enviado via SMS ou email ao usuário.
            if (TextHelper.isNull(usuSer.getAttribute(Columns.USU_OTP_CODIGO)) || !JCrypt.verificaSenha(otp, (String) usuSer.getAttribute(Columns.USU_OTP_CODIGO))) {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.invalido", respValidacao);
            }

            if ((!TextHelper.isNull(emailOpcional) || !TextHelper.isNull(telefoneOpcional)) && !usuarioTemPermissao(usuCodigo, CodedValues.FUN_EDT_SERVIDOR, AcessoSistema.ENTIDADE_SER, respValidacao)) {
                throw new UsuarioControllerException("mensagem.erro.servidor.nao.autorizado", respValidacao);
            }

            // valida tamanho máximo e mínimo dos campos senha e confirmação de senha
            int tamMinSenhaServidor = 6;
            int tamMaxSenhaServidor = 8;
            try {
                tamMinSenhaServidor = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MIN_SENHA_SERVIDOR, responsavel)) ? Integer.parseInt(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MIN_SENHA_SERVIDOR, responsavel).toString()) : 6;
            } catch (final Exception ex) {
                tamMinSenhaServidor = 6;
            }
            try {
                tamMaxSenhaServidor = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_SERVIDOR, responsavel)) ? Integer.parseInt(ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_SERVIDOR, responsavel).toString()) : 8;
            } catch (final Exception ex) {
                tamMaxSenhaServidor = 8;
            }
            if (TextHelper.isNull(novaSenha) || (novaSenha.length() < tamMinSenhaServidor)) {
                throw new UsuarioControllerException("mensagem.erro.cadastrar.senha.servidor.minimo", responsavel, String.valueOf(tamMinSenhaServidor));
            } else if (novaSenha.length() > tamMaxSenhaServidor) {
                throw new UsuarioControllerException("mensagem.erro.cadastrar.senha.servidor.maximo", responsavel, String.valueOf(tamMaxSenhaServidor));
            }

            // cria ocorrência de alteração de senha
            final String tocCodigoOcorrencia = CodedValues.TOC_ALTERACAO_SENHA_USUARIO;
            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setUsuCodigo(usuCodigo);
            ocorrencia.setTocCodigo(tocCodigoOcorrencia);
            ocorrencia.setOusUsuCodigo(CodedValues.USU_CODIGO_SISTEMA);
            ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.senha.usuario", respValidacao));

            //setar nova senha para todos usuários ligados a este CPF
            final List<TransferObject> lstTodosUsuarios = lstUsuariosSer((String) usuSer.getAttribute(Columns.SER_CPF), null, null, null, respValidacao);
            for (final TransferObject usuTO : lstTodosUsuarios) {
                alterarSenha((String) usuTO.getAttribute(Columns.USU_CODIGO), novaSenha, null, null, false, false, false, senhaCriptografada, null, null, false, senhaApp, null, responsavel);
            }

            if (!TextHelper.isNull(emailOpcional) || !TextHelper.isNull(telefoneOpcional)) {
                final ServidorTransferObject servidor = new ServidorTransferObject((String) usuSer.getAttribute(Columns.SER_CODIGO));
                servidor.setSerCpf((String) usuSer.getAttribute(Columns.SER_CPF));
                if (!TextHelper.isNull(emailOpcional) && TextHelper.isNull(servidor.getSerEmail())) {
                    servidor.setSerEmail(emailOpcional);
                }

                if (!TextHelper.isNull(telefoneOpcional) && TextHelper.isNull(servidor.getSerCelular())) {
                    servidor.setSerCelular(telefoneOpcional);
                }

                ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_USUARIO);
                servidorController.updateServidor(servidor, CodedValues.TOC_RSE_ALTERACAO_DADOS_CADASTRAIS, respValidacao);
            }

            // autentica usuário e retorna dados da autenticação para usuário
            return servidorController.lstRegistroServidorUsuarioSer((String) usuSer.getAttribute(Columns.USU_LOGIN), false, respValidacao);

        } catch (final ServidorControllerException e) {
            throw new UsuarioControllerException(e.getMessageKey(), respValidacao);
        }
    }


    /**
     * Envia OTP numérico de 6 dígitos para usuário por e-mail e/ou celular previamente cadastrados.
     * Os booleanos "enviarOtpEmail" e "enviarOtpCelular" indicam em qual meio o OTP deve ser enviado.
     * Por favor, não alterar o código e inserir parametrizações específicas de caso de uso. Este método
     * deve ser genérico para que seja utilizado por outras rotinas.
     * @param usuCodigo
     * @param enviarOtpEmail
     * @param enviarOtpCelular
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void enviarOtpUsuarioPorEmailOuCelular(String usuCodigo, boolean enviarOtpEmail, boolean enviarOtpCelular, AcessoSistema responsavel) throws UsuarioControllerException {
        if (!enviarOtpEmail && !enviarOtpCelular) {
            throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
        }

        // Buscar usuário através do usuCodigo passado
        final UsuarioTransferObject usuario = findUsuario(usuCodigo, responsavel);
        if (usuario == null) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
        }

        final String usuNome = usuario.getUsuNome();
        final String usuEmail = usuario.getUsuEmail();
        final String usuCelular = usuario.getUsuTel(); // TODO Criar campo para telefone celular

        // Se for para TOTP, validar se email ou telefone estão no campo USU_CHAVE_VALIDACAO_TOTP
        final String usuChaveValidacaoTotp = usuario.getUsuChaveValidacaoTotp();
        if (!TextHelper.isNull(usuChaveValidacaoTotp) && responsavel.getUsuCodigo().equals(usuCodigo)) {
            if (enviarOtpEmail) {
                if (!usuChaveValidacaoTotp.equals(TextHelper.md5(usuEmail))) {
                    throw new UsuarioControllerException("mensagem.erro.totp.chave.validacao.invalida", responsavel);
                }
            } else if (enviarOtpCelular) {
                if (!usuChaveValidacaoTotp.equals(TextHelper.md5(usuCelular))) {
                    throw new UsuarioControllerException("mensagem.erro.totp.chave.validacao.invalida", responsavel);
                }
            }
        }

        // Senha numérica com 6 dígitos
        final String otp = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);

        // Criptografa OTP antes de salvar no usuário
        final String otpCrypt = SenhaHelper.criptografarSenha(usuario.getUsuLogin(), otp, true, responsavel);

        // Salva OTP gerado no campo provisório USU_OTP_CODIGO
        usuario.setUsuOtpCodigo(otpCrypt);
        usuario.setUsuOtpDataCadastro(DateHelper.getSystemDatetime());

        // Cria ocorrência
        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
        ocorrencia.setUsuCodigo(usuCodigo);
        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setTocCodigo(CodedValues.TOC_INCLUSAO_OTP_USUARIO);
        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.inclusao.otp.usuario", responsavel));
        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

        // Salva OTP no usuário
        updateUsuario(usuario, ocorrencia, responsavel);

        if (enviarOtpEmail && enviarOtpCelular) {
            if (!TextHelper.isNull(usuCelular)) {
                try {
                    EnviaSMSHelper.enviarSMSOTP(usuCelular, otp, responsavel);
                } catch (final ZetraException ex) {
                    if (!TextHelper.isNull(usuEmail)) {
                        try {
                            EnviaEmailHelper.enviarEmailOTP(usuNome, usuEmail, otp, responsavel);
                        } catch (final ViewHelperException ex2) {
                            throw new UsuarioControllerException("mensagem.erro.sms.ou.email.enviar", responsavel, ex);
                        }
                    } else {
                        throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, ex);
                    }
                }
            } else if (!TextHelper.isNull(usuEmail)) {
                try {
                    EnviaEmailHelper.enviarEmailOTP(usuNome, usuEmail, otp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel, e);
                }
            } else {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.erro.email.celular.invalido", responsavel);
            }
        } else if (enviarOtpCelular) {
            if (!TextHelper.isNull(usuCelular)) {
                try {
                    EnviaSMSHelper.enviarSMSOTP(usuCelular, otp, responsavel);
                } catch (final ZetraException ex) {
                    throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, ex);
                }
            } else {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.erro.celular.invalido", responsavel);
            }
        } else if (enviarOtpEmail) {
            if (!TextHelper.isNull(usuEmail)) {
                try {
                    EnviaEmailHelper.enviarEmailOTPServidor(usuNome, usuEmail, otp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel, e);
                }
            } else {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.erro.email.invalido", responsavel);
            }
        }
    }

    @Override
    public void validarOtpUsuarioEnviadoPorEmailOuCelular(String usuCodigo, String otp, AcessoSistema responsavel) throws UsuarioControllerException {
        final UsuarioTransferObject usuario = findUsuario(usuCodigo, responsavel);

        // Valida a data de expiração do otp
        if (isDataCadastroOptExpirado((java.util.Date) usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO), responsavel)) {
            throw new UsuarioControllerException("mensagem.erro.totp.informado.expirado", responsavel);
        }

        // valida otp enviado via SMS ou email ao usuário.
        if (TextHelper.isNull(usuario.getAttribute(Columns.USU_OTP_CODIGO)) || !JCrypt.verificaSenha(otp, (String) usuario.getAttribute(Columns.USU_OTP_CODIGO))) {
            throw new UsuarioControllerException("mensagem.erro.totp.informado.invalido", responsavel);
        }
    }

    /**
     * Envia OTP numérico de 6 dígitos para servidor por e-mail e/ou celular previamente cadastrados.
     * Os booleanos "enviarOtpEmail" e "enviarOtpCelular" indicam em qual meio o OTP deve ser enviado.
     * Por favor, não alterar o código e inserir parametrizações específicas de caso de uso. Este método
     * deve ser genérico para que seja utilizado por outras rotinas.
     * @param usuCodigo
     * @param enviarOtpEmail
     * @param enviarOtpCelular
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void enviarOtpServidorPorEmailOuCelular(String usuCodigo, boolean enviarOtpEmail, boolean enviarOtpCelular, AcessoSistema responsavel) throws UsuarioControllerException {
        if (!enviarOtpEmail && !enviarOtpCelular) {
            throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
        }

        final String serEmail;
        final String serCelular;
        final String serNome;

        // Buscar usuário através do usuCodigo passado
        UsuarioTransferObject usuario = new UsuarioTransferObject(usuCodigo);
        final Usuario usuarioBean = findUsuarioBean(usuario, AcessoSistema.ENTIDADE_SER);
        if (usuarioBean == null) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
        }

        try {
            final UsuarioSer usuarioSer = UsuarioSerHome.findByUsuCodigo(usuCodigo);
            final String serCodigo = usuarioSer.getServidor().getSerCodigo();
            final ServidorTransferObject servidor = servidorController.findServidor(serCodigo, responsavel);
            if (servidor == null) {
                throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", responsavel);
            }

            serNome = servidor.getSerNome();
            serEmail = servidor.getSerEmail();
            serCelular = servidor.getSerCelular();
        } catch (ServidorControllerException | FindException ex) {
            throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", responsavel, ex);
        }

        // Senha numérica com 6 dígitos
        final String otp = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);

        // Criptografa OTP antes de salvar no usuário
        final String otpCrypt = SenhaHelper.criptografarSenha(usuarioBean.getUsuLogin(), otp, true, responsavel);

        // Salva OTP gerado no campo provisório USU_CHAVE_VALIDACAO_TOTP
        usuario = this.findUsuario(usuario, AcessoSistema.ENTIDADE_SER, responsavel);
        usuario.setUsuOtpCodigo(otpCrypt);
        usuario.setUsuOtpDataCadastro(DateHelper.getSystemDatetime());

        // Cria ocorrência
        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
        ocorrencia.setUsuCodigo(usuCodigo);
        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
        ocorrencia.setTocCodigo(CodedValues.TOC_INCLUSAO_OTP_USUARIO);
        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.inclusao.otp.usuario", responsavel));
        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

        // Salva OTP no usuário
        updateUsuario(usuario, ocorrencia, responsavel);

        if (enviarOtpEmail && enviarOtpCelular) {
            if (!TextHelper.isNull(serCelular)) {
                try {
                    EnviaSMSHelper.enviarSMSOTP(serCelular, otp, responsavel);
                } catch (final ZetraException ex) {
                    if (!TextHelper.isNull(serEmail)) {
                        try {
                            EnviaEmailHelper.enviarEmailOTPServidor(serNome, serEmail, otp, responsavel);
                        } catch (final ViewHelperException ex2) {
                            throw new UsuarioControllerException("mensagem.erro.sms.ou.email.enviar", responsavel, ex);
                        }
                    } else {
                        throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, ex);
                    }
                }
            } else if (!TextHelper.isNull(serEmail)) {
                try {
                    EnviaEmailHelper.enviarEmailOTPServidor(serNome, serEmail, otp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel, e);
                }
            } else {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.erro.email.celular.invalido", responsavel);
            }
        } else if (enviarOtpCelular) {
            if (!TextHelper.isNull(serCelular)) {
                try {
                    EnviaSMSHelper.enviarSMSOTP(serCelular, otp, responsavel);
                } catch (final ZetraException ex) {
                    throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel, ex);
                }
            } else {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.erro.celular.invalido", responsavel);
            }
        } else if (enviarOtpEmail) {
            if (!TextHelper.isNull(serEmail)) {
                try {
                    EnviaEmailHelper.enviarEmailOTPServidor(serNome, serEmail, otp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel, e);
                }
            } else {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.erro.email.invalido", responsavel);
            }
        }
    }

    @Override
    public void validarOtpServidorEnviadoPorEmailOuCelular(String usuCodigo, String otp, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final TransferObject usuSer = pesquisarServidorController.buscaUsuarioServidor(usuCodigo, responsavel);

            // Valida a data de expiração do otp
            if (isDataCadastroOptExpirado((java.util.Date) usuSer.getAttribute(Columns.USU_OTP_DATA_CADASTRO), responsavel)) {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.expirado", responsavel);
            }

            // valida otp enviado via SMS ou email ao usuário.
            if (TextHelper.isNull(usuSer.getAttribute(Columns.USU_OTP_CODIGO)) || !JCrypt.verificaSenha(otp, (String) usuSer.getAttribute(Columns.USU_OTP_CODIGO))) {
                throw new UsuarioControllerException("mensagem.senha.servidor.otp.invalido", responsavel);
            }
        } catch (final ServidorControllerException ex) {
            throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", responsavel, ex);
        }
    }

    /**
     * Método para recuperar senha via Web.
     * @param usuCodigo : código do usuário
     * @param tipoEntidade : tipo de entidade do usuário, ex: AcessoSistema.ENTIDADE_SER
     * @param chaveRecuperarSenha : chave de recuperação de senha enviada no e-mail
     * @param senhaNova : nova senha informada pelo usuário
     * @param dicaSenha : dica da senha
     * @param autoDesbloqueio : TRUE se é operação de autodesbloqueio
     * @param responsavel : responsável pela operação
     * @throws UsuarioControllerException
     */
    @Override
    public void recuperarSenha(String usuCodigo, String tipoEntidade, String chaveRecuperarSenha, String senhaNova, String dicaSenha, boolean autoDesbloqueio, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            boolean isCodValido = false;

            if (autoDesbloqueio) {
                isCodValido = validarChaveRecupSenhaAutoDesbloqueio(usuCodigo, chaveRecuperarSenha, responsavel);
            } else {
                isCodValido = validarChaveRecupSenha(usuCodigo, chaveRecuperarSenha, responsavel);
            }

            // Retorno mensagem de erro se o codigo de recuperação de senha for invalido
            if (!isCodValido) {
                throw new UsuarioControllerException("mensagem.erro.servidor.recuperar.senha.codigo.nao.localizado", responsavel);
            }
            // Desbloqueia o servidor caso seja auto desbloqueio
            if (autoDesbloqueio) {
                bloquearDesbloquearUsuario(usuCodigo, CodedValues.STU_ATIVO, tipoEntidade, null, null, responsavel);
            }

            if (tipoEntidade.contentEquals(AcessoSistema.ENTIDADE_SER) && ParamSist.paramEquals(CodedValues.TPC_SENHA_CONS_SERVIDOR_SOMENTE_NUMERICA, CodedValues.TPC_SIM, responsavel) && !TextHelper.isNum(senhaNova)) {
                throw new UsuarioControllerException("mensagem.senha.servidor.consulta.deve.ser.numerica", responsavel);
            }

            // Altera a senha do usuário
            alterarSenha(usuCodigo, senhaNova, dicaSenha, false, false, false, null, responsavel);
        } catch (final UsuarioControllerException ex) {
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw ex;
        }
    }

    /**
     * Método para recuperar senha via Web.
     * @param usuCodigos : Lista de códigos dos usuários que irão recuperar senha
     * @param tipoEntidade : tipo de entidade do usuário, ex: AcessoSistema.ENTIDADE_SER
     * @param chaveRecuperarSenha : chave de recuperação de senha enviada no e-mail
     * @param senhaNova : nova senha informada pelo usuário
     * @param dicaSenha : dica da senha
     * @param autoDesbloqueio : TRUE se é operação de autodesbloqueio
     * @param responsavel : responsável pela operação
     * @throws UsuarioControllerException
     */
    @Override
    public void recuperarSenha(Set<String> usuCodigos, String tipoEntidade, String chaveRecuperarSenha, String senhaNova, String dicaSenha, boolean autoDesbloqueio, AcessoSistema responsavel) throws UsuarioControllerException {
        for (final String usuCod : usuCodigos) {
            try {
                responsavel = AcessoSistema.recuperaAcessoSistema(usuCod, responsavel.getIpUsuario(), responsavel.getPortaLogicaUsuario());
            } catch (final ZetraException ex) {
                LOG.error(ex.getMessage(), ex);
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
            }

            recuperarSenha(usuCod, tipoEntidade, chaveRecuperarSenha, senhaNova, dicaSenha, autoDesbloqueio, responsavel);
        }
    }

    @Override
    public void recuperarSenha(String id, String login, List<String> orgCodigos, String otp, String senhaNova, boolean senhaApp, AcessoSistema responsavel) throws UsuarioControllerException {
        this.recuperarSenha(id, login, orgCodigos, otp, senhaNova, senhaApp, true, responsavel);
    }

    /** Método para recuperar senha via web.
     * Através do CPF informado, gera OTP e envia para celular ou email previamente cadastrados.
     * Ao receber, CPF, OTP e nova senha, valida OTP enviado anteriormente e cadastra nova senha.
     * Caso exista mais de um usuário vinculado ao CPF informado, OTP será enviado para todos os usuários e a nova senha também.
     *
     * @param id
     * @param login
     * @param orgCodigos
     * @param otp
     * @param senhaNova
     * @param responsavel
     * @throws UsuarioControllerException
      */
    @Override
    public UsuarioTransferObject recuperarSenha(String id, String login, List<String> orgCodigos, String otp, String senhaNova, boolean senhaApp, boolean isAcessoMobile, AcessoSistema responsavel) throws UsuarioControllerException {

        //Valida a máscara do código otp quando for preenchido
        if (!TextHelper.isNull(otp) && !TextHelper.validaMascara(otp, "#D6")) {
            throw new UsuarioControllerException("mensagem.senha.servidor.otp.invalido", responsavel);
        }

        // Verifica se o sistem permite recuperação de senha
        final Object paramRecuperacaoSenha = isAcessoMobile ? ParamSist.getInstance().getParam(CodedValues.TPC_METODO_ENVIO_OTP_RECUPERACAO_SENHA, responsavel) : AcessoSistema.ENTIDADE_SER.equals(responsavel.getTipoEntidade()) ? ParamSist.getInstance().getParam(CodedValues.TPC_ENVIA_OTP_RECUPERACAO_SENHA_SERVIDOR, responsavel)
                : ParamSist.getInstance().getParam(CodedValues.TPC_ENVIA_OTP_RECUPERACAO_SENHA_USU, responsavel);
        final String strParamRecuperaSenha = paramRecuperacaoSenha != null ? paramRecuperacaoSenha.toString() : CodedValues.ENVIA_OTP_DESABILITADO;

        if (TextHelper.isNull(paramRecuperacaoSenha) || CodedValues.ENVIA_OTP_DESABILITADO.equals(strParamRecuperaSenha)) {
            throw new UsuarioControllerException(isAcessoMobile ? "mensagem.erro.recuperacao.mobile.nao.disponivel" : "mensagem.erro.recuperacao.nao.disponivel", responsavel);
        }
        if (!CodedValues.ENVIA_OTP_SMS.equals(strParamRecuperaSenha) && !CodedValues.ENVIA_OTP_EMAIL.equals(strParamRecuperaSenha) && !CodedValues.ENVIA_OTP_SMS_OU_EMAIL.equals(strParamRecuperaSenha)) {
            throw new UsuarioControllerException("mensagem.operacaoInvalida", responsavel);
        }

        final boolean omiteCpf = ParamSist.getBoolParamSist(CodedValues.TPC_OMITE_CPF_SERVIDOR, responsavel);

        // Recupera tempo de expiração otp
        final ParamSist paramSist = ParamSist.getInstance();
        final String timeoutOtpString = (String) paramSist.getParam(CodedValues.TPC_TEMPO_EXPIRACAO_OTP, AcessoSistema.getAcessoUsuarioSistema());
        Integer timeoutOtp = TextHelper.isNull(timeoutOtpString) ? null : Integer.valueOf(timeoutOtpString);

        // Default 20 minutos
        if (timeoutOtp == null) {
            timeoutOtp = 20;
        }

        // Senha numérica com 6 dígitos - OTP gerado é único para todos usuários com mesmo CPF
        final String otpGerado = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);
        UsuarioTransferObject usuario = null;
        if (responsavel.isSer()) {
            List<TransferObject> lstRegistroServidores = null;
            try {
                if (omiteCpf) {
                    lstRegistroServidores = servidorController.lstRegistroServidorPorEmail(id, orgCodigos, AcessoSistema.getAcessoUsuarioSistema());
                } else {
                    lstRegistroServidores = servidorController.lstRegistroServidorPorCpf(id, orgCodigos, AcessoSistema.getAcessoUsuarioSistema());
                }

            } catch (final ServidorControllerException ex) {
                throw new UsuarioControllerException(ex);
            }

            if ((lstRegistroServidores == null) || lstRegistroServidores.isEmpty()) {
                throw new UsuarioControllerException("mensagem.erro.servidor.nao.encontrado", responsavel);
            }

            int serNaoEncontrado = 0;
            int usuOtpInvalido = 0;
            int usuOtpExpirado = 0;
            int usuErroGenerico = 0;
            int erroEnvioOtpSms = 0;
            int erroEnvioOtpEmail = 0;
            int erroEnvioOtpSmsEmail = 0;
            int erroGerarOtp = 0;
            int erroSemEmailCadastrado = 0;
            int erroSemTelCadastrado = 0;
            int totalErros = 0;
            ZetraException excecaoOrigem = null;
            String chaveErro = null;
            boolean notificacaoEnviada = false;

            for (final TransferObject rseTO : lstRegistroServidores) {
                CustomTransferObject usuTO = null;
                try {
                    // Busca o usuário pela chave primária
                    usuTO = pesquisarServidorController.buscaUsuarioServidor(null, null, (String) rseTO.getAttribute(Columns.RSE_MATRICULA), (String) rseTO.getAttribute(Columns.ORG_IDENTIFICADOR), (String) rseTO.getAttribute(Columns.EST_IDENTIFICADOR), responsavel);
                } catch (final ServidorControllerException ex) {
                    serNaoEncontrado++;
                    totalErros++;
                    excecaoOrigem = ex;
                }

                if (usuTO != null) {
                    final String usuCodigo = usuTO.getAttribute(Columns.USU_CODIGO).toString();
                    final String serCodigo = usuTO.getAttribute(Columns.SER_CODIGO).toString();

                    usuario = new UsuarioTransferObject(usuCodigo);
                    usuario = findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);

                    if (CodedValues.STU_ATIVO.equals(usuario.getStuCodigo()) || CodedValues.STU_AGUARD_APROVACAO_CADASTRO.equals(usuario.getStuCodigo())) {
                        if (!TextHelper.isNull(otp)) {
                            try {
                                // Valida se o otp expirou
                                final java.util.Date otpDataCadastro = usuTO.getAttribute(Columns.USU_OTP_DATA_CADASTRO) != null ? (java.util.Date) usuTO.getAttribute(Columns.USU_OTP_DATA_CADASTRO) : null;
                                final java.util.Date dataAtual = new java.util.Date();

                                // Verifica se otp é inválido ou se passou o limite do tempo em milisegundos
                                if (TextHelper.isNull(usuario.getUsuOtpCodigo()) || !JCrypt.verificaSenha(otp, usuario.getUsuOtpCodigo())) {
                                    usuOtpInvalido++;
                                    totalErros++;
                                    chaveErro = "mensagem.senha.servidor.otp.invalido";
                                } else if ((otpDataCadastro == null) || ((dataAtual.getTime() - otpDataCadastro.getTime()) > (timeoutOtp * (6 * Math.pow(10, 4))))) {
                                    usuOtpExpirado++;
                                    totalErros++;
                                    chaveErro = "mensagem.senha.servidor.otp.expirado";
                                } else {
                                    // Altera senha
                                    if (senhaApp) {
                                        alterarSenhaApp(usuCodigo, senhaNova, false, true, responsavel);
                                    } else {
                                        alterarSenha(usuCodigo, senhaNova, "", false, false, false, null, responsavel);
                                    }

                                    /*
                                     * Necessário fazer o reload das informações do usuário pois a senha foi alterada em outro método
                                     * e a variável local não é atualizada automaticamente.
                                     */
                                    usuario = findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);
                                    // Apaga a chave para recuperação de senha.
                                    usuario.setUsuOtpCodigo(null);
                                    usuario.setUsuDataRecSenha(null);
                                    usuario.setUsuOtpDataCadastro(null);

                                    // Determina parâmetros da ocorrência de usuário a ser gravada.
                                    final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                                    ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_SENHA_USUARIO);
                                    ocorrencia.setUsuCodigo(usuCodigo);
                                    ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                                    ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
                                    ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.invalida.otp.usuario", responsavel));

                                    // Invalida OTP
                                    updateUsuario(usuario, ocorrencia, responsavel);
                                }
                            } catch (final UsuarioControllerException ex) {
                                usuErroGenerico++;
                                totalErros++;
                                excecaoOrigem = ex;
                            }

                        } else {
                            try {
                                ServidorTransferObject servidor = null;
                                try {
                                    servidor = servidorController.findServidor(serCodigo, responsavel);
                                } catch (final ServidorControllerException ex) {
                                    serNaoEncontrado++;
                                    totalErros++;
                                    excecaoOrigem = ex;
                                }

                                if (servidor != null) {
                                    final String serNome = servidor.getSerNome();
                                    final String serEmail = servidor.getSerEmail();
                                    final String serCelular = servidor.getSerCelular();

                                    // Criptografa OTP antes de salvar no usuário
                                    final String otpCrypt = SenhaHelper.criptografarSenha(usuario.getUsuLogin(), otpGerado, true, responsavel);

                                    // Salva chave para recuperação de senha.
                                    final java.util.Date dataCadastro = DateHelper.getSystemDatetime();
                                    usuario.setUsuOtpCodigo(otpCrypt);
                                    usuario.setUsuDataRecSenha(dataCadastro);
                                    usuario.setUsuOtpDataCadastro(dataCadastro);

                                    // Determina parâmetros da ocorrência de usuário a ser gravada.
                                    final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                                    ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_SENHA_USUARIO);
                                    ocorrencia.setUsuCodigo(usuCodigo);
                                    ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                                    ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
                                    ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.inclusao.otp.usuario", responsavel));

                                    updateUsuario(usuario, ocorrencia, responsavel);

                                    if (!notificacaoEnviada) {
                                        if (CodedValues.ENVIA_OTP_SMS.equals(strParamRecuperaSenha) || CodedValues.ENVIA_OTP_SMS_OU_EMAIL.equals(strParamRecuperaSenha)) {
                                            try {
                                                EnviaSMSHelper.enviarSMSOTP(serCelular, otpGerado, responsavel);
                                                notificacaoEnviada = true;
                                            } catch (final ZetraException e) {
                                                if (CodedValues.ENVIA_OTP_SMS_OU_EMAIL.equals(strParamRecuperaSenha)) {
                                                    try {
                                                        EnviaEmailHelper.enviarEmailOTPServidor(serNome, serEmail, otpGerado, responsavel);
                                                        notificacaoEnviada = true;
                                                    } catch (final ViewHelperException ex) {
                                                        erroEnvioOtpSmsEmail++;
                                                        totalErros++;
                                                        excecaoOrigem = ex;
                                                        if (TextHelper.isNull(serEmail)) {
                                                            erroSemEmailCadastrado++;
                                                        }
                                                        if (TextHelper.isNull(serCelular)) {
                                                            erroSemTelCadastrado++;
                                                        }
                                                    }
                                                } else {
                                                    erroEnvioOtpSms++;
                                                    totalErros++;
                                                    excecaoOrigem = e;
                                                }
                                            }
                                        } else if (CodedValues.ENVIA_OTP_EMAIL.equals(strParamRecuperaSenha)) {
                                            try {
                                                EnviaEmailHelper.enviarEmailOTPServidor(serNome, serEmail, otpGerado, responsavel);
                                                notificacaoEnviada = true;
                                            } catch (final ViewHelperException ex) {
                                                erroEnvioOtpEmail++;
                                                totalErros++;
                                                excecaoOrigem = ex;
                                                if (TextHelper.isNull(serEmail)) {
                                                    erroSemEmailCadastrado++;
                                                }
                                            }
                                        }
                                    }
                                }

                            } catch (final UsuarioControllerException ex) {
                                erroGerarOtp++;
                                totalErros++;
                                excecaoOrigem = ex;
                            }
                        }
                    } else {
                        totalErros++;
                        chaveErro = "mensagem.erro.status.usuario.nao.permite.operacao";
                    }
                }
            }

            // Caso apresente o mesmo erro para todas as tentativas, retorna erro gerado

            if (serNaoEncontrado == lstRegistroServidores.size()) {
                chaveErro = "mensagem.erro.servidor.nao.encontrado";
            } else if (usuOtpInvalido == lstRegistroServidores.size()) {
                chaveErro = "mensagem.senha.servidor.otp.invalido";
            } else if (usuOtpExpirado == lstRegistroServidores.size()) {
                chaveErro = "mensagem.senha.servidor.otp.expirado";
            } else if (erroEnvioOtpSms == lstRegistroServidores.size()) {
                chaveErro = "mensagem.erro.sms.enviar";
            } else if ((erroSemEmailCadastrado == lstRegistroServidores.size()) && (erroSemTelCadastrado == lstRegistroServidores.size())) {
                chaveErro = "mensagem.erro.tel.email.ser.nao.cadastrado";
            } else if (erroSemEmailCadastrado == lstRegistroServidores.size()) {
                chaveErro = "mensagem.erro.email.ser.nao.cadastrado";
            } else if (erroSemTelCadastrado == lstRegistroServidores.size()) {
                chaveErro = "mensagem.erro.celular.ser.nao.cadastrado";
            } else if (erroEnvioOtpEmail == lstRegistroServidores.size()) {
                chaveErro = "mensagem.erro.email.enviar";
            } else if (erroEnvioOtpSmsEmail == lstRegistroServidores.size()) {
                chaveErro = "mensagem.erro.sms.ou.email.enviar";
            } else if (usuErroGenerico == lstRegistroServidores.size()) {
                if ((excecaoOrigem != null) && !TextHelper.isNull(excecaoOrigem.getMessageKey())) {
                    chaveErro = excecaoOrigem.getMessageKey();
                } else {
                    chaveErro = "mensagem.erro.alterar.chave.recuperacao.senha.usuario";
                }
            } else if (erroGerarOtp == lstRegistroServidores.size()) {
                chaveErro = "mensagem.erro.alterar.chave.recuperacao.senha.usuario";
            } else if (totalErros == lstRegistroServidores.size()) {
                if (TextHelper.isNull(chaveErro) && (excecaoOrigem != null) && !TextHelper.isNull(excecaoOrigem.getMessageKey())) {
                    chaveErro = excecaoOrigem.getMessageKey();
                } else if (TextHelper.isNull(chaveErro)) {
                    chaveErro = "mensagem.erro.alterar.chave.recuperacao.senha.usuario";
                }
            }
            if ((totalErros == lstRegistroServidores.size()) && !TextHelper.isNull(chaveErro)) {
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                throw new UsuarioControllerException(chaveErro, responsavel, excecaoOrigem, excecaoOrigem != null ? excecaoOrigem.getMessageArgs() : null);
            }

        } else {
            final CustomTransferObject usuTO = findUsuarioByLogin(login, responsavel);
            final String usuCodigo = usuTO.getAttribute(Columns.USU_CODIGO).toString();
            usuario = new UsuarioTransferObject(usuCodigo);
            usuario = findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);

            if (CodedValues.STU_ATIVO.equals(usuario.getStuCodigo()) && (usuario.getUsuCPF() != null) && (id != null) && usuario.getUsuCPF().equals(id)) {
                if (!TextHelper.isNull(otp)) {
                    try {
                        // Valida se o otp expirou
                        final java.util.Date otpDataCadastro = usuario.getUsuOtpDataCadastro();
                        final java.util.Date dataAtual = new java.util.Date();

                        // Verifica se otp é inválido ou se passou o limite do tempo em milisegundos
                        if (TextHelper.isNull(usuario.getUsuOtpCodigo()) || !JCrypt.verificaSenha(otp, usuario.getUsuOtpCodigo())) {
                            throw new UsuarioControllerException("mensagem.erro.usuario.codigo.otp.invalido", responsavel);
                        } else if ((otpDataCadastro == null) || ((dataAtual.getTime() - otpDataCadastro.getTime()) > (timeoutOtp * (6 * Math.pow(10, 4))))) {
                            throw new UsuarioControllerException("mensagem.erro.usuario.codigo.otp.vencido", responsavel);
                        } else {
                            // Altera senha
                            if (senhaApp) {
                                alterarSenhaApp(usuCodigo, senhaNova, false, responsavel);
                            } else {
                                alterarSenha(usuCodigo, senhaNova, "", false, false, false, null, responsavel);
                            }

                            /*
                             * Necessário fazer o reload das informações do usuário pois a senha foi alterada em outro método
                             * e a variável local não é atualizada automaticamente.
                             */
                            usuario = findUsuario(usuario, AcessoSistema.ENTIDADE_USU, responsavel);
                            // Apaga a chave para recuperação de senha.
                            usuario.setUsuOtpCodigo(null);
                            usuario.setUsuDataRecSenha(null);
                            usuario.setUsuOtpDataCadastro(null);

                            // Determina parâmetros da ocorrência de usuário a ser gravada.
                            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                            ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_SENHA_USUARIO);
                            ocorrencia.setUsuCodigo(usuCodigo);
                            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
                            ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.invalida.otp.usuario", responsavel));

                            // Invalida OTP
                            updateUsuario(usuario, ocorrencia, responsavel);
                        }
                    } catch (final UsuarioControllerException ex) {
                        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                        throw ex;
                    }
                } else {
                    try {
                        final String nome = usuario.getUsuNome();
                        final String usuEmail = usuario.getUsuEmail();
                        final String usuCelular = usuario.getUsuTel(); // TODO: usuario.getUsuCelular();

                        // Criptografa OTP antes de salvar no usuário
                        final String otpCrypt = SenhaHelper.criptografarSenha(usuario.getUsuLogin(), otpGerado, false, responsavel);

                        // Salva chave para recuperação de senha.
                        final java.util.Date dataCadastro = DateHelper.getSystemDatetime();
                        usuario.setUsuOtpCodigo(otpCrypt);
                        usuario.setUsuDataRecSenha(dataCadastro);
                        usuario.setUsuOtpDataCadastro(dataCadastro);

                        // Determina parâmetros da ocorrência de usuário a ser gravada.
                        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                        ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_SENHA_USUARIO);
                        ocorrencia.setUsuCodigo(usuCodigo);
                        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
                        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.inclusao.otp.usuario", responsavel));

                        updateUsuario(usuario, ocorrencia, responsavel);

                        if (CodedValues.ENVIA_OTP_SMS.equals(strParamRecuperaSenha) || CodedValues.ENVIA_OTP_SMS_OU_EMAIL.equals(strParamRecuperaSenha)) {
                            try {
                                EnviaSMSHelper.enviarSMSOTP(usuCelular, otpGerado, responsavel);
                            } catch (final ZetraException e) {
                                if (CodedValues.ENVIA_OTP_SMS_OU_EMAIL.equals(strParamRecuperaSenha)) {
                                    try {
                                        EnviaEmailHelper.enviarEmailOTP(nome, usuEmail, otpGerado, responsavel);
                                    } catch (final ViewHelperException ex) {
                                        throw new UsuarioControllerException("mensagem.erro.sms.ou.email.enviar", responsavel);
                                    }
                                } else {
                                    throw new UsuarioControllerException("mensagem.erro.sms.enviar", responsavel);
                                }
                            }
                        } else if (CodedValues.ENVIA_OTP_EMAIL.equals(strParamRecuperaSenha)) {
                            try {
                                EnviaEmailHelper.enviarEmailOTP(nome, usuEmail, otpGerado, responsavel);
                            } catch (final ViewHelperException e) {
                                throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel);
                            }
                        }
                    } catch (final UsuarioControllerException ex) {
                        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                        throw new UsuarioControllerException("mensagem.erro.alterar.chave.recuperacao.senha.usuario", responsavel, ex);
                    }
                }
            }
        }
        return usuario;
    }

    @Override
    public TransferObject buscarUsuarioPorCodRecuperarSenha(String codRecuperar, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemPapelUsuarioQuery query = new ObtemPapelUsuarioQuery();
            query.usuChaveRecuperarSenha = codRecuperar;
            final List<TransferObject> resultado = query.executarDTO();
            if ((resultado != null) && !resultado.isEmpty()) {
                return resultado.get(0);
            }
            return null;
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public void atualizarUsuarioAutorizacaoEmailMarketing(UsuarioTransferObject usuario, String usuAutoriza, AcessoSistema responsavel) throws UsuarioControllerException {
        usuario.setUsuAutorizaEmailMarketing(CodedValues.TPC_SIM.equals(usuAutoriza) ? CodedValues.TPC_SIM : CodedValues.TPC_NAO);
        updateUsuario(usuario, null, responsavel);
    }

    /** NOME DE USUÁRIO (PARA LOGIN EM DUAS ETAPAS) ---------------------------------------------------------------------- **/

    @Override
    public int countNomeUsuario(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemNomeUsuarioQuery query = new ObtemNomeUsuarioQuery();
            query.count = true;
            return query.executarContador();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public TransferObject obtemNomeUsuario(String login, String usuCodigo, int offset, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ObtemNomeUsuarioQuery query = new ObtemNomeUsuarioQuery();
            query.usuLogin = login;
            query.usuCodigo = usuCodigo;
            if (offset != -1) {
                query.firstResult = offset;
            }
            query.maxResults = 1;
            final List<TransferObject> lista = query.executarDTO();
            if ((lista == null) || lista.isEmpty()) {
                throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
            }

            return lista.get(0);
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    /**
     * Método que retorna a lista de usuários a serem notificados por tempo de initividade
     * no sistema.
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     * @throws HQueryException
     */
    @Override
    public List<TransferObject> enviaNotificacaoUsuariosPorTempoInatividade(AcessoSistema responsavel) throws UsuarioControllerException {

        List<TransferObject> lista = null;

        try {
            final Integer diasSemAcessoCse = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSE_SEM_ACESSO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSE_SEM_ACESSO, responsavel).toString()) : 0;
            final Integer diasSemAcessoCsa = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSA_SEM_ACESSO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_CSA_SEM_ACESSO, responsavel).toString()) : 0;
            final Integer diasSemAcessoSer = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_SER_SEM_ACESSO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_BLOQ_USU_SER_SEM_ACESSO, responsavel).toString()) : 0;
            final Integer qtdDiasAntesNotificacao = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_NOTIFICACAO_BLOQUEIO_INATIVIDADE, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_NOTIFICACAO_BLOQUEIO_INATIVIDADE, responsavel).toString()) : 0;

            // DESENV-14804 Quantidade de horas que o usuário tem de prazo para logar no sistema após o desbloqueio no sistema.
            Integer qtdeHorasPrazoLoginUsuario = !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_HORAS_USUARIO_LOGAR_APOS_DESBLOQUEIO, responsavel)) ? Integer.valueOf(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_HORAS_USUARIO_LOGAR_APOS_DESBLOQUEIO, responsavel).toString()) : 48;
            // Prazo máximo permitido será 10 (dez) dias, ou seja 240 horas.
            if (qtdeHorasPrazoLoginUsuario > 240) {
                qtdeHorasPrazoLoginUsuario = 240;
            }

            // Só executa se um dos parâmetros estiver setada a quantidade de dias sem acesso
            if (((diasSemAcessoCse.compareTo(0) > 0) || (diasSemAcessoCsa.compareTo(0) > 0) || (diasSemAcessoSer.compareTo(0) > 0)) && (qtdDiasAntesNotificacao.compareTo(0) > 0)) {

                final ListaUsuarioNotificacaoInatividadeQuery query = new ListaUsuarioNotificacaoInatividadeQuery();
                final Calendar data = Calendar.getInstance();
                data.add(Calendar.HOUR, -qtdeHorasPrazoLoginUsuario);
                query.dataLimiteBloqueio = data.getTime();
                lista = query.executarDTO();
            }
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.nao.foi.possivel.notificar.usuario.bloqueio.inatividade", responsavel, ex);
        }
        return lista;
    }

    @Override
    public void limparDadosOTP(TransferObject usuario, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final String usuCodigo = (String) usuario.getAttribute(Columns.USU_CODIGO);
            final Usuario usuarioBean = UsuarioHome.findByPrimaryKey(usuCodigo);

            usuarioBean.setUsuOtpCodigo(null);
            usuarioBean.setUsuOtpChaveSeguranca(null);
            usuarioBean.setUsuChaveValidacaoTotp(null);
            usuarioBean.setUsuOtpDataCadastro(null);

            AbstractEntityHome.update(usuarioBean);
        } catch (final Exception ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    /**
     * Método que gera o código de autorização a ser enviado ao Servidor via SMS.
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    private String gerarCodigoAutorizacaoSms(AcessoSistema responsavel) throws UsuarioControllerException {

        //Gera o código de autorização
        String codAut;
        try {
            codAut = GeradorSenhaUtil.getPasswordNumber(6, responsavel);
        } catch (final UsuarioControllerException e) {
            LOG.debug("Erro ao gerar o código de autorização: " + e.getMessage());
            return null;
        }

        //Salva o código na tabela de usuário
        UsuarioTransferObject usu = new UsuarioTransferObject();
        try {
            usu = findUsuario(responsavel.getUsuCodigo(), responsavel);

            final String codCriptografado = JCrypt.crypt(codAut);

            // registra dados no USU_OTP_CODIGO
            usu.setUsuOtpCodigo(codCriptografado);
            usu.setUsuOtpDataCadastro(DateHelper.getSystemDatetime());

            // Grava ocorrência de geração de OTP
            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setTocCodigo(CodedValues.TOC_INCLUSAO_OTP_USUARIO);
            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo() != null ? responsavel.getUsuCodigo() : AcessoSistema.getAcessoUsuarioSistema().getUsuCodigo());
            ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.usuario", responsavel));
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

            updateUsuario(usu, ocorrencia, null, null, AcessoSistema.ENTIDADE_SER, responsavel.getUsuCodigo(), null, responsavel);
        } catch (final UsuarioControllerException ex) {
            LOG.debug("Erro ao salvar o código de autorização: " + ex.getMessage());
            codAut = null;
            throw new UsuarioControllerException("mensagem.erro.interno.nao.possivel.gerar.codigo.autorizacao.solicitacao", responsavel, ex);
        }

        return codAut;
    }

    /**
     * Método que envia o código gerado, ao celular do Servidor, cadastrado na tb_servdor, campo "ser_celular".
     * @param rseCodigo
     * @param responsavel
     * @throws ServidorControllerException
     * @throws UsuarioControllerException
     */
    @Override
    public void enviarCodigoAutorizacaoSms(String rseCodigo, AcessoSistema responsavel) throws ServidorControllerException, UsuarioControllerException {

        if ((rseCodigo == null) || !validarCodigoAutorizacaoSmsExpirado(responsavel)) {
            return;
        }

        String celularDestinatario = null;

        // Busca mensagem a ser enviada
        String corpo = ApplicationResourcesHelper.getMessage("mensagem.sms.servidor.codigo.unico", responsavel);

        // Busca dados do servidor
        final ServidorTransferObject servidor = servidorController.findServidorByRseCodigo(rseCodigo, responsavel);

        if (servidor != null) {
            // Formata o telefone para o padrão do país
            celularDestinatario = !TextHelper.isNull(servidor.getSerCelular()) ? LocaleHelper.formataCelular(servidor.getSerCelular()) : null;
        }

        if (!TextHelper.isNull(celularDestinatario)) {
            // Envia o SMS.
            try {
                final String apiUrl = SysConfig.get().getZenviaApiUrl();
                final String apiToken = SysConfig.get().getZenviaApiToken();
                final String from = SysConfig.get().getZenviaSmsFrom();

                final String codAut = gerarCodigoAutorizacaoSms(responsavel);

                if (TextHelper.isNull(codAut)) {
                    return;
                }

                corpo += codAut;
                new SMSHelper(apiUrl, apiToken, from).send(celularDestinatario, corpo, responsavel);

            } catch (final ZetraException ex) {
                LOG.debug("Erro ao enviar o SMS: " + ex.getMessage());
                throw new UsuarioControllerException("mensagem.erro.interno.nao.possivel.gerar.codigo.autorizacao.solicitacao", responsavel, ex);
            }
        } else {
            throw new UsuarioControllerException("mensagem.erro.necessita.telefone.cadastrado", responsavel);
        }

    }

    /**
     * Método que valida o código enviado ao celular do Servidor, que foi informado na tela da interface web.
     * @param codAut
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public boolean validarCodigoAutorizacaoSms(String codAut, AcessoSistema responsavel) throws UsuarioControllerException {

        TransferObject usuario = null;

        try {
            usuario = pesquisarServidorController.buscaUsuarioServidor(responsavel.getUsuCodigo(), responsavel);
        } catch (final ServidorControllerException ex) {
            LOG.debug("Erro ao localizar o servidor: " + ex.getMessage());
            throw new UsuarioControllerException("mensagem.erro.localizar.servidor", responsavel, ex);
        }

        final ParamSist paramSist = ParamSist.getInstance();
        final String timeoutOtpString = (String) paramSist.getParam(CodedValues.TPC_TEMPO_EXPIRACAO_OTP, AcessoSistema.getAcessoUsuarioSistema());
        Integer timeoutOtp = TextHelper.isNull(timeoutOtpString) ? null : Integer.valueOf(timeoutOtpString);

        // default 20 minutos
        if (timeoutOtp == null) {
            timeoutOtp = 20;
        }

        // Valida se o otp expirou
        final java.util.Date otpDataCadastro = usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO) != null ? (java.util.Date) usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO) : null;
        final java.util.Date dataAtual = new java.util.Date();

        // Verifica se otp é inválido ou se passou o limite do tempo em milisegundos
        if (TextHelper.isNull(usuario.getAttribute(Columns.USU_OTP_CODIGO)) || !JCrypt.verificaSenha(codAut, usuario.getAttribute(Columns.USU_OTP_CODIGO).toString())) {
            throw new UsuarioControllerException("mensagem.erro.codigo.autorizacao.invalido", responsavel);
        } else if ((otpDataCadastro == null) || ((dataAtual.getTime() - otpDataCadastro.getTime()) > (timeoutOtp * 60000))) {
            throw new UsuarioControllerException("mensagem.erro.codigo.autorizacao.expirado", responsavel);
        }

        return true;
    }

    /**
     * Método que valida o tempo de expiração do código enviado ao celular do Servido.
     * @param codAut
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    private boolean validarCodigoAutorizacaoSmsExpirado(AcessoSistema responsavel) throws UsuarioControllerException {
        TransferObject usuario = null;

        try {
            usuario = pesquisarServidorController.buscaUsuarioServidor(responsavel.getUsuCodigo(), responsavel);
        } catch (final ServidorControllerException ex) {
            LOG.debug("Erro ao localizar o servidor: " + ex.getMessage());
            throw new UsuarioControllerException("mensagem.erro.localizar.servidor", responsavel, ex);
        }

        final ParamSist paramSist = ParamSist.getInstance();
        final String timeoutOtpString = (String) paramSist.getParam(CodedValues.TPC_TEMPO_EXPIRACAO_OTP, AcessoSistema.getAcessoUsuarioSistema());
        Integer timeoutOtp = TextHelper.isNull(timeoutOtpString) ? null : Integer.valueOf(timeoutOtpString);

        // default 20 minutos
        if (timeoutOtp == null) {
            timeoutOtp = 20;
        }

        // Valida se o otp expirou
        final java.util.Date otpDataCadastro = usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO) != null ? (java.util.Date) usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO) : null;
        final java.util.Date dataAtual = new java.util.Date();

        // Verifica se otp é inválido ou se passou o limite do tempo em milisegundos
        return (otpDataCadastro == null) || ((dataAtual.getTime() - otpDataCadastro.getTime()) > (timeoutOtp * 60000));
    }

    @Override
    public List<Papel> listarPapeis(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            return PapelHome.listarPapeis();
        } catch (final FindException e) {
            throw new UsuarioControllerException("mensagem.menu.papel.indefinido", responsavel);
        }
    }

    private Calendar calculaDataExpiracaoSenha(boolean senhaAutorizacaoServidor, UsuarioTransferObject usuario, boolean usuarioSer, AcessoSistema responsavel) throws UsuarioControllerException {
        final Calendar dataExpiracaoSenhaCalc = Calendar.getInstance();
        // Determina o prazo de expiração, de acordo com o tipo de usuário.
        String paramPrazoExpiracaoSenha;
        if (usuarioSer) {
            paramPrazoExpiracaoSenha = CodedValues.TPC_PRAZO_EXPIRACAO_SENHA_USU_SER;
        } else {
            final TransferObject tipoUsuario = obtemUsuarioTipo(usuario.getUsuCodigo(), usuario.getUsuLogin(), responsavel);
            final String tipo = (String) tipoUsuario.getAttribute("TIPO");
            if (tipo == null) {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.determinar.tipo.usuario", responsavel);
            }
            if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo) || AcessoSistema.ENTIDADE_SUP.equals(tipo)) {
                paramPrazoExpiracaoSenha = CodedValues.TPC_PRAZO_EXPIRACAO_SENHA_USU_CSE_ORG;
            } else if (AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) {
                paramPrazoExpiracaoSenha = CodedValues.TPC_PRAZO_EXPIRACAO_SENHA_USU_CSA_COR;
            } else if (AcessoSistema.ENTIDADE_SER.equals(tipo)) {
                paramPrazoExpiracaoSenha = CodedValues.TPC_PRAZO_EXPIRACAO_SENHA_USU_SER;
            } else {
                throw new UsuarioControllerException("mensagem.erro.nao.possivel.determinar.tipo.usuario", responsavel);
            }
        }

        String prazo = (String) ParamSist.getInstance().getParam(paramPrazoExpiracaoSenha, responsavel);
        if (TextHelper.isNull(prazo)) {
            throw new UsuarioControllerException("mensagem.erro.nao.ha.prazo.expiracao.senha.definido", responsavel);
        }
        if (senhaAutorizacaoServidor) {
            // Se é senha de autorização de servidor e a senha possui validade em dias
            // determina a data de expiração de acordo com este parâmetro, e não com
            // o parâmetro de expiração de senha de servidor.
            final String prazoValidade = (String) ParamSist.getInstance().getParam(CodedValues.TPC_QTD_DIAS_VALIDADE_SENHA_AUTORIZACAO, responsavel);
            if (!TextHelper.isNull(prazoValidade) && (Integer.parseInt(prazoValidade) > 0)) {
                prazo = prazoValidade;
            }
        }
        dataExpiracaoSenhaCalc.add(Calendar.DATE, Integer.parseInt(prazo));

        return dataExpiracaoSenhaCalc;
    }

    /**
     * geração e envio de OTP exclusivamente para validação de e-mail
     * @param servidor
     * @param emailValidacao
     * @param responsavel
     * @throws UsuarioControllerException
     */
    @Override
    public void gerarOtpConfirmacaoEmail(Servidor servidor, String emailValidacao, AcessoSistema responsavel) throws UsuarioControllerException {
        if (TextHelper.isNull(emailValidacao)) {
            throw new UsuarioControllerException("mensagem.informe.servidor.email", responsavel);
        }

        final List<TransferObject> usuarios = lstUsuariosSer(servidor.getSerCpf(), null, null, null, responsavel);
        if ((usuarios == null) || usuarios.isEmpty()) {
            throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
        }

        // Senha numérica com 6 dígitos
        final String otp = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);

        try {
            if (TextHelper.isNull(servidor.getSerEmail()) || !servidor.getSerEmail().equals(emailValidacao)) {
                final ServidorTransferObject serTO = new ServidorTransferObject(servidor.getSerCodigo());
                serTO.setSerEmail(emailValidacao);
                serTO.setSerDataValidacaoEmail(null);
                servidorController.updateServidor(serTO, responsavel);
            }

            for (final TransferObject usuario : usuarios) {
                // Criptografa OTP antes de salvar no usuário
                final String otpCrypt = SenhaHelper.criptografarSenha((String) usuario.getAttribute(Columns.USU_CODIGO), otp, true, responsavel);

                // Salva OTP gerado no campo provisório USU_CHAVE_VALIDACAO_TOTP
                UsuarioTransferObject usuTo = new UsuarioTransferObject();
                usuTo.setAtributos(usuario.getAtributos());

                usuTo = findUsuario(usuTo, AcessoSistema.ENTIDADE_SER, responsavel);
                usuTo.setUsuOtpCodigo(otpCrypt);
                usuTo.setUsuOtpDataCadastro(DateHelper.getSystemDatetime());
                if (ParamSist.paramEquals(CodedValues.TPC_VALIDAR_KYC_FACESWEB_INTEGRACAO_SALARYPAY, CodedValues.TPC_SIM, responsavel)) {
                    usuTo.setStuCodigo(CodedValues.STU_AGUARD_APROVACAO_CADASTRO);
                }

                // Cria ocorrência
                final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                ocorrencia.setUsuCodigo((String) usuario.getAttribute(Columns.USU_CODIGO));
                ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                ocorrencia.setTocCodigo(CodedValues.TOC_INCLUSAO_OTP_USUARIO);
                ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.inclusao.otp.usuario", responsavel));
                ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

                // Salva OTP no usuário
                updateUsuario(usuTo, ocorrencia, responsavel);

                try {
                    EnviaEmailHelper.enviarEmailOTPServidor(servidor.getSerNome(), emailValidacao, otp, responsavel);
                } catch (final ViewHelperException e) {
                    throw new UsuarioControllerException("mensagem.erro.falha.enviar.email", responsavel, e);
                }
            }
        } catch (final ServidorControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    /** Altera a chave de validação de Email
     * @param dadosUsuario : UsuarioTransferObject
     * @param responsavel : Usuário que está realizando a validação de email
     * @throws UsuarioControllerException
     */
    @Override
    public void alteraChaveValidacaoEmail(UsuarioTransferObject dadosUsuario, String link, AcessoSistema responsavel) throws UsuarioControllerException {
        if (!CodedValues.STU_ATIVO.equals(dadosUsuario.getStuCodigo())) {
            throw new UsuarioControllerException("mensagem.usuarioBloqueado", responsavel);
        }

        try {
            // Determina parâmetros da ocorrência de usuário a ser gravada.
            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            ocorrencia.setTocCodigo(CodedValues.TOC_VALIDACAO_EMAIL_USUARIO);
            ocorrencia.setUsuCodigo(dadosUsuario.getUsuCodigo());
            ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
            ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
            ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.validacao.email.usuario", responsavel));

            updateUsuario(dadosUsuario, ocorrencia, responsavel);

            enviaLinkValidaEmailUsuario(dadosUsuario.getUsuEmail(), dadosUsuario.getUsuNome(), link, dadosUsuario.getUsuChaveValidacaoEmail(), responsavel);

        } catch (final UsuarioControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw ex;
        }
    }

    /**
     * Envia ao usuário link de verificação do email
     * @param usuCodigo
     * @param emailDestinatario
     * @param link - link a ser enviado no e-mail que direciona para a página de confirmação de email.
     * @param codigo - token de fluxo de acesso da URL
     * @param responsavel
     * @throws UsuarioControllerException
     */
    private void enviaLinkValidaEmailUsuario(String emailDestinatario, String usuNome, String link, String codSenha, AcessoSistema responsavel) throws UsuarioControllerException {
        link = link + "&codValidacao=" + codSenha;

        if (!TextHelper.isNull(emailDestinatario)) {
            try {
                EnviaEmailHelper.enviarEmailLinkValidarEmailusuario(emailDestinatario, usuNome, link, responsavel);
            } catch (final ViewHelperException e) {
                throw new UsuarioControllerException("mensagem.erro.falha.enviar.email", responsavel, e);
            }
        }
    }

    @Override
    public TransferObject buscarUsuarioPorCodValidaEmail(String codValidacaoEmail, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            if (!TextHelper.isNull(codValidacaoEmail)) {

                final ObtemPapelUsuarioQuery query = new ObtemPapelUsuarioQuery();
                query.usuChaveValidacaoEmail = codValidacaoEmail;
                final List<TransferObject> resultado = query.executarDTO();
                if ((resultado != null) && !resultado.isEmpty()) {
                    for (final TransferObject usuario : resultado) {
                        final String usuCodigo = usuario.getAttribute(Columns.USU_CODIGO).toString();
                        final UsuarioTransferObject dadosUsuario = findUsuario(usuCodigo, responsavel);
                        responsavel.setUsuCodigo(usuCodigo);
                        dadosUsuario.setUsuDataValidacaoEmail(DateHelper.getSystemDatetime());

                        final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
                        ocorrencia.setTocCodigo(CodedValues.TOC_CONFIRMACAO_EMAIL_USUARIO);
                        ocorrencia.setUsuCodigo(dadosUsuario.getUsuCodigo());
                        ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                        ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());
                        ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.confirmacao.email.usuario", responsavel));

                        updateUsuario(dadosUsuario, ocorrencia, responsavel);

                    }
                    return resultado.get(0);
                }
            }
            return null;
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    /**
     * valida OTP para uso exclusivo em validação de e-mail
     * @param codAut
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    @Override
    public boolean validarOtpConfirmacaoEmail(String otp, String serCpf, AcessoSistema responsavel) throws UsuarioControllerException {
        //TODO: tratar quando retornar mais de um servidor
        try {
            final List<Servidor> servidores = ServidorHome.findByCPF(serCpf);
            final List<TransferObject> usuSerTos = this.lstUsuariosSer(servidores.get(0).getSerCpf(), null, null, null, responsavel);

            if ((usuSerTos == null) || usuSerTos.isEmpty()) {
                throw new UsuarioControllerException("mensagem.erro.usuario.nao.encontrado", responsavel);
            }

            //TODO: tratar quando retornar mais de um usuário
            final TransferObject usuario = usuSerTos.get(0);

            final ParamSist paramSist = ParamSist.getInstance();
            final String timeoutOtpString = (String) paramSist.getParam(CodedValues.TPC_TEMPO_EXPIRACAO_OTP, AcessoSistema.getAcessoUsuarioSistema());
            Integer timeoutOtp = TextHelper.isNull(timeoutOtpString) ? null : Integer.valueOf(timeoutOtpString);

            // default 20 minutos
            if (timeoutOtp == null) {
                timeoutOtp = 20;
            }

            // Valida se o otp expirou
            final java.util.Date otpDataCadastro = usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO) != null ? (java.util.Date) usuario.getAttribute(Columns.USU_OTP_DATA_CADASTRO) : null;
            final java.util.Date dataAtual = new java.util.Date();

            // Verifica se otp é inválido ou se passou o limite do tempo em milisegundos
            if (TextHelper.isNull(usuario.getAttribute(Columns.USU_OTP_CODIGO)) || !JCrypt.verificaSenha(otp, usuario.getAttribute(Columns.USU_OTP_CODIGO).toString())) {
                throw new UsuarioControllerException("mensagem.erro.codigo.autorizacao.invalido", responsavel);
            } else if ((otpDataCadastro == null) || ((dataAtual.getTime() - otpDataCadastro.getTime()) > (timeoutOtp * 60000))) {
                throw new UsuarioControllerException("mensagem.erro.codigo.autorizacao.expirado", responsavel);
            } else {
                // atualiza os campos do servidor que informam que o e-mail está validado
                final Servidor servidor = servidores.get(0);
                final ServidorTransferObject serTO = new ServidorTransferObject(servidor.getSerCodigo());
                serTO.setSerDataValidacaoEmail(new Timestamp(DateHelper.getSystemDatetime().getTime()));
                servidorController.updateServidor(serTO, responsavel);
            }
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException("mensagem.erro.localizar.servidor", responsavel, ex);
        } catch (final ServidorControllerException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }

        return true;
    }

    /**
     * Retorna TRUE caso exista outro usuário não excluído no sistema com o mesmo e-mail
     * @param usuEmail
     * @param usuCpfExceto
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */
    private boolean existeOutroUsuarioMesmoEmail(String usuEmail, String usuCpfExceto, AcessoSistema responsavel) throws UsuarioControllerException {
        boolean existeEmailCadastrado = false;
        try {
            if (ParamSist.paramEquals(CodedValues.TPC_IMPEDE_EMAIL_IGUAL_ENTRE_USU, CodedValues.TPC_SIM, responsavel)) {
                final ObtemTotalUsuariosPorEmailQuery query = new ObtemTotalUsuariosPorEmailQuery();
                query.usuEmail = usuEmail;
                query.usuCpfExceto = usuCpfExceto;
                existeEmailCadastrado = query.executarContador() > 0;
            }
            if (!existeEmailCadastrado && ParamSist.paramEquals(CodedValues.TPC_IMPEDE_EMAIL_IGUAL_ENTRE_USU_E_SER, CodedValues.TPC_SIM, responsavel)) {
                final ObtemTotalServidoresPorEmailCelularQuery query = new ObtemTotalServidoresPorEmailCelularQuery();
                query.serEmail = usuEmail;
                query.serCpfExceto = usuCpfExceto;
                existeEmailCadastrado = query.executarContador() > 0;
            }
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
        return existeEmailCadastrado;
    }

    private String criaOcorrenciaPerfil(String perCodigo, String tocCodigo, String oprObs, String tmoCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final String usuCodigo = responsavel != null ? responsavel.getUsuCodigo() : null;
            final OcorrenciaPerfil opr = OcorrenciaPerfilHome.create(perCodigo, tocCodigo, usuCodigo, oprObs, responsavel.getIpUsuario(), tmoCodigo);
            return opr.getOprCodigo();
        } catch (final CreateException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public int countOcorrenciaPerfil(String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaOcorrenciaPerfilQuery query = new ListaOcorrenciaPerfilQuery();
            query.count = true;
            query.perCodigo = perCodigo;
            return query.executarContador();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.contar.ocorrencias", responsavel, ex);
        }
    }

    @Override
    public List<TransferObject> lstOcorrenciaPerfil(String perCodigo, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaOcorrenciaPerfilQuery query = new ListaOcorrenciaPerfilQuery();
            if (offset != -1) {
                query.firstResult = offset;
            }
            if (count != -1) {
                query.maxResults = count;
            }
            query.perCodigo = perCodigo;
            return query.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.listar.ocorrencias", responsavel, ex);
        }
    }

    private TransferObject obtemServidorPorUsuario(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        final ObtemUsuarioServidorQuery query = new ObtemUsuarioServidorQuery();
        query.usuCodigo = usuCodigo;

        TransferObject servidor = null;
        try {
            final List<TransferObject> servidores = query.executarDTO();
            if ((servidores != null) && (servidores.size() == 1)) {
                servidor = servidores.get(0);
            }
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
        }

        if (servidor == null) {
            throw new UsuarioControllerException("mensagem.erro.nao.possivel.encontrar.servidor", responsavel);
        }

        return servidor;
    }

    @Override
    public String[] matriculasUsuariosServidores(String usuCodigo, String senhaNovaCrypt, boolean alteraSenha, AcessoSistema responsavel) throws UsuarioControllerException {

        try {
            final OcorrenciaUsuarioTransferObject ocorrencia = new OcorrenciaUsuarioTransferObject();
            final List<Usuario> usuarios = UsuarioHome.listaUsuServidores(usuCodigo);
            final String[] usuLogin = new String[usuarios.size()];
            int posicaoUsu = 0;

            for (final Usuario usu : usuarios) {
                final String[] matriculasSer = usu.getUsuLogin().split("-");
                usuLogin[posicaoUsu] = matriculasSer[matriculasSer.length - 1];

                if (!usuCodigo.equals(usu.getUsuCodigo()) && alteraSenha) {
                    final UsuarioTransferObject usuTranferObject = new UsuarioTransferObject(usu.getUsuCodigo());
                    usuTranferObject.setUsuSenha(senhaNovaCrypt);

                    ocorrencia.setUsuCodigo(usu.getUsuCodigo());
                    ocorrencia.setTocCodigo(CodedValues.TOC_ALTERACAO_SENHA_USUARIO);
                    ocorrencia.setOusUsuCodigo(responsavel.getUsuCodigo());
                    ocorrencia.setOusObs(ApplicationResourcesHelper.getMessage("mensagem.ocorrencia.ous.obs.alteracao.senhas.servidor", responsavel));
                    ocorrencia.setOusIpAcesso(responsavel.getIpUsuario());

                    updateUsuario(usuTranferObject, ocorrencia, responsavel);

                }
                posicaoUsu++;
            }
            return usuLogin;
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public void bloqueiaPerfilDataExpiracao(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            // Lista os perfils com data expirada
            final List<Perfil> lstPerfil = PerfilHome.findPerfilExpirado();

            if ((lstPerfil != null) && !lstPerfil.isEmpty()) {
                final Short status = CodedValues.STS_INATIVO;
                for (final Perfil perfil : lstPerfil) {
                    final String perCodigo = perfil.getPerCodigo();
                    //Iremos fazer o bloqueio para cada tipo de perfil CSE,ORG,CSA,COR,SUP,USU para que seja criado as ocorrêcia de bloqueio
                    final List<PerfilCse> lstPerfilCse = PerfilCseHome.findByPerCodigo(perCodigo);
                    final List<PerfilOrg> lstPerfilOrg = PerfilOrgHome.findByPerCodigo(perCodigo);
                    final List<PerfilCsa> lstPerfilCsa = PerfilCsaHome.findByPerCodigo(perCodigo);
                    final List<PerfilCor> lstPerfilCor = PerfilCorHome.findByPerCodigo(perCodigo);
                    final List<PerfilSup> lstPerfilSup = PerfilSupHome.findByPerCodigo(perCodigo);

                    if ((lstPerfilCse != null) && !lstPerfilCse.isEmpty()) {
                        final String tipoEntidade = AcessoSistema.ENTIDADE_CSE;
                        for (final PerfilCse perfilCse : lstPerfilCse) {
                            final String cseCodigo = perfilCse.getConsignante().getCseCodigo();
                            updatePerfil(tipoEntidade, cseCodigo, perCodigo, null, null, null, null, status, null,null, null, null, null, responsavel);
                        }
                    }

                    if ((lstPerfilOrg != null) && !lstPerfilOrg.isEmpty()) {
                        final String tipoEntidade = AcessoSistema.ENTIDADE_ORG;
                        for (final PerfilOrg perfilOrg : lstPerfilOrg) {
                            final String orgCodigo = perfilOrg.getOrgao().getOrgCodigo();
                            updatePerfil(tipoEntidade, orgCodigo, perCodigo, null, null, null, null, status, null, null, null, null, null, responsavel);
                        }
                    }

                    if ((lstPerfilCsa != null) && !lstPerfilCsa.isEmpty()) {
                        final String tipoEntidade = AcessoSistema.ENTIDADE_CSA;
                        for (final PerfilCsa perfilCsa : lstPerfilCsa) {
                            final String csaCodigo = perfilCsa.getConsignataria().getCsaCodigo();
                            updatePerfil(tipoEntidade, csaCodigo, perCodigo, null, null, null, null, status, null, null, null, null, null, responsavel);
                        }
                    }

                    if ((lstPerfilCor != null) && !lstPerfilCor.isEmpty()) {
                        final String tipoEntidade = AcessoSistema.ENTIDADE_COR;
                        for (final PerfilCor perfilCor : lstPerfilCor) {
                            final String corCodigo = perfilCor.getCorrespondente().getCorCodigo();
                            updatePerfil(tipoEntidade, corCodigo, perCodigo, null, null, null, null, status, null, null, null, null, null, responsavel);
                        }
                    }

                    if ((lstPerfilSup != null) && !lstPerfilSup.isEmpty()) {
                        final String tipoEntidade = AcessoSistema.ENTIDADE_SUP;
                        for (final PerfilSup perfilSup : lstPerfilSup) {
                            final String cseCodigo = perfilSup.getConsignante().getCseCodigo();
                            updatePerfil(tipoEntidade, cseCodigo, perCodigo, null, null, null, null, status, null, null, null, null, null, responsavel);
                        }
                    }
                }
            }
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    /**
     * Remove restrição do usuário por perfil.
     * @param responsavel
     * @return
     * @throws UsuarioControllerException
     */

    @Override
    public List<String> unidadesPermissaoEdtUsuario(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final List<String> unidades = new ArrayList<>();
            final List<UsuarioUnidade> usuUnidades = UsuarioUnidadeHome.listUniCodigosByUsuCodigo(usuCodigo);

            for (final UsuarioUnidade usu : usuUnidades) {
                unidades.add(usu.getUniCodigo());
            }
            return unidades;
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public void atribuirUnidadesUsuario(String usuCodigo, List<String> unidades, AcessoSistema responsavel) throws UsuarioControllerException {
        try {

            final List<UsuarioUnidade> usuUnidades = UsuarioUnidadeHome.listUniCodigosByUsuCodigo(usuCodigo);
            if ((usuUnidades != null) && !usuUnidades.isEmpty()) {
                UsuarioUnidadeHome.deleteByUsucodigo(usuCodigo);
            }

            for (final String unidade : unidades) {
                UsuarioUnidadeHome.create(usuCodigo, unidade);
            }
        } catch (CreateException | UpdateException | FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public void fixarCamposPesquisaAvancada(List<CampoUsuario> lstCampoUsuaio, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final String usuCodigo = responsavel.getUsuCodigo();
            final List<CampoUsuario> usuario = CampoUsuarioHome.findByUsuario(usuCodigo);
            if (!usuario.isEmpty()) {
                lstCampoUsuaio.forEach(campoUsuario -> {
                    try {
                        CampoUsuarioHome.updateCauValor(usuCodigo, campoUsuario.getCauChave(), campoUsuario.getCauValor());
                    } catch (final UpdateException ex) {
                        LOG.error(ex.getMessage(), ex);
                    }
                });
            } else {
                lstCampoUsuaio.forEach(campoUsuario -> {
                    try {
                        CampoUsuarioHome.create(usuCodigo, campoUsuario.getCauChave(), campoUsuario.getCauValor());
                    } catch (final CreateException ex) {
                        LOG.error(ex.getMessage(), ex);
                    }
                });
            }
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public List<CampoUsuario> buscarCamposPesquisaAvancada(AcessoSistema responsavel) throws UsuarioControllerException {
        List<CampoUsuario> usuario = null;
        try {
            usuario = CampoUsuarioHome.findByUsuario(responsavel.getUsuCodigo());

        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }

        return usuario;
    }

    @Override
    public List<TransferObject> listarUsuariosFuncaoEspecifica(String funCodigo, String tipoEntidade, String codigoEndidade, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuariosFuncaoEspecificaQuery lstUsuarios = new ListaUsuariosFuncaoEspecificaQuery();
            lstUsuarios.tipo = tipoEntidade;
            lstUsuarios.funCodigo = funCodigo;
            lstUsuarios.codigoEntidade = codigoEndidade;

            return lstUsuarios.executarDTO();
        } catch (final HQueryException e) {
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel);
        }
    }

    @Override
    public boolean findEmailExistenteCsaCseOrgCor(String emailUsuario, String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            List<TransferObject> listUsuEmailsRepeat = null;
            final FindEmailUsuarioRepeatQuery usuEmailRepeat = new FindEmailUsuarioRepeatQuery();
            boolean breakOperation = false;

            usuEmailRepeat.emailUsuario = emailUsuario;
            listUsuEmailsRepeat = usuEmailRepeat.executarDTO();

            for (final TransferObject usu : listUsuEmailsRepeat) {
                if ((!TextHelper.isNull(usu.getAttribute(Columns.UCE_CSE_CODIGO)) && !usuCodigo.equals(usu.getAttribute(Columns.USU_CODIGO))) || (!TextHelper.isNull(usu.getAttribute(Columns.UCA_CSA_CODIGO)) && !usuCodigo.equals(usu.getAttribute(Columns.USU_CODIGO)))) {
                    breakOperation = true;
                    break;
                } else if ((!TextHelper.isNull(usu.getAttribute(Columns.UCO_COR_CODIGO)) && !usuCodigo.equals(usu.getAttribute(Columns.USU_CODIGO))) || (!TextHelper.isNull(usu.getAttribute(Columns.UOR_ORG_CODIGO)) && !usuCodigo.equals(usu.getAttribute(Columns.USU_CODIGO)))) {
                    breakOperation = true;
                    break;
                } else if ((!TextHelper.isNull(usu.getAttribute(Columns.USP_CSE_CODIGO)) && !usuCodigo.equals(usu.getAttribute(Columns.USU_CODIGO))) || (!TextHelper.isNull(usu.getAttribute(Columns.USE_SER_CODIGO)) && !usuCodigo.equals(usu.getAttribute(Columns.USU_CODIGO)))) {
                    breakOperation = false;
                }
            }

            return breakOperation;
        } catch (final HQueryException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String consultarEmailServidor(boolean enviaEmail, String serCpf, String serEmail, String modoEntrega, AcessoSistema responsavel) throws UsuarioControllerException {
        String email = null;
        final String consultarEmailExternoClassName = (String) ParamSist.getInstance().getParam(CodedValues.TPC_CLASSE_BUSCA_EMAIL_SERVIDOR_API_EXTERNA, responsavel);

        //DESENV-21344
        if (enviaEmail && !TextHelper.isNull(consultarEmailExternoClassName) && (!CodedValues.ALTERACAO_SENHA_AUT_SER_EXIBE_TELA.equals(modoEntrega))) {
            try {
                final ConsultarEmailExternoServidor consultarEmailExternoServidor = ConsultarEmailExternoServidorFactory.getClasseConsultarEmailExternoServidor(consultarEmailExternoClassName);
                final CustomTransferObject resultadoConsultaAPIExterna = consultarEmailExternoServidor.consultarEmailExternoServidor(serCpf);

                if (HttpStatus.OK.equals(resultadoConsultaAPIExterna.getAttribute(ParamEmailExternoServidorEnum.RESULT_STATUS.getChave()))) {
                    email = (String) resultadoConsultaAPIExterna.getAttribute(ParamEmailExternoServidorEnum.RESULT_SUCCESS_DATA.getChave());
                } else if (!TextHelper.isNull(serEmail)) {
                    email = serEmail;
                } else {
                    throw UsuarioControllerException.byMessage((String) resultadoConsultaAPIExterna.getAttribute(ParamEmailExternoServidorEnum.RESULT_ERROR_DATA.getChave()));
                }
            } catch (final UsuarioControllerException ex) {
                LOG.error(ex.getMessage(), ex);
                throw UsuarioControllerException.byMessage(ex.getMessage());
            } catch (final ZetraException ex) {
            	LOG.error(ex.getMessage(), ex);
                throw new UsuarioControllerException("mensagem.erro.email.enviar", responsavel);
            }
        } else {
            email = serEmail;
        }

        return email;
    }

    @Override
    public Perfil findPerfilByUsuCodigo(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final String perCodigo = findUsuarioPerfil(usuCodigo, responsavel);
            if (perCodigo != null) {
                return PerfilHome.findByPrimaryKey(perCodigo);
            } else {
                throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, "");
            }
        } catch (final FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException("mensagem.erro.arg0.nenhum.perfil.encontrado", responsavel, "");
        }
    }

    @Override
    public void removeRestricaoUsuarioPerfil(String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException {
        try {

            final List<PerfilUsuario> lstUsuariosPerfil = PerfilUsuarioHome.findByPerfil(perCodigo);

            for (final PerfilUsuario usuarioPerfil : lstUsuariosPerfil) {

                final UsuarioTransferObject usuario = findUsuario(new UsuarioTransferObject(usuarioPerfil.getUsuCodigo()), AcessoSistema.ENTIDADE_USU, responsavel);
                usuario.setUsuIpAcesso(null);
                usuario.setUsuDDNSAcesso(null);
                updateUsuario(usuario, null, responsavel);

                final LogDelegate logDelegate = new LogDelegate(responsavel, Log.USUARIO, Log.UPDATE, Log.LOG_INFORMACAO);
                logDelegate.setUsuario(responsavel.getUsuCodigo());
                logDelegate.add(ApplicationResourcesHelper.getMessage("mensagem.informacao.remocao.restricao.usuario.perfil", responsavel));
                logDelegate.write();

            }

        } catch (LogControllerException | FindException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(MENSAGEM_ERRO_INTERNO_SISTEMA, responsavel, ex);
        }
    }

    @Override
    public List<TransferObject> listUsuariosAtivosComEmail(AcessoSistema responsavel) throws UsuarioControllerException {
        try {
            final ListaUsuarioAtivoComEmailQuery query = new ListaUsuarioAtivoComEmailQuery();
            return query.executarDTO();
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
    }

    @Override
    public void enviarNotificacaoPrazoExpiracaoSenha(String usuNome, String usuEmail, Integer qtdeDiasExpiracaoSenha, AcessoSistema responsavel) {
        try {
            EnviaEmailHelper.notificarUsuPrazoExpiracaoSenha(usuNome, usuEmail, qtdeDiasExpiracaoSenha, responsavel);
        } catch (ViewHelperException ex) {
            LOG.error(ex.getMessage(), ex);
            LOG.error(ApplicationResourcesHelper.getMessage("mensagem.erro.email.enviar", responsavel));
        }
    }

    @Override
    public boolean usuarioPossuiPermissaoAutoDesbloqueio(TransferObject usuarioTO, String tipoEntidade, AcessoSistema responsavel) {

        boolean usuarioPossuiPermissao = true;

        if (AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade) || AcessoSistema.ENTIDADE_ORG.equals(tipoEntidade)) {
            if (!ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_CSE_ORG, CodedValues.TPC_SIM, responsavel)) {
                usuarioPossuiPermissao = false;
            }
        } else if (AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade)) {
            
            if (!ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_CSA, CodedValues.TPC_SIM, responsavel)) {
                usuarioPossuiPermissao = false;
            } else {
                usuarioPossuiPermissao = verificarSePerfilCsaPermiteAutoDesbloqueio(usuarioTO, responsavel);
            }
            
        } else if (AcessoSistema.ENTIDADE_COR.equals(tipoEntidade)) {
            if (!ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_COR, CodedValues.TPC_SIM, responsavel)) {
                usuarioPossuiPermissao = false;
            }
        } else if (AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade)) {
            if (!ParamSist.paramEquals(CodedValues.TPC_AUTO_DESBLOQUEIO_USUARIO_SUP, CodedValues.TPC_SIM, responsavel)) {
                usuarioPossuiPermissao = false;
            }
        }

        return usuarioPossuiPermissao;
        
    }

    private boolean verificarSePerfilCsaPermiteAutoDesbloqueio(TransferObject usuarioTO, AcessoSistema responsavel) {
        
        try {

            boolean perfilPossuiPermissao = true;

            String tpaAutoDesbloqueio = buscarValorParametroConsignatariaAutoDesbloqueio(usuarioTO, responsavel);

            if (!TextHelper.isNull(tpaAutoDesbloqueio) && CodedValues.TPA_SIM.equals(tpaAutoDesbloqueio)) {

                String perCodigo = (String) usuarioTO.getAttribute(Columns.UPE_PER_CODIGO);

                if (perCodigo != null) {

                    Perfil perfil = findPerfil(perCodigo, responsavel);

                    if (perfil != null) {
                        
                        if (!TextHelper.isNull(perfil.getPerAutoDesbloqueio())) {
                            perfilPossuiPermissao = CodedValues.TPA_SIM.equals(perfil.getPerAutoDesbloqueio());
                        } else {
                            perfilPossuiPermissao = false;
                        }

                    }

                } 

            }

            return perfilPossuiPermissao;

        } catch (UsuarioControllerException | ParametroControllerException | CorrespondenteControllerException e) {
            LOG.error(e.getMessage(), e);
            return true;
        }

    }

    private String buscarValorParametroConsignatariaAutoDesbloqueio(TransferObject usuarioTO, AcessoSistema responsavel)
            throws CorrespondenteControllerException, ParametroControllerException {
        
        String csaCodigo = null;

        if (!TextHelper.isNull(usuarioTO.getAttribute(Columns.UCA_CSA_CODIGO))) {
            csaCodigo = (String) usuarioTO.getAttribute(Columns.UCA_CSA_CODIGO);
        } else if (!TextHelper.isNull(usuarioTO.getAttribute(Columns.UCO_COR_CODIGO))) {
            Correspondente cor = correspondenteController.findCorrespondenteByPrimaryKey((String) usuarioTO.getAttribute(Columns.UCO_COR_CODIGO), responsavel);
            csaCodigo = cor.getCsaCodigo();
        }
        
        String tpaAutoDesbloqueio = parametroController.getParamCsa(csaCodigo, CodedValues.TPA_AUTO_DESBLOQUEIO_USUARIO_CSA_COR, responsavel);

        return tpaAutoDesbloqueio;
        
    }

	@Override
	public boolean existeBloqueioSegurancaPorCpf(String usuCpf, AcessoSistema responsavel) throws UsuarioControllerException {
		try {
            final VerificaBloqueioSegurancaPorCpfQuery query = new VerificaBloqueioSegurancaPorCpfQuery();
            query.usuCpf = usuCpf;
            return !TextHelper.isNull(query.executarDTO());
        } catch (final HQueryException ex) {
            LOG.error(ex.getMessage(), ex);
            throw new UsuarioControllerException(ex);
        }
	}
	
	@Override
	public boolean bloquearInclusaoPorSeguranca(String usuCpf, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
		final boolean naoImpedeCpfUsuCsa = ParamSist.paramEquals(CodedValues.TPC_IMPEDE_CPF_IGUAL_ENTRE_USU_CSA, CodedValues.TPC_NAO, responsavel);
        final boolean cpfInvalidoPorSeguranca = existeBloqueioSegurancaPorCpf(usuCpf, responsavel);

        return !responsavel.isSup() && naoImpedeCpfUsuCsa && !tipoEntidade.equals(AcessoSistema.ENTIDADE_SER) && cpfInvalidoPorSeguranca;
	}
	
	@Override
	public boolean bloquearAlteracaoExclusaoPorSeguranca(String stuCodigo, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException {
        return !responsavel.isSup() && !tipoEntidade.equals(AcessoSistema.ENTIDADE_SER) && stuCodigo.equals(CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE_SEGURANCA);
	}
}


package com.zetra.econsig.service.usuario;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.zetra.econsig.dto.CustomTransferObject;
import com.zetra.econsig.dto.TransferObject;
import com.zetra.econsig.dto.entidade.EnderecoFuncaoTransferObject;
import com.zetra.econsig.dto.entidade.OcorrenciaUsuarioTransferObject;
import com.zetra.econsig.dto.entidade.UsuarioTransferObject;
import com.zetra.econsig.exception.FindException;
import com.zetra.econsig.exception.ServidorControllerException;
import com.zetra.econsig.exception.UsuarioControllerException;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.persistence.entity.ArquivoUsuario;
import com.zetra.econsig.persistence.entity.CampoUsuario;
import com.zetra.econsig.persistence.entity.Funcao;
import com.zetra.econsig.persistence.entity.Papel;
import com.zetra.econsig.persistence.entity.Perfil;
import com.zetra.econsig.persistence.entity.Servidor;
import com.zetra.econsig.persistence.entity.Usuario;
import com.zetra.econsig.persistence.entity.UsuarioChaveSessao;
import com.zetra.econsig.values.OperacaoValidacaoTotpEnum;
import com.zetra.econsig.values.PermiteValidacaoTotpEnum;

/**
 * <p>Title: UsuarioController</p>
 * <p>Description: </p>
 * <p>Copyright: Copyright (c) 2006</p>
 * <p>Company: ZetraSoft</p>
 * $Author$
* $Revision$
 * $Date$
 */
public interface UsuarioController  {
    // Usuario
    public UsuarioTransferObject findUsuario(UsuarioTransferObject usuario, String tipo, AcessoSistema responsavel) throws UsuarioControllerException;
    public UsuarioTransferObject findUsuario(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;
    public UsuarioTransferObject findUsuarioSer(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;
    public UsuarioTransferObject findUsuarioByLogin(String login, AcessoSistema responsavel) throws UsuarioControllerException;

    public CustomTransferObject findTipoUsuarioByLogin(String usuLogin, AcessoSistema responsavel) throws UsuarioControllerException;
    public CustomTransferObject findTipoUsuarioByCodigo(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> findUsuarioByEmail(String email, AcessoSistema responsavel) throws UsuarioControllerException;

    public Usuario findUsuarioByEmailAndToken(String email, String token, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<UsuarioTransferObject> lstUsuariosSerByEmail(String email, AcessoSistema responsavel) throws UsuarioControllerException;

    public String findUsuarioPerfil(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<String> getUsuarioFuncoes(String usuCodigo, String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createUsuario(UsuarioTransferObject usuario, List<String> funcoes, String codigoEntidade, String tipo, String senhaAberta, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createUsuario(UsuarioTransferObject usuario, List<String> funcoes, String codigoEntidade, String tipo, TransferObject tipoMotivoOperacao, boolean validaCpfEmail, String senhaAberta, AcessoSistema responsavel) throws UsuarioControllerException;
    
    public String createUsuario(UsuarioTransferObject usuario, List<String> funcoes, String codigoEntidade, String tipo, TransferObject tipoMotivoOperacao, boolean validaCpfEmail, String senhaAberta, boolean validaForcaSenha, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createUsuario(UsuarioTransferObject usuario, String perCodigo, String codigoEntidade, String tipo, String senhaAberta, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createUsuario(UsuarioTransferObject usuario, String perCodigo, String codigoEntidade, String tipo, TransferObject tipoMotivoOperacao, boolean validaCpfEmail, String senhaAberta, boolean validaForcaSenha, AcessoSistema responsavel) throws UsuarioControllerException;

    public void updateUsuario(UsuarioTransferObject usuario, OcorrenciaUsuarioTransferObject ocorrenciaUsu, List<String> funcoes, String perCodigo, String tipo, String codigoEntidade, TransferObject tipoMotivoOperacao, AcessoSistema responsavel) throws UsuarioControllerException;

    public void removeUsuario(UsuarioTransferObject usuario, String tipo, TransferObject tipoMotivoOperacao, AcessoSistema responsavel) throws UsuarioControllerException;

    public TransferObject obtemUsuarioTipo(String usuCodigo, String usuLogin, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstUsuarios(String opcao, String tipo, String codigoEntidade, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstUsuarios(String opcao, String tipo, String codigoEntidade, CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> getUsuarios(String tipo, String codigo, CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> listUsuarios(String tipo, String codigo, CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> listUsuariosAtivosComEmail(AcessoSistema responsavel) throws UsuarioControllerException;
    
    public int countUsuarios(String opcao, String tipo, String codigoEntidade, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException;

    public int countUsuarios(String tipo, String codigo, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException;

    public int listCountUsuarios(String tipo, String codigo, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException;

    // Usuario Servidor
    public List<TransferObject> lstUsuariosSerByRseCodigo(String rseCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstUsuariosSerByRseCodigos(List<String> rseCodigos, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstUsuariosSer(String serCpf, String rseMatricula, String estIdentificador, String orgIdentificador, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstUsuariosSer(String serCpf, String rseMatricula, String estIdentificador, String orgIdentificador, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstUsuariosSerLoginComCpf(String usuLogin, String rseMatricula, String serCpf, String estIdentificador, String orgIdentificador, boolean serSomenteAtivo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void aprovarCadastroUsuarioSer(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    // Perfil
    public Perfil findPerfil(String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> selectFuncoes(String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public CustomTransferObject getFuncao(String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public Map<String, EnderecoFuncaoTransferObject> selectFuncoes(String usuCodigo, String entidade, String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public Map<String, EnderecoFuncaoTransferObject> selectFuncoes(String usuCodigo, String entidade, String tipo, CustomTransferObject filtro, int offset, int size, AcessoSistema responsavel) throws UsuarioControllerException;

    public Map<String, String> selectFuncoesRestricaoAcesso(String usuCodigo, String entidade, String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public boolean usuarioTemPermissao(String usuCodigo, String funCodigo, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createPerfil(String tipoEntidade, String codigoEntidade, String perDescricao, String perVisivel, Date perDataExpiracoa, String perEntAltera, String perOrigem, String perAutoDesbloqueio, List<String> funCodigo, String perIpAcesso, String perDdnsAcesso, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createPerfil(String tipoEntidade, String codigoEntidade, String perDescricao, String perVisivel, Date perDataExpiracao, String perEntAltera, String perOrigem, String perAutoDesbloqueio,List<String> funCodigo, Boolean pcaPerfilPadrao, String perIpAcesso, String perDdnsAcesso,AcessoSistema responsavel) throws UsuarioControllerException;

    public void updatePerfil(String tipoEntidade, String codigoEntidade, String perCodigo, String perDescricao, String perVisivel, Date perDataExpiracao, String perEntAltera, Short status, String perAutoDesbloqueio, String perIpAcesso, String perDdnsAcesso, Boolean pcaPerfilPadrao, List<String> funcoes, AcessoSistema responsavel) throws UsuarioControllerException;

    public void removePerfil(String tipoEntidade, String codigoEntidade, String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void copyPerfil(String tipoEntidade, String codigoEntidade, String perOrigem, List<String> perDestino, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstPerfil(String tipoEntidade, String codigoEntidade, CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstPerfilSemBloqueioRepasse(String tipoEntidade, String codigoEntidade, String usuCodigoEdt, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<String> getFuncaoPerfil(String tipoEntidade, String codigoEntidade, String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public Short getStatusPerfil(String tipoEntidade, String codigoEntidade, String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstFuncoesPermitidasUsuario(String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstFuncoesPermitidasPerfil(String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    // Bloqueio de funções por usuário e serviço
    public List<TransferObject> lstFuncoes(String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public Map<String, String> getMapFuncoes(String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstFuncoesBloqueaveis(String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> selectFuncoesBloqueadas(String usuario, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> selectFuncoesBloqueadas(String usuario, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    public void insereBloqueiosFuncoes(String usuCodigo, List<TransferObject> bloqueios, AcessoSistema responsavel) throws UsuarioControllerException;

    public boolean usuarioTemBloqueioFuncao(String usuCodigo, String funCodigo, String svcCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstFuncaoExigeTmo(String funExigeTmo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> selectFuncoesPermitidasNca(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> selectFuncoesSensiveisCsa(AcessoSistema responsavel) throws UsuarioControllerException;

    // Senha Servidor
    public TransferObject getSenhaServidor(String rseCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public String gerarSenhaAutorizacaoOtp(String rseCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public String gerarSenhaAutorizacaoOtp(String rseCodigo, String modoEntrega, AcessoSistema responsavel) throws UsuarioControllerException;

    public String gerarSenhaAutorizacao(String usuCodigo, boolean totem, AcessoSistema responsavel) throws UsuarioControllerException;

    public String gerarSenhaAutorizacao(String usuCodigo, boolean totem, boolean naoComunicarServidor, boolean validaQtdeSenhaAutorizacao, AcessoSistema responsavel) throws UsuarioControllerException;

    public String gerarSenhaAutorizacaoRest(AcessoSistema responsavel) throws UsuarioControllerException;

    public void validaQtdeSenhaAutorizacao(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alterarSenhaAutorizacao(String usuCodigo, String senhaNova, AcessoSistema responsavel) throws UsuarioControllerException;

    public void consomeSenhaAutorizacao(String usuCodigo, String senhaUtilizada, AcessoSistema responsavel) throws UsuarioControllerException;

    public void cancelaSenhaAutorizacao(String usuCodigo, String senhaNaoUtilizada, AcessoSistema responsavel) throws UsuarioControllerException;

    public void cancelaSenhaAutorizacaoRest(Date dataCriacao, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alterarOperacoesSenhaAutorizacao(String usuCodigo, Short qtdOperacoes, String senhaUtilizada, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstSenhaAutorizacaoServidor(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstSenhaAutorizacaoServidorRest(AcessoSistema responsavel) throws UsuarioControllerException;

    public int qtdeSenhaAutorizacaoUsuSerDiaHostAHost(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public TransferObject obtemSenhaAutorizacaoServidor(String usuCodigo, String sasSenha, AcessoSistema responsavel) throws UsuarioControllerException;

    // Ocorrência usuário
    public String createOcorrenciaUsuario(CustomTransferObject ocorrencia, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstOcorrenciaUsuario(CustomTransferObject filtro, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException;

    public int countOcorrenciaUsuario(CustomTransferObject filtro, AcessoSistema responsavel) throws UsuarioControllerException;

    public String isOrg(String usuCodigo) throws UsuarioControllerException;

    public void alterarSenha(String usuCodigo, String senhaNova, String dicaSenha, boolean expiracaoImediata, boolean reiniciacao, boolean senhaCriptografada, String senhaAtualAberta, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alterarSenha(String usuCodigo, String senhaNova, String dicaSenha, boolean expiracaoImediata, boolean reiniciacao, boolean senhaCriptografada, CustomTransferObject tipoMotivoOperacao, String senhaAtualAberta, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alterarSenhaApp(String usuCodigo, String senhaNova, boolean senhaCriptografada, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alterarSenhaApp(String usuCodigo, String senhaNova, boolean senhaCriptografada, boolean chamaMobile, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alteraChaveRecupSenha(String usuCodigo, String codSenha, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alteraChaveRecupSenhaAutoDesbloqueio(String usuCodigo, String codSenha, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviaLinkReinicializarSenhaSer(String usuCodigo, String matricula, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviaLinkReinicializarSenhaSerAutoDesbloqueio(String usuCodigo, String matricula, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviaLinkReinicializarSenhaUsuAutoDesbloqueio(String usuLogin, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviaLinkReinicializarSenhaUsu(String usuCodigo, String login, String link, String codigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createProtocoloSenhaAutorizacao(String psaCodigo, String usuCodigoAfetado, AcessoSistema responsavel) throws UsuarioControllerException;

    public TransferObject getProtocoloSenhaAutorizacao(String psaCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> listarSenhasExpiradasCancelamentoAut(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstStatusLogin(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstPapel(AcessoSistema responsavel) throws UsuarioControllerException;

    public void alteraDataUltimoAcessoSistema(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> listarBloqueiaUsuariosInativos(String usuCodigo, java.util.Date dataLimiteBloqueio, AcessoSistema responsavel) throws UsuarioControllerException;

    public void bloqueiaUsuarioCsaComCPFServidor(String serCpf, AcessoSistema responsavel) throws UsuarioControllerException;

    public void validaIpAcessoResponsavel(String tipo, String usuLogin, String codigoEntidade, String ipList, String ddnsList, AcessoSistema responsavel) throws UsuarioControllerException;

    public Short getPerfilStatus(String perCodigo, String tipo, String entCodigo, AcessoSistema responsavel) throws FindException, UsuarioControllerException;

    public List<TransferObject> lstUsuarioCriadoRecursivoPorResponsavel(List<String> usuCodigos, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstUsuarioCriadoPorResponsavel(List<String> usuCodigos, AcessoSistema responsavel) throws UsuarioControllerException;

    public void bloquearDesbloquearUsuario(String usu_codigo, String status, String tipo, String tmoCodigo, String ousObs, AcessoSistema responsavel) throws UsuarioControllerException;

    public void bloquearDesbloquearUsuario(List<TransferObject> usuarios, String status, String tmoCodigo, String ousObs, AcessoSistema responsavel) throws UsuarioControllerException;

    public void bloquearDesbloquearUsuario(String usu_codigo, String status, String tipo, String tmoCodigo, String ousObs, AcessoSistema responsavel, Boolean validarCpf) throws UsuarioControllerException;

    public void bloquearUsuarioMotivoSeguranca(String usuCodigo, String entidadeOperada, String operacao, AcessoSistema responsavel) throws UsuarioControllerException;

    public Funcao findFuncao(String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public String createFuncao(String grfCodigo, String funDescricao, String funPermiteBloqueio, String funExigeTmo, String funExigeSegundaSenhaCse, String funExigeSegundaSenhaSup, String funExigeSegundaSenhaOrg, String funExigeSegundaSenhaCsa, String funExigeSegundaSenhaCor, String funExigeSegundaSenhaSer, String funAuditavel, List<String> papCodigos, AcessoSistema responsavel) throws UsuarioControllerException;

    public void updateFuncao(TransferObject funcaoTO, List<String> papCodigos, AcessoSistema responsavel) throws UsuarioControllerException;

    public void removeFuncao(String funCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public int countFuncao(TransferObject criterio, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> listFuncao(TransferObject criterio, int offset, int size, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstFuncoesAuditaveis(String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    public void updateFuncoesAuditaveis(List<String> funcoes, String tipo, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    public Map<String, List<TransferObject>> lstUsuarioAuditorEntidade(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<UsuarioTransferObject> lstUsuariosAuditores(String tipo, String codigoEntidade, Object stuCodigo, int offset, int size, AcessoSistema responsavel) throws UsuarioControllerException;

    public int countUsuariosAuditores(String tipo, String codigoEntidade, Object stuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public boolean podeRemoverFuncAuditoria(String usuCodigo, String codigoEntidade, String tipo, AcessoSistema responsavel) throws UsuarioControllerException;

    public String gerarSenhasUsuServidores(AcessoSistema responsavel) throws UsuarioControllerException;

    public void ativarSenhasUsuServidores(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> findFuncaoAuditavelPorEntidade(String codigoEntidade, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    public void bloqueiaUsuariosFimVigencia(AcessoSistema responsavel) throws UsuarioControllerException;

    public String cadastrarChaveValidacaoTotp(String usuChaveValidacaoTotp, OperacaoValidacaoTotpEnum operacoesValidacaoTotp, PermiteValidacaoTotpEnum permiteValidacaoTotp, AcessoSistema responsavel) throws UsuarioControllerException;

    public void removerChaveValidacaoTotp(AcessoSistema responsavel) throws UsuarioControllerException;

    public void updateEnderecoAcessoFuncao(CustomTransferObject dadosTo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> findUsuarioCseList(AcessoSistema responsavel) throws UsuarioControllerException;

    public String gerarChaveSessaoUsuario(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void cadastroDeviceToken(String usuCodigo, String tdiCodigo, String deviceToken, AcessoSistema responsavel) throws UsuarioControllerException;

    public String findDeviceToken(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public UsuarioChaveSessao findUsuarioChaveSessao(String token) throws FindException;

    public void deleteUsuarioChaveSessao(String usuCodigo) throws UsuarioControllerException;

    public UsuarioChaveSessao validateToken(String token) throws UsuarioControllerException;

    public void insereAlteraImagemUsuario(String usuCodigo, byte[] imagem, AcessoSistema responsavel) throws UsuarioControllerException;

    public Map<String, Object> primeiroAcesso(String cpf, String orgCodigo, String otp, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviaOTPServidor(String usuCodigo, String chaveSenha, String emailOpcional, String telefoneOpcional, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviaOTPServidor(String usuCodigo, String chaveSenha, String emailOpcional, String telefoneOpcional, boolean validarChaveSenha, boolean fluxoAutoDesbloqueio, boolean enviaOtpEmail, boolean enviaOtpCelular, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> validaOTPServidor(String usuCodigo, String chaveSenha, boolean senhaCriptografada, String otp, String emailOpcional, String telefoneOpcional, boolean senhaApp, AcessoSistema responsavel) throws UsuarioControllerException;

    public String validarOTPPortal(TransferObject usuario, String otp, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviarOtpUsuarioPorEmailOuCelular(String usuCodigo, boolean enviarOtpEmail, boolean enviarOtpCelular, AcessoSistema responsavel) throws UsuarioControllerException;
    public void validarOtpUsuarioEnviadoPorEmailOuCelular(String usuCodigo, String otp, AcessoSistema responsavel) throws UsuarioControllerException;
    
    public void enviarOtpServidorPorEmailOuCelular(String usuCodigo, boolean enviarOtpEmail, boolean enviarOtpCelular, AcessoSistema responsavel) throws UsuarioControllerException;
    public void validarOtpServidorEnviadoPorEmailOuCelular(String usuCodigo, String otp, AcessoSistema responsavel) throws UsuarioControllerException;

    public void recuperarSenha(String usuCodigo, String tipoEntidade, String chaveRecuperarSenha, String senhaNova, String dicaSenha, boolean autoDesbloqueio, AcessoSistema responsavel) throws UsuarioControllerException;

    public void recuperarSenha(Set<String> usuCodigos, String tipoEntidade, String chaveRecuperarSenha, String senhaNova, String dicaSenha, boolean autoDesbloqueio, AcessoSistema responsavel) throws UsuarioControllerException;

    public void recuperarSenha(String cpf, String login, List<String> orgCodigos, String otp, String senhaNova, boolean senhaApp, AcessoSistema responsavel) throws UsuarioControllerException;

    public UsuarioTransferObject recuperarSenha(String id, String login, List<String> orgCodigos, String otp, String senhaNova, boolean senhaApp, boolean isAcessoMobile, AcessoSistema responsavel) throws UsuarioControllerException;

    public Collection<ArquivoUsuario> findArquivoUsuario(String usuCodigo, String tarCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public TransferObject buscarUsuarioPorCodRecuperarSenha(String codRecuperar, AcessoSistema responsavel) throws UsuarioControllerException;

    public void atualizarUsuarioAutorizacaoEmailMarketing(UsuarioTransferObject usuario, String usuAutoriza, AcessoSistema responsavel) throws UsuarioControllerException;

    // NOME DE USUÁRIO (PARA LOGIN EM DUAS ETAPAS)
    public int countNomeUsuario(AcessoSistema responsavel) throws UsuarioControllerException;

    public TransferObject obtemNomeUsuario(String login, String usuCodigo, int offset, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> enviaNotificacaoUsuariosPorTempoInatividade(AcessoSistema responsavel) throws UsuarioControllerException;

    public void limparDadosOTP(TransferObject usuario, AcessoSistema responsavel) throws UsuarioControllerException;

    public void enviarCodigoAutorizacaoSms(String rseCodigo, AcessoSistema responsavel) throws ServidorControllerException, UsuarioControllerException;

    public boolean validarCodigoAutorizacaoSms(String codAut, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<Papel> listarPapeis(AcessoSistema responsavel) throws UsuarioControllerException;

    public void gerarOtpConfirmacaoEmail(Servidor servidor, String emailValidacao, AcessoSistema responsavel) throws UsuarioControllerException;

    public boolean validarOtpConfirmacaoEmail(String otp, String serCpf, AcessoSistema responsavel) throws UsuarioControllerException;

    public void alteraChaveValidacaoEmail(UsuarioTransferObject dadosUsuario, String link, AcessoSistema responsavel) throws UsuarioControllerException;

    public TransferObject buscarUsuarioPorCodValidaEmail(String codValidacao, AcessoSistema responsavel) throws UsuarioControllerException;

    public int countOcorrenciaPerfil(String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> lstOcorrenciaPerfil(String perCodigo, int offset, int count, AcessoSistema responsavel) throws UsuarioControllerException;

    public String[] matriculasUsuariosServidores(String usuCodigo, String senhaNovaCrypt, boolean alteraSenha, AcessoSistema responsavel) throws UsuarioControllerException;

    public void bloqueiaPerfilDataExpiracao(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<String> unidadesPermissaoEdtUsuario (String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public void atribuirUnidadesUsuario(String usuCodigo, List<String> unidades, AcessoSistema responsavel) throws UsuarioControllerException;

    public void fixarCamposPesquisaAvancada(List<CampoUsuario> lstCampoUsuario, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<CampoUsuario> buscarCamposPesquisaAvancada(AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> listarUsuariosFuncaoEspecifica(String funCodigo, String tipoEntidade, String codigoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;

    public List<TransferObject> findFuncoesRegraTaxa(String funCodigos, AcessoSistema responsavel) throws UsuarioControllerException;

    public boolean findEmailExistenteCsaCseOrgCor(String emailUsuario, String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public String consultarEmailServidor(boolean enviaEmail, String serCpf, String serEmail, String modoEntrega, AcessoSistema responsavel) throws UsuarioControllerException;

    public void removeRestricaoUsuarioPerfil(String perCodigo, AcessoSistema responsavel) throws UsuarioControllerException;

    public Perfil findPerfilByUsuCodigo(String usuCodigo, AcessoSistema responsavel) throws UsuarioControllerException;
    
    public void enviarNotificacaoPrazoExpiracaoSenha(String usuNome, String usuEmail, Integer qtdeDiasExpiracaoSenha, AcessoSistema responsavel);

    public boolean usuarioPossuiPermissaoAutoDesbloqueio(TransferObject usuarioTO, String tipoEntidade, AcessoSistema responsavel);
    
    public boolean existeBloqueioSegurancaPorCpf(String usuCpf, AcessoSistema responsavel) throws UsuarioControllerException;
    
	boolean bloquearInclusaoPorSeguranca(String usuCpf, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;
	
	boolean bloquearAlteracaoExclusaoPorSeguranca(String stuCodigo, String tipoEntidade, AcessoSistema responsavel) throws UsuarioControllerException;
}

package com.zetra.econsig.values;

import java.util.HashMap;
import java.util.Map;

/**
 * Enum para os parâmetros de sistema:
 * TPC_TIPO_PERMITIDO_TOTP_USUARIO_CSE_ORG
 * TPC_TIPO_PERMITIDO_TOTP_USUARIO_CSA_COR
 * TPC_TIPO_PERMITIDO_TOTP_USUARIO_SUP
 * TPC_TIPO_PERMITIDO_TOTP_USUARIO_SER
 * 
 * Com domínio: ESCOLHA[0=Nenhum;1=App;2=Email;3=SMS;4=App/Email/SMS;5=App/Email;6=App/SMS;7=Email/SMS]
 */
public enum ParamTipoPermitidoTotpEnum {

    NENHUM("0"),
    APP("1"),
    EMAIL("2"),
    SMS("3"),
    APP_EMAIL_SMS("4"),
    APP_EMAIL("5"),
    APP_SMS("6"),
    EMAIL_SMS("7"),
    ;

    private final String codigo;

    private ParamTipoPermitidoTotpEnum(String codigo) {
        this.codigo = codigo;
    }

    public String getCodigo() {
        return codigo;
    }

    public boolean permiteAlgum() {
        return !this.equals(NENHUM);
    }

    public boolean permiteApp() {
        return this.equals(APP) || this.equals(APP_EMAIL_SMS) || this.equals(APP_EMAIL) || this.equals(APP_SMS);
    }

    public boolean permiteEmail() {
        return this.equals(EMAIL) || this.equals(APP_EMAIL_SMS) || this.equals(APP_EMAIL) || this.equals(EMAIL_SMS);
    }

    public boolean permiteSms() {
        return this.equals(SMS) || this.equals(APP_EMAIL_SMS) || this.equals(APP_SMS) || this.equals(EMAIL_SMS);
    }

    // Reverse-lookup map para buscar o enum através de um codigo
    private static final Map<String, ParamTipoPermitidoTotpEnum> lookup = new HashMap<>();

    static {
        for (ParamTipoPermitidoTotpEnum c : ParamTipoPermitidoTotpEnum.values()) {
            lookup.put(c.getCodigo(), c);
        }
    }

    public static ParamTipoPermitidoTotpEnum get(String codigo) {
        return lookup.get(codigo);
    }

}

package com.zetra.econsig.values;

import java.util.HashMap;
import java.util.Map;

/**
 * <p>Title: PermiteValidacaoTotpEnum</p>
 * <p>Description: Enumeração para tipos de envio de TOTP.</p>
 * <p>Copyright: Copyright (c) 2024</p>
 * <p>Company: ZetraSoft</p>
 * $Author$
 * $Revision$
 * $Date$
 */
public enum PermiteValidacaoTotpEnum {

    DESABILITADO("0"),
    APP("1"),
    EMAIL("2"),
    SMS("3");

    private final String codigo;

    private PermiteValidacaoTotpEnum(String codigo) {
        this.codigo = codigo;
    }

    public String getCodigo() {
        return codigo;
    }

    // Reverse-lookup map para buscar o enum através de um codigo
    private static final Map<String, PermiteValidacaoTotpEnum> lookup = new HashMap<>();

    static {
        for (PermiteValidacaoTotpEnum c : PermiteValidacaoTotpEnum.values()) {
            lookup.put(c.getCodigo(), c);
        }
    }

    public static PermiteValidacaoTotpEnum get(String codigo) {
        return lookup.get(codigo);
    }
}

package com.zetra.econsig.web.controller.autenticacao;

import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.zetra.econsig.dto.entidade.UsuarioTransferObject;
import com.zetra.econsig.exception.UsuarioControllerException;
import com.zetra.econsig.exception.ViewHelperException;
import com.zetra.econsig.helper.parametro.ParamSist;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.helper.seguranca.GoogleAuthenticatorHelper;
import com.zetra.econsig.helper.seguranca.SynchronizerToken;
import com.zetra.econsig.helper.texto.ApplicationResourcesHelper;
import com.zetra.econsig.helper.texto.TextHelper;
import com.zetra.econsig.helper.usuario.LoginHelper;
import com.zetra.econsig.helper.usuario.UsuarioHelper;
import com.zetra.econsig.helper.web.JspHelper;
import com.zetra.econsig.service.usuario.UsuarioController;
import com.zetra.econsig.values.CodedValues;
import com.zetra.econsig.values.OperacaoValidacaoTotpEnum;
import com.zetra.econsig.values.ParamTipoPermitidoTotpEnum;
import com.zetra.econsig.values.PermiteValidacaoTotpEnum;
import com.zetra.econsig.web.controller.AbstractWebController;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * <p>Title: CadastrarValidacaoWebController</p>
 * <p>Description: Controlador Web para o caso de uso CadastrarValidacao.</p>
 * <p>Copyright: Copyright (c) 2002-2017</p>
 * <p>Company: ZetraSoft</p>
 * $Author$
 * $Revision$
 * $Date$
 */
@Controller
@RequestMapping(method = { RequestMethod.POST }, value = { "/v3/cadastrarValidacaoTotp" })
public class CadastrarValidacaoTotpWebController extends AbstractWebController {

    @Autowired
    private UsuarioController usuarioController;

    @RequestMapping(params = { "acao=iniciar" })
    public String iniciar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        SynchronizerToken.saveToken(request);

        final String mensagemTotpCadastrado = ApplicationResourcesHelper.getMessage("mensagem.totp.cadastrado", responsavel);
        final String mensagemTotpRemoverCliqueAqui = ApplicationResourcesHelper.getMessage("mensagem.totp.remover.clique.aqui", responsavel);
        final String mensagemTotpCadastrarCliqueAqui = ApplicationResourcesHelper.getMessage("mensagem.totp.cadastrar.clique.aqui", responsavel);
        final String linkRet = "../v3/cadastrarValidacaoTotp?acao=iniciar";

        // Verifica se a sessão do usuário está ativa
        if (responsavel.getUsuNome() == null) {
            return "forward:/v3/expirarSistema?acao=iniciar";
        }

        final String codigoParamTipoPermitidoTotp = switch (responsavel.getTipoEntidade()) {
            case AcessoSistema.ENTIDADE_CSE, AcessoSistema.ENTIDADE_ORG -> CodedValues.TPC_TIPO_PERMITIDO_TOTP_USUARIO_CSE_ORG;
            case AcessoSistema.ENTIDADE_CSA, AcessoSistema.ENTIDADE_COR -> CodedValues.TPC_TIPO_PERMITIDO_TOTP_USUARIO_CSA_COR;
            case AcessoSistema.ENTIDADE_SUP -> CodedValues.TPC_TIPO_PERMITIDO_TOTP_USUARIO_SUP;
            case AcessoSistema.ENTIDADE_SER -> CodedValues.TPC_TIPO_PERMITIDO_TOTP_USUARIO_SER;
            default -> null;
        };
        final String valorParamTipoPermitidoTotp = (String) ParamSist.getInstance().getParam(codigoParamTipoPermitidoTotp, responsavel);
        final ParamTipoPermitidoTotpEnum paramTipoPermitidoTotp = Optional.ofNullable(ParamTipoPermitidoTotpEnum.get(valorParamTipoPermitidoTotp)).orElse(ParamTipoPermitidoTotpEnum.NENHUM);
        final boolean permiteRemoverTotp = ParamSist.paramEquals(CodedValues.TPC_PERMITE_USUARIO_REMOVER_TOTP, CodedValues.TPC_SIM, responsavel);

        if (!paramTipoPermitidoTotp.permiteAlgum()) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.totp.usuario.nao.tem.permissao", responsavel));
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        final UsuarioTransferObject usuario;
        try {
            // TODO Tratar usuário servidor
            usuario = usuarioController.findUsuario(responsavel.getUsuCodigo(), responsavel);
        } catch (UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
        if (usuario == null) {
            session.setAttribute(CodedValues.MSG_ERRO, LoginHelper.getMensagemErroLogin());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        final String usuChaveValidacaoTotp = usuario.getUsuChaveValidacaoTotp();
        final boolean possuiChaveCadastrada = !TextHelper.isNull(usuario.getUsuChaveValidacaoTotp());
        final OperacaoValidacaoTotpEnum operacoesValidacaoTotp = OperacaoValidacaoTotpEnum.get(usuario.getUsuOperacoesValidacaoTotp());

        // Configuração de uso de TOTP cadastrada no registro do usuário
        PermiteValidacaoTotpEnum permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(usuario.getUsuPermiteValidacaoTotp())).orElse(PermiteValidacaoTotpEnum.DESABILITADO);
        // Se o cadastro não tem um TOTP habilitado, verifica se na requisição está sendo habilitado um
        if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.DESABILITADO) || !possuiChaveCadastrada) {
            final String tipoEnvioTotp = request.getParameter("tipoEnvioTotp");
            if (!TextHelper.isNull(tipoEnvioTotp)) {
                permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(tipoEnvioTotp)).orElse(PermiteValidacaoTotpEnum.DESABILITADO);
            }
        }

        model.addAttribute("mensagemTotpCadastrado", mensagemTotpCadastrado);
        model.addAttribute("mensagemTotpRemoverCliqueAqui", mensagemTotpRemoverCliqueAqui);
        model.addAttribute("mensagemTotpCadastrarCliqueAqui", mensagemTotpCadastrarCliqueAqui);
        model.addAttribute("usuChaveValidacaoTotp", usuChaveValidacaoTotp);
        model.addAttribute("possuiChaveCadastrada", possuiChaveCadastrada);
        model.addAttribute("operacoesValidacaoTotp", operacoesValidacaoTotp);
        model.addAttribute("permiteValidacaoTotp", permiteValidacaoTotp);
        model.addAttribute("paramTipoPermitidoTotp", paramTipoPermitidoTotp);
        model.addAttribute("permiteRemoverTotp", permiteRemoverTotp);
        model.addAttribute("usuario", usuario);
        model.addAttribute("linkRet", linkRet);

        return viewRedirect(possuiChaveCadastrada ? "jsp/autenticacao/alterarValidacaoTotp" : "jsp/autenticacao/cadastrarValidacaoTotp", request, session, model, responsavel);
    }

    private String validarCodigoSeguranca(AcessoSistema responsavel, HttpServletRequest request, HttpSession session, Model model) {
        try {
            // Configuração de uso de TOTP cadastrada no registro do usuário
            final PermiteValidacaoTotpEnum permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(request.getParameter("tipoEnvioTotp"))).orElse(PermiteValidacaoTotpEnum.DESABILITADO);
            final String otpInformado = JspHelper.verificaVarQryStr(request, "otp");
            final String chaveValidacaoTotpProvisoria = (String) session.getAttribute(GoogleAuthenticatorHelper.CHAVE_VALIDACAO);
            final long timeInMilliseconds = Long.parseLong(JspHelper.verificaVarQryStr(request, "timeInMilliseconds"));

            if (UsuarioHelper.isTotpValidoUsuario(otpInformado, permiteValidacaoTotp, chaveValidacaoTotpProvisoria, timeInMilliseconds, responsavel)) {
                return null;
            }
        } catch (ViewHelperException ex) {
            return ex.getMessage();
        } catch (NumberFormatException ex) {
            return ApplicationResourcesHelper.getMessage("mensagem.usoIncorretoSistema", responsavel);
        }

        return ApplicationResourcesHelper.getMessage("mensagem.totp.codigo.invalido", responsavel);
    }

    @RequestMapping(params = { "acao=gerar" })
    public String gerar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

        try {
            final PermiteValidacaoTotpEnum permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(request.getParameter("tipoEnvioTotp"))).orElse(PermiteValidacaoTotpEnum.DESABILITADO);
            if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.APP)) {
                // Gera chave de validação totp da sessão do usuário
                session.setAttribute(GoogleAuthenticatorHelper.CHAVE_VALIDACAO, GoogleAuthenticatorHelper.generateSecretKey());
                session.setAttribute(CodedValues.MSG_ALERT, ApplicationResourcesHelper.getMessage("mensagem.totp.enviado.app.informe.codigo", responsavel));
            } else if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) || permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS)) {
                if (responsavel.isSer()) {
                    usuarioController.enviarOtpServidorPorEmailOuCelular(responsavel.getUsuCodigo(), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS), responsavel);
                } else {
                    usuarioController.enviarOtpUsuarioPorEmailOuCelular(responsavel.getUsuCodigo(), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS), responsavel);
                }
                session.setAttribute(CodedValues.MSG_ALERT, ApplicationResourcesHelper.getMessage(permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) ? "mensagem.totp.enviado.email.codigo" : "mensagem.totp.enviado.sms.codigo", responsavel));
            } else {
                throw new ViewHelperException("mensagem.usoIncorretoSistema", responsavel);
            }

            return iniciar(request, response, session, model);
        } catch (Exception ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=cadastrar" })
    public String cadastrar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        final String erroCodigoSeguranca = validarCodigoSeguranca(responsavel, request, session, model);
        if (erroCodigoSeguranca != null) {
            session.setAttribute(CodedValues.MSG_ERRO, erroCodigoSeguranca);
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        try {
            final OperacaoValidacaoTotpEnum operacoesValidacaoTotp = Optional.ofNullable(OperacaoValidacaoTotpEnum.get(request.getParameter("operacoesValidacaoTotp"))).orElse(OperacaoValidacaoTotpEnum.AUTORIZACAO_OPERACAO_SENSIVEL);
            final PermiteValidacaoTotpEnum permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(request.getParameter("tipoEnvioTotp"))).orElse(PermiteValidacaoTotpEnum.DESABILITADO);

            String usuChaveValidacaoTotp = null;
            if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.APP)) {
                // Recupera chave de validação totp da sessão do usuário
                usuChaveValidacaoTotp = (String) session.getAttribute(GoogleAuthenticatorHelper.CHAVE_VALIDACAO);
            } else {
                // TODO Tratar usuário servidor
                final UsuarioTransferObject usuario = usuarioController.findUsuario(responsavel.getUsuCodigo(), responsavel);
                // Chave TOTP será o email ou celular usados na habilitação do MFA, em md5, para que possa ser validado no envio
                if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL)) {
                    usuChaveValidacaoTotp = TextHelper.md5(usuario.getUsuEmail());
                } else {
                    usuChaveValidacaoTotp = TextHelper.md5(usuario.getUsuTel());
                }
            }

            // Atualiza o cadastro do usuário
            usuarioController.cadastrarChaveValidacaoTotp(usuChaveValidacaoTotp, operacoesValidacaoTotp, permiteValidacaoTotp, responsavel);

            // Atualiza a sessão do usuário
            responsavel.setUsuChaveValidacaoTotp(usuChaveValidacaoTotp);
            responsavel.setUsuOperacoesValidacaoTotp(operacoesValidacaoTotp);
            responsavel.setUsuPermiteValidacaoTotp(permiteValidacaoTotp);

        } catch (UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        // Armazena na sessão o objeto AcessoSistema para este usuário incluindo a chave de validação TOTP
        session.setAttribute(AcessoSistema.SESSION_ATTR_NAME, responsavel);
        // Remove chave de validação armazenada da sessão do usuário
        session.removeAttribute(GoogleAuthenticatorHelper.CHAVE_VALIDACAO);
        // Seta mensagem de informação de chave cadastrada
        session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.totp.cadastrado.sucesso", responsavel));

        return iniciar(request, response, session, model);
    }

    @RequestMapping(params = { "acao=remover" })
    public String remover(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        if (ParamSist.paramEquals(CodedValues.TPC_PERMITE_USUARIO_REMOVER_TOTP, CodedValues.TPC_SIM, responsavel)) {
            final String erroCodigoSeguranca = validarCodigoSeguranca(responsavel, request, session, model);
            if (erroCodigoSeguranca != null) {
                session.setAttribute(CodedValues.MSG_ERRO, erroCodigoSeguranca);
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            try {
                // Remove chave de validação TOTP
                usuarioController.removerChaveValidacaoTotp(responsavel);
            } catch (UsuarioControllerException ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            // Armazena na sessão o objeto AcessoSistema para este usuário excluindo a chave de validação TOTP
            responsavel.setUsuChaveValidacaoTotp(null);
            session.setAttribute(AcessoSistema.SESSION_ATTR_NAME, responsavel);
            session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.totp.removido.sucesso", responsavel));

            return iniciar(request, response, session, model);
        }

        session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.usoIncorretoSistema", responsavel));
        return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
    }
}


package com.zetra.econsig.web.controller.sistema;

import static com.zetra.econsig.web.filter.UrlCryptFilter.AES_INIT_VECTOR_SESSION_ATTRIBUTE;
import static com.zetra.econsig.web.filter.UrlCryptFilter.AES_KEY_SESSION_ATTRIBUTE;

import java.security.KeyPair;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import javax.crypto.BadPaddingException;

import org.apache.commons.lang3.StringEscapeUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.zetra.econsig.delegate.LogDelegate;
import com.zetra.econsig.dto.CustomTransferObject;
import com.zetra.econsig.dto.TransferObject;
import com.zetra.econsig.dto.entidade.UsuarioTransferObject;
import com.zetra.econsig.exception.ViewHelperException;
import com.zetra.econsig.exception.ZetraException;
import com.zetra.econsig.helper.criptografia.AES;
import com.zetra.econsig.helper.criptografia.RSA;
import com.zetra.econsig.helper.log.Log;
import com.zetra.econsig.helper.margem.ControleConsulta;
import com.zetra.econsig.helper.parametro.ParamSist;
import com.zetra.econsig.helper.seguranca.AcessoRecursoHelper;
import com.zetra.econsig.helper.seguranca.AcessoRecursoHelper.AcessoRecurso;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.helper.seguranca.GeraTelaSegundaSenhaHelper;
import com.zetra.econsig.helper.seguranca.SynchronizerToken;
import com.zetra.econsig.helper.texto.ApplicationResourcesHelper;
import com.zetra.econsig.helper.texto.TextHelper;
import com.zetra.econsig.helper.usuario.LoginHelper;
import com.zetra.econsig.helper.usuario.UsuarioHelper;
import com.zetra.econsig.helper.web.JspHelper;
import com.zetra.econsig.persistence.entity.OperacaoNaoConfirmada;
import com.zetra.econsig.service.seguranca.SegurancaController;
import com.zetra.econsig.service.sistema.SistemaController;
import com.zetra.econsig.service.usuario.UsuarioController;
import com.zetra.econsig.values.CodedValues;
import com.zetra.econsig.values.Columns;
import com.zetra.econsig.values.PermiteValidacaoTotpEnum;
import com.zetra.econsig.web.controller.ControlePaginacaoWebController;
import com.zetra.econsig.web.servlet.AudioCaptchaServlet;
import com.zetra.econsig.web.servlet.ImageCaptchaServlet;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

/**
 * <p>Title: AutorizarOperacaoWebController</p>
 * <p>Description: REST Controller para autorização de operação sensível.</p>
 * <p>Copyright: Copyright (c) 2002-2017</p>
 * <p>Company: ZetraSoft</p>
 * $Author$
 * $Revision$
 * $Date$
 */
@RestController
public class AutorizarOperacaoWebController extends ControlePaginacaoWebController {
    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(AutorizarOperacaoWebController.class);

    @Autowired
    private UsuarioController usuarioController;

    @Autowired
    private SistemaController sistemaController;

    @Autowired
    private SegurancaController segurancaController;

    @RequestMapping("/v3/verificarOperacao")
    @Produces({ MediaType.APPLICATION_JSON })
    public Map<String, String> verificarOperacao(@RequestParam(value="uri") String uri, HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final Map<String, String> result = new HashMap<>();
        try {
            final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
            final AcessoRecurso recursoAcessado = obterRecursoAcessado(uri, responsavel, request);

            result.put("requerAutorizacao", verificarExigenciaAutorizacao(recursoAcessado, responsavel));

            if (verificarExigenciaCaptcha(recursoAcessado, responsavel)) {
                boolean exibeCaptcha = false;
                boolean exibeCaptchaAvancado = false;
                boolean exibeCaptchaDeficiente = false;

                final boolean defVisual = responsavel.isDeficienteVisual();
                if (!defVisual) {
                    exibeCaptcha = ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
                    exibeCaptchaAvancado = exibeCaptcha ? false : ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_AVANCADO_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
                } else {
                    exibeCaptchaDeficiente = ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_DEFICIENTE_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
                }
                // O captcha default deve ser solicitado mesmo que não tenha nenhum parâmetro de captcha configurado
                if (!exibeCaptcha && !exibeCaptchaAvancado && !exibeCaptchaDeficiente) {
                    exibeCaptcha = true;
                }
                result.put("requerCaptcha", exibeCaptcha ? "S" : "N");
                result.put("requerCaptchaAvancado", exibeCaptchaAvancado ? "S" : "N");
                result.put("requerCaptchaDeficiente", exibeCaptchaDeficiente ? "S" : "N");
            }
        } catch (final Exception ex) {
            // DESENV-21330 : força pedir senha para não correr o risco de algum erro permitir a inclusão indevidamente
            result.put("requerAutorizacao", CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_SIM);
            LOG.error(ex.getMessage(), ex);
        }
        return result;
    }

    @RequestMapping("/v3/autorizarOperacao")
    public Map<String, String> autorizarOperacao(@RequestParam(value="uri") String uri, @RequestParam(value = "username") String username, @RequestParam(value = "password") String password, @RequestParam(value = "validarSenha") boolean validarSenha, @RequestParam(value = "validarCaptcha") boolean validarCaptcha, HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final Map<String, String> result = new HashMap<>();
        try {
            final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
            final AcessoRecurso recursoAcessado = obterRecursoAcessado(uri, responsavel, request);
            String exigeAutorizacaoOperacao = CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_NAO;
            boolean exigeCaptchaOperacao = false;
            if (validarSenha) {
                exigeAutorizacaoOperacao = verificarExigenciaAutorizacao(recursoAcessado, responsavel);
            }
            if (validarCaptcha) {
                exigeCaptchaOperacao = verificarExigenciaCaptcha(recursoAcessado, responsavel);
            }

            result.put("prosseguir", "S");

            if (!CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_NAO.equals(exigeAutorizacaoOperacao)) {
                final String mensagemErro = validarAutorizacao(exigeAutorizacaoOperacao, username, password, recursoAcessado, responsavel, request, session);
                if (!TextHelper.isNull(mensagemErro)) {
                    result.put("prosseguir", "N");
                    result.put("mensagem", mensagemErro);
                    return result;
                }
            }

            if (exigeCaptchaOperacao) {
                final String mensagemErro = validarCaptchaOperacoesLiberacaoMargem(request, response, session, model, responsavel);
                if (!TextHelper.isNull(mensagemErro)) {
                    result.put("prosseguir", "N");
                    result.put("mensagem", mensagemErro);
                }
            }
        } catch (final Exception ex) {
            // DESENV-21330 : força o bloqueio para não correr o risco de algum erro permitir a inclusão indevidamente
            result.put("prosseguir", "N");
            result.put("mensagem", ex.getMessage());
            LOG.error(ex.getMessage(), ex);
        }

        return result;
    }

    @RequestMapping("/v3/verDetalheOperacao")
    public Map<String, String> verDetalheOperacao(@RequestParam(value="oncCodigo") String oncCodigo, HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final Map<String, String> result = new HashMap<>();
        try {
            final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

            if (!SynchronizerToken.isTokenValid(request)) {
                result.put("mensagem", ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return result;
            }

            final OperacaoNaoConfirmada opNaoConfirmada = sistemaController.findOperacaoNaoConfirmada(oncCodigo, responsavel);

            result.put("oncDetalhe", opNaoConfirmada.getOncDetalhe());
        } catch (final Exception ex) {
            result.put("mensagem", ex.getMessage());
            LOG.warn(ex.getMessage(), ex);
        }

        return result;
    }

    private AcessoRecurso obterRecursoAcessado(String uri, AcessoSistema responsavel, HttpServletRequest request) {
        if (responsavel.isSessaoValida()) {
            return AcessoRecursoHelper.identificarAcessoRecurso(getURIFromURL(uri, request), request.getParameterMap(), responsavel);
        }
        return null;
    }

    private String verificarExigenciaAutorizacao(AcessoRecurso recursoAcessado, AcessoSistema responsavel) {
        String exigeSenhaAutorizacao = CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_NAO;
        if (recursoAcessado != null) {
            boolean fimFluxo = recursoAcessado.isAcrFimFluxo();

            if (recursoAcessado.exigeSenhaOpeSensiveis(responsavel)) {
                // Se não é o fim do fluxo, porém é um recurso "acao=efetivarAcao", então verifica se a função acessada
                // exige motivo de operação, pois caso não exija, é feito um redirecionamento para o recurso do fim fluxo
                if ((!fimFluxo && "acao".equals(recursoAcessado.getAcrParametro()) && "efetivarAcao".equals(recursoAcessado.getAcrOperacao())) && !isExigeMotivoOperacao(recursoAcessado.getFunCodigo(), responsavel)) {
                    fimFluxo = true;
                }

                if (fimFluxo) {
                    if (recursoAcessado.funcaoExigeSegundaSenha(responsavel)) {
                        exigeSenhaAutorizacao = CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_SIM;
                    } else if (recursoAcessado.funcaoExigePropriaSenha(responsavel)) {
                        exigeSenhaAutorizacao = CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_PROPRIA;
                    } else if (recursoAcessado.adicionarFuncaoFilaAutorizacao(responsavel)) {
                        exigeSenhaAutorizacao = CodedValues.OPERACAO_ADICIONA_FILA_SEGUNDA_SENHA;
                    }
                }
            }

            // Verifica se deve solicitar segunda senha por motivo de segurança para funções que podem liberar margem
            if (fimFluxo && !CodedValues.OPERACAO_ADICIONA_FILA_SEGUNDA_SENHA.equals(exigeSenhaAutorizacao) && segurancaController.exigirSegundaSenhaOperacoesLiberacaoMargem(responsavel)) {
                exigeSenhaAutorizacao = CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_SIM;
            }
        }
        return exigeSenhaAutorizacao;
    }

    private boolean verificarExigenciaCaptcha(AcessoRecurso recursoAcessado, AcessoSistema responsavel) {
        if (recursoAcessado != null) {
            final boolean fimFluxo = recursoAcessado.isAcrFimFluxo();
            if (fimFluxo && segurancaController.exigirCaptchaOperacoesLiberacaoMargem(responsavel)) {
                return true;
            }
        }
        return false;
    }

    private String validarAutorizacao(String exigeAutorizacaoOperacao, String username, String password, AcessoRecurso recursoAcessado, AcessoSistema responsavel, HttpServletRequest request, HttpSession session) {
        boolean exigePropriaSenha = false;
        if (CodedValues.OPERACAO_EXIGE_SEGUNDA_SENHA_PROPRIA.equals(exigeAutorizacaoOperacao)) {
            username = responsavel.getUsuLogin();
            exigePropriaSenha = true;
        } else if (TextHelper.isNull(username)) {
            return ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel);
        }

        try {
            final CustomTransferObject usuario = new CustomTransferObject();
            List<TransferObject> usuarios = UsuarioHelper.localizarUsuario(username, responsavel);

            if ((usuarios == null)  || usuarios.isEmpty()) {
                return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.senha.invalida", responsavel);
            }

            String funCodigo = responsavel.getFunCodigo();
            if (TextHelper.isNull(funCodigo) && recursoAcessado != null) {
                funCodigo = recursoAcessado.getFunCodigo();
            }

            if (!exigePropriaSenha) {
                final List<TransferObject> usuarioProprio = usuarios.stream().filter(usu -> usu.getAttribute(Columns.USU_CODIGO).equals(responsavel.getUsuCodigo())).collect(Collectors.toList());

                if ((usuarioProprio != null)  && !usuarioProprio.isEmpty() && !responsavel.isValidaTotp(true)) {
                    return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.diferente.autorizar.operacao", responsavel);
                }

                if (responsavel.isCseSup()) {
                    usuarios = usuarios.stream().filter(usu -> !TextHelper.isNull(usu.getAttribute(Columns.UCE_CSE_CODIGO)) || !TextHelper.isNull(usu.getAttribute(Columns.USP_CSE_CODIGO))).collect(Collectors.toList());

                    if ((usuarios == null)  || usuarios.isEmpty()) {
                        return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.pode.autorizar.operacao", responsavel);
                    }
                } else if (responsavel.isOrg()) {
                    usuarios = usuarios.stream().filter(usu -> (!TextHelper.isNull(usu.getAttribute(Columns.UCE_CSE_CODIGO)) || !TextHelper.isNull(usu.getAttribute(Columns.USP_CSE_CODIGO)) || (!TextHelper.isNull(usu.getAttribute(Columns.UOR_ORG_CODIGO)) && responsavel.getOrgCodigo().equals(usu.getAttribute(Columns.UOR_ORG_CODIGO))))).collect(Collectors.toList());

                    if ((usuarios == null)  || usuarios.isEmpty()) {
                        return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.pode.autorizar.operacao", responsavel);
                    }
                } else if (responsavel.isCsa()) {
                    List<TransferObject> usuariosTemp = usuarios.stream().filter(usu -> !TextHelper.isNull(usu.getAttribute(Columns.UCA_CSA_CODIGO))).collect(Collectors.toList());

                    if ((usuariosTemp == null)  || usuariosTemp.isEmpty()) {
                        return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.pode.autorizar.operacao", responsavel);
                    } else {
                        usuariosTemp = usuariosTemp.stream().filter(usu -> responsavel.getCsaCodigo().equals(usu.getAttribute(Columns.UCA_CSA_CODIGO))).collect(Collectors.toList());

                        if ((usuariosTemp == null)  || usuariosTemp.isEmpty()) {
                            return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.pode.autorizar.operacao", responsavel);
                        }
                    }

                    usuarios = usuariosTemp;
                } else if (responsavel.isCor()) {
                    usuarios = usuarios.stream().filter(usu -> (((!TextHelper.isNull(usu.getAttribute(Columns.UCA_CSA_CODIGO)) && responsavel.getCsaCodigo().equals(usu.getAttribute(Columns.UCA_CSA_CODIGO))) || (!TextHelper.isNull(usu.getAttribute(Columns.UCO_COR_CODIGO)) && responsavel.getCorCodigo().equals(usu.getAttribute(Columns.UCO_COR_CODIGO)))))).collect(Collectors.toList());
                    if ((usuarios == null)  || usuarios.isEmpty()) {
                        return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.nao.pode.autorizar.operacao", responsavel);
                    }
                }

                // Verifica se o usuário está bloqueado ou cancelado (removido)
                final List<TransferObject> usuariosExcluidos = usuarios.stream().filter(usu -> !TextHelper.isNull(usu.getAttribute(Columns.USU_STU_CODIGO)) && CodedValues.STU_EXCLUIDO.equals(usu.getAttribute(Columns.USU_STU_CODIGO))).collect(Collectors.toList());

                if ((usuariosExcluidos != null)  && !usuariosExcluidos.isEmpty()) {
                    return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.senha.invalida", responsavel);
                }

                final List<TransferObject> usuariosBloqueados = usuarios.stream().filter(usu -> !TextHelper.isNull(usu.getAttribute(Columns.USU_STU_CODIGO)) && CodedValues.STU_CODIGOS_INATIVOS.contains(usu.getAttribute(Columns.USU_STU_CODIGO))).collect(Collectors.toList());
                if ((usuariosBloqueados != null)  && !usuariosBloqueados.isEmpty()) {
                    return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.bloqueado.autorizar.operacao", responsavel);
                }
            }

            // Decriptografa a senha informada
            final KeyPair keyPair = LoginHelper.getRSAKeyPair(request);
            String senhaAberta = null;
            AcessoSistema usuAutentica = null;
            try {
                senhaAberta = RSA.decrypt(password, keyPair.getPrivate());
            } catch (final BadPaddingException ex) {
                return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.senha.invalida", responsavel);
            }

            if (responsavel.isValidaTotp(true)) {
                usuario.setAtributos(usuarios.get(0).getAtributos());

                try {
                    final long timeInMilliseconds = Long.parseLong(JspHelper.verificaVarQryStr(request, "timeInMilliseconds"));

                    if (!UsuarioHelper.isTotpValidoUsuario(senhaAberta, responsavel.getUsuPermiteValidacaoTotp(), null, timeInMilliseconds, responsavel)) {
                        return ApplicationResourcesHelper.getMessage("mensagem.totp.codigo.invalido", responsavel);
                    }
                } catch (ViewHelperException ex) {
                    return ex.getMessage();
                } catch (NumberFormatException ex) {
                    return ApplicationResourcesHelper.getMessage("mensagem.usoIncorretoSistema", responsavel);
                }
            } else {
                final List<UsuarioTransferObject> usuarioTOs = usuarios.stream().map(usu -> {final UsuarioTransferObject usuTransf = new UsuarioTransferObject(); usuTransf.setAtributos(usu.getAtributos()); return usuTransf;}).collect(Collectors.toList());
                // configura AcessoSistema para o primeiro usuário temporáriamente. Após autenticação, seta este para do usuário correto.
                usuAutentica = new AcessoSistema(usuarioTOs.get(0).getUsuCodigo());
                usuAutentica.setIpUsuario((String) usuarioTOs.get(0).getAttribute(Columns.USU_IP_ACESSO));
                usuarios = UsuarioHelper.validarSenhaUsuarios(senhaAberta, usuarioTOs, false, false, null, usuAutentica);
                if ((usuarios == null) || usuarios.isEmpty()) {
                    return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.senha.invalida", responsavel);
                }
            }

            usuario.setAtributos(usuarios.get(0).getAtributos());
            if (usuAutentica != null) {
                usuAutentica.setUsuCodigo((String) usuario.getAttribute(Columns.USU_CODIGO));
                usuAutentica.setIpUsuario((String) usuario.getAttribute(Columns.USU_IP_ACESSO));
            }

            // se sistema está configurado para bloquear automaticamente usuário na sua próxima autenticação, faz a verficação de bloqueio.
            if(!exigePropriaSenha && ParamSist.getBoolParamSist(CodedValues.TPC_BLOQUEIA_USU_INATIVIDADE_PROXIMA_AUTENTICACAO, responsavel) &&
            		UsuarioHelper.bloqueioAutomaticoPorInatividade((String) usuario.getAttribute(Columns.USU_CODIGO), responsavel)) {
            	return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.bloqueado.autorizar.operacao", responsavel);
            }

            final String usuCodigo = usuario.getAttribute(Columns.USU_CODIGO).toString();
            final String usuIpAcesso = (usuario.getAttribute(Columns.USU_IP_ACESSO) != null ? usuario.getAttribute(Columns.USU_IP_ACESSO).toString() : "");
            final String usuDdnsAcesso = (usuario.getAttribute(Columns.USU_DDNS_ACESSO) != null ? usuario.getAttribute(Columns.USU_DDNS_ACESSO).toString() : "");

            String expirou = usuario.getAttribute("EXPIROU") != null ? usuario.getAttribute("EXPIROU").toString() : "1";

            // Se validou usuário no SSO, expiração de senha deve ser considerada do SSO
            if (!TextHelper.isNull(usuario.getAttribute(Columns.USU_AUTENTICA_SSO)) && CodedValues.TPC_SIM.equals(usuario.getAttribute(Columns.USU_AUTENTICA_SSO))) {
                expirou = "0";
            }

            if ("1".equals(expirou)) {
                return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.senha.expirada.autorizar.operacao", responsavel);
            }

            UsuarioHelper.obterTipoEntidade(usuario);
            final String tipo = (String) usuario.getAttribute("TIPO_ENTIDADE");
            final String entidade = (String) usuario.getAttribute("COD_ENTIDADE");

            if (tipo == null) {
                return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.invalido.autorizar.operacao", responsavel);
            }

            if (!usuarioController.usuarioTemPermissao(usuCodigo, funCodigo, tipo, responsavel)) {
                return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.sem.permissao.autorizar.operacao", responsavel);
            }

            // Verifica se o perfil do usuário não está bloqueado
            final String perCodigo = (String)usuario.getAttribute(Columns.UPE_PER_CODIGO);
            if ((perCodigo != null) && !"".equals(perCodigo)) {
                final Short upeStatus = usuarioController.getStatusPerfil(tipo, entidade, perCodigo, responsavel);
                if ((upeStatus == null) || !upeStatus.equals(CodedValues.STS_ATIVO)) {
                    return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.bloqueado.autorizar.operacao", responsavel);
                }
            }

            try {
                // Verifica obrigatoriedade e validade do IP/DDNS de acesso
                UsuarioHelper.verificarIpDDNSAcesso(tipo, entidade, JspHelper.getRemoteAddr(request), usuIpAcesso, usuDdnsAcesso, usuCodigo, responsavel);
            } catch (final ViewHelperException vex) {
                return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.acesso.invalido.autorizar.operacao", responsavel);
            }

            // Cria o responsável pela confirmação com a segunda senha
            final AcessoSistema segundoResponsavel = new AcessoSistema(usuCodigo, JspHelper.getRemoteAddr(request), JspHelper.getRemotePort(request));
            segundoResponsavel.setTipoEntidade(tipo);
            segundoResponsavel.setCodigoEntidade(entidade);
            segundoResponsavel.setUsuNome(usuario.getAttribute(Columns.USU_NOME).toString());
            segundoResponsavel.setUsuLogin(usuario.getAttribute(Columns.USU_LOGIN).toString());
            segundoResponsavel.setFunCodigo(funCodigo);
            session.setAttribute(GeraTelaSegundaSenhaHelper.RESPONSAVEL_2A_SENHA, segundoResponsavel);

            // Define observação para gravação de ocorrência de autorização com senha: será consumido pelas operações
            final StringBuilder ocaObs = new StringBuilder().append(ApplicationResourcesHelper.getMessage("mensagem.confirmacao.operacao.sensivel", responsavel));
            if (responsavel.isValidaTotp(true)) {
                ocaObs.append(" ").append(ApplicationResourcesHelper.getMessage("mensagem.confirmacao.operacao.com.codigo.seguranca", responsavel));
            } else if (exigePropriaSenha) {
                ocaObs.append(" ").append(ApplicationResourcesHelper.getMessage("mensagem.confirmacao.operacao.com.propria.senha", responsavel));
            } else {
                ocaObs.append(" ").append(ApplicationResourcesHelper.getMessage("mensagem.confirmacao.operacao.com.segunda.senha", responsavel));
            }
            ocaObs.append(" ").append(recursoAcessado.getFunDescricao());
            session.setAttribute(GeraTelaSegundaSenhaHelper.OCA_OBS_2A_SENHA, ocaObs.toString());

            // Grava log de autorização de operação sensível
            final LogDelegate logDelegate = new LogDelegate(responsavel, Log.SISTEMA, Log.AUTORIZA_OP_2A_SENHA, Log.LOG_INFORMACAO);
            String logObs = "";
            if (responsavel.isValidaTotp(true)) {
                logObs = ApplicationResourcesHelper.getMessage("mensagem.confirmacao.operacao.com.codigo.seguranca", responsavel);
            } else if (exigePropriaSenha) {
                logObs = ApplicationResourcesHelper.getMessage("mensagem.confirmacao.operacao.com.propria.senha", responsavel);
            } else {
                logObs = ApplicationResourcesHelper.getMessage("mensagem.confirmacao.operacao.com.segunda.senha", responsavel);
            }
            logDelegate.setResponsavel(segundoResponsavel);
            logDelegate.add(logObs);
            logDelegate.write();

            // Pula o filtro de segurança
            session.setAttribute(AcessoSistema.SEGUNDA_SENHA_AUTENTICADA, Boolean.TRUE);

        } catch (final ZetraException ex) {
            if ((ex.getMessageKey() == null) || !"mensagem.erro.usuario.senha.invalida".equals(ex.getMessageKey())) {
                // Grava no console de erro exceção que não é de senha inválida para que possa ser analisada
                LOG.error(ex.getMessage(), ex);
            }
            return ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.senha.invalida", responsavel);
        }

        return null;
    }

    private static String getURIFromURL(String url, HttpServletRequest request) {
    	final String context = request.getContextPath();
        final HttpSession session = request.getSession();
        final byte[] key = (byte[]) session.getAttribute(AES_KEY_SESSION_ATTRIBUTE);
        final byte[] iv = (byte[]) session.getAttribute(AES_INIT_VECTOR_SESSION_ATTRIBUTE);

        if (key != null && iv != null) {
        	try {
				final String uri = new String(Base64.getDecoder().decode(JspHelper.verificaVarQryStr(request, "xyz")));
				String plainUrl = StringEscapeUtils.unescapeHtml4(AES.decryptText(key, iv, uri));

				if (!TextHelper.isNull(plainUrl)) {
					while (plainUrl.charAt(0) == '.') {
						plainUrl = plainUrl.substring(1);
					}

					return plainUrl;
				}
			} catch (final Exception e) {
				// Não conseguiu realizar o decode, deve ser ignorado
			}
        }

        return url.substring(url.indexOf(context) + context.length(), (url.indexOf('?') > 0 ? url.indexOf('?') : url.length()));
    }

    protected String validarCaptchaOperacoesLiberacaoMargem(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model, AcessoSistema responsavel) {
        String msgRetorno = "";
        final String usuCodigo = responsavel.getUsuCodigo();

        final boolean defVisual = responsavel.isDeficienteVisual();
        if (!defVisual) {
            if (ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_AVANCADO_TELA_LOGIN, CodedValues.TPC_SIM, responsavel)) {
                final String remoteAddr = request.getRemoteAddr();

                if (!isValidCaptcha(request.getParameter("g-recaptcha-response"), remoteAddr, responsavel)) {
                    msgRetorno = ApplicationResourcesHelper.getMessage("mensagem.erro.captcha.invalido", responsavel);
                }
            } else {
                if (ImageCaptchaServlet.armazenaCaptcha(session.getId(), (String) session.getAttribute(ImageCaptchaServlet.IMAGE_CAPTCHA_SESSION_KEY))
                        && !ImageCaptchaServlet.validaCaptcha(session.getId(), request.getParameter("captcha"))) {
                    msgRetorno = ApplicationResourcesHelper.getMessage("mensagem.erro.captcha.invalido", responsavel);
                }
                session.removeAttribute(ImageCaptchaServlet.IMAGE_CAPTCHA_SESSION_KEY);
            }
        } else {
            final boolean exigeCaptchaDeficiente = ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_DEFICIENTE_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
            if (exigeCaptchaDeficiente) {
                final String captchaAnswer = request.getParameter("captcha");

                if (captchaAnswer == null) {
                    msgRetorno = ApplicationResourcesHelper.getMessage("mensagem.erro.captcha.invalido", responsavel);
                }

                final String captchaCode   = (String) session.getAttribute(AudioCaptchaServlet.AUDIO_CAPTCHA_SESSION_KEY);
                if ((captchaCode == null) || !captchaCode.equalsIgnoreCase(captchaAnswer)) {
                    msgRetorno = ApplicationResourcesHelper.getMessage("mensagem.erro.captcha.invalido", responsavel);
                }
                session.removeAttribute(AudioCaptchaServlet.AUDIO_CAPTCHA_SESSION_KEY);
            }
        }

        if (TextHelper.isNull(msgRetorno)) {
            ControleConsulta.getInstance().somarValorCaptcha(usuCodigo);
        }
        return msgRetorno;
    }

    @RequestMapping("/v3/enviarOtpOperacao")
    @Produces({ MediaType.APPLICATION_JSON })
    public Map<String, String> enviarOtpOperacao(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final Map<String, String> result = new HashMap<>();
        try {
            final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
            final PermiteValidacaoTotpEnum permiteValidacaoTotp = responsavel.getUsuPermiteValidacaoTotp();
            usuarioController.enviarOtpUsuarioPorEmailOuCelular(responsavel.getUsuCodigo(), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS), responsavel);
            result.put("mensagemInfo", ApplicationResourcesHelper.getMessage(permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) ? "mensagem.totp.enviado.email.codigo" : "mensagem.totp.enviado.sms.codigo", responsavel));
        } catch (final Exception ex) {
            result.put("mensagemErro", ex.getMessage());
            LOG.error(ex.getMessage(), ex);
        }
        return result;
    }
}


package com.zetra.econsig.web.controller.usuario;

import java.sql.Date;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import com.zetra.econsig.dto.CustomTransferObject;
import com.zetra.econsig.dto.TransferObject;
import com.zetra.econsig.dto.entidade.EnderecoFuncaoTransferObject;
import com.zetra.econsig.dto.entidade.OcorrenciaUsuarioTransferObject;
import com.zetra.econsig.dto.entidade.UsuarioTransferObject;
import com.zetra.econsig.exception.ParametroControllerException;
import com.zetra.econsig.exception.UsuarioControllerException;
import com.zetra.econsig.exception.ViewHelperException;
import com.zetra.econsig.exception.ZetraException;
import com.zetra.econsig.helper.email.EnviaEmailHelper;
import com.zetra.econsig.helper.parametro.ParamSist;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.helper.seguranca.FuncaoExigeMotivo;
import com.zetra.econsig.helper.seguranca.SynchronizerToken;
import com.zetra.econsig.helper.senha.GeradorSenhaUtil;
import com.zetra.econsig.helper.senha.SenhaHelper;
import com.zetra.econsig.helper.texto.ApplicationResourcesHelper;
import com.zetra.econsig.helper.texto.DateHelper;
import com.zetra.econsig.helper.texto.LocaleHelper;
import com.zetra.econsig.helper.texto.TextHelper;
import com.zetra.econsig.helper.usuario.UsuarioHelper;
import com.zetra.econsig.helper.web.JspHelper;
import com.zetra.econsig.helper.web.ParamSession;
import com.zetra.econsig.service.convenio.ConvenioController;
import com.zetra.econsig.service.parametro.ParametroController;
import com.zetra.econsig.service.servico.ServicoController;
import com.zetra.econsig.service.usuario.UsuarioController;
import com.zetra.econsig.values.CodedValues;
import com.zetra.econsig.values.Columns;
import com.zetra.econsig.values.OperacaoValidacaoTotpEnum;
import com.zetra.econsig.values.PermiteValidacaoTotpEnum;
import com.zetra.econsig.webclient.sso.SSOClient;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * <p>Title: AbstractManterUsuarioPapelWebController</p>
 * <p>Description: Controlador Web base para o caso de uso Manter Usuário por papel.</p>
 * <p>Copyright: Copyright (c) 2002-2017</p>
 * <p>Company: ZetraSoft</p>
 * $Author$
 * $Revision$
 * $Date$
 */
public abstract class AbstractManterUsuarioPapelWebController extends AbstractEfetivarAcaoUsuarioWebController {
    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(AbstractManterUsuarioPapelWebController.class);

    @Autowired
    private UsuarioController usuarioController;

    @Autowired
    private ConvenioController convenioController;

    @Autowired
    private ServicoController servicoController;
    
    @Autowired
    private ParametroController parametroController;
    
    @Lazy(true)
    @Autowired
    private SSOClient ssoClient;

    @RequestMapping(params = { "acao=iniciar" })
    public String iniciar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final boolean cpfObrigatorio = ParamSist.getBoolParamSist(CodedValues.TPC_CADASTRO_CPF_OBRIGATORIO_USUARIO, responsavel);

            // Exige tipo de motivo da operacao
            final boolean exigeMotivoOperacaoUsu = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_TIPO_MOTIVO_OPERACAO_USUARIO, responsavel);
            final boolean exibeMotivoOperacao = (exigeMotivoOperacaoUsu && FuncaoExigeMotivo.getInstance().exists(responsavel.getFunCodigo(), responsavel));

            boolean podeEditarUsuDeficienteVisual = false;
            if (responsavel.isSup()) {
                podeEditarUsuDeficienteVisual = true;
            }

            boolean bloqueiaEdicaoEmail = ParamSist.getBoolParamSist(CodedValues.TPC_BLOQUEIA_EDICAO_EMAIL, responsavel);
            if (responsavel.isSup()) {
                bloqueiaEdicaoEmail = false;
            }

            final String codigo = getCodigoEntidade(request);
            final String tipo = getTipoEntidade();
            final String titulo = getTituloPagina(request, responsavel);
            final String usuCodigo = JspHelper.verificaVarQryStr(request, "usu_codigo");

            try {
                validaTipoEntidade(request, responsavel);
            } catch (final ZetraException e) {
                // Redireciona para página de erro
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            if (!TextHelper.isNull(usuCodigo)) {
                // Validação para a escalação de usuário
                final List<TransferObject> usuarios = usuarioController.listUsuarios(tipo, codigo, null, -1, -1, responsavel);
                boolean usuarioExiste = false;
                for (final TransferObject validaUsuario : usuarios) {
                    if (usuCodigo.equals(validaUsuario.getAttribute(Columns.USU_CODIGO))) {
                        usuarioExiste = true;
                        break;
                    }
                }

                if (!usuarioExiste) {
                    session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                    return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
                }
            }

            String arr_p = "";
            Map<String, Object> funcoesSession = new HashMap<>();
            try {
                if (request.getParameterValues("funcao") != null) {
                    final List<String> list = Arrays.asList(request.getParameterValues("funcao"));
                    for (final String e : list) {
                        funcoesSession.put(e, e);
                    }
                } else {
                    funcoesSession = new HashMap<>(usuarioController.selectFuncoes(usuCodigo, codigo, tipo, responsavel));
                }
            } catch (final Exception ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            }

            if (funcoesSession.size() != 0) {
                arr_p = "'" + TextHelper.join(funcoesSession.keySet().toArray(), "','") + "'";
            } else {
                arr_p = "";
            }

            List<String> usuFunCodigos = null;
            List<TransferObject> funcoes = null;
            List<TransferObject> perfis = null;

            String stu_codigo = "";
            String usu_dica_senha = "";
            String usu_email = "";
            String usu_tel = "";
            String usu_login = "";
            String usu_nome = "";
            String usu_ip_acesso = "";
            String usu_ddns_acesso = "";
            String usu_cpf = "";
            String usu_centralizador = "";
            String usu_autentica_sso = "";
            String usu_visivel = "";
            String usu_exige_certificado = "";
            String usu_matricula_inst = "";
            String usu_deficiente_visual = "";
            String perfil = "";
            String usu_permite_validacao_totp = "";
            Integer usu_qtd_consultas_margem = null;
            Date usu_data_fim_vig = null;

            boolean podeEditarUsuTel = true;
            boolean podeEditarUsuEmail = true;
            boolean podeEditarUsuExigeCertificado = false;
            try {
                podeEditarUsuExigeCertificado = (UsuarioHelper.isUsuarioCertificadoDigital(usu_login, "S", tipo, codigo, responsavel) != UsuarioHelper.isUsuarioCertificadoDigital(usu_login, "N", tipo, codigo, responsavel));
            } catch (final ViewHelperException ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            }

            try {
                // Inclusão não precisa pesquisar usuário
                if (!TextHelper.isNull(usuCodigo)) {
                    usuFunCodigos = usuarioController.getUsuarioFuncoes(usuCodigo, tipo, responsavel);
                    final UsuarioTransferObject usuario = usuarioController.findUsuario(usuCodigo, responsavel);
                    stu_codigo = usuario.getStuCodigo();
                    usu_login = CodedValues.STU_EXCLUIDO.equals(usuario.getStuCodigo()) ? usuario.getUsuTipoBloq() + "(*)" : usuario.getUsuLogin();
                    usu_nome = usuario.getUsuNome();
                    usu_cpf = usuario.getUsuCPF();
                    usu_email = usuario.getUsuEmail() == null ? "" : usuario.getUsuEmail();
                    usu_tel = usuario.getUsuTel() == null ? "" : usuario.getUsuTel();
                    usu_dica_senha = usuario.getUsuDicaSenha() == null ? "" : usuario.getUsuDicaSenha();
                    usu_ip_acesso = (usuario.getUsuIpAcesso() != null ? usuario.getUsuIpAcesso() : "");
                    usu_ddns_acesso = (usuario.getUsuDDNSAcesso() != null ? usuario.getUsuDDNSAcesso() : "");
                    usu_centralizador = (usuario.getUsuCentralizador() != null ? (String) usuario.getUsuCentralizador() : "");
                    usu_autentica_sso = (usuario.getUsuAutenticaSso() != null ? (String) usuario.getUsuAutenticaSso() : "");
                    usu_visivel = (usuario.getUsuVisivel() != null ? (String) usuario.getUsuVisivel() : "");
                    usu_exige_certificado = podeEditarUsuExigeCertificado ? usuario.getUsuExigeCertificado() : CodedValues.TPC_NAO;
                    usu_matricula_inst = usuario.getUsuMatriculaInst() == null ? "" : usuario.getUsuMatriculaInst();
                    perfil = usuarioController.findUsuarioPerfil(usuCodigo, responsavel);
                    usu_data_fim_vig = usuario.getUsuDataFimVig();
                    usu_deficiente_visual = usuario.getUsuDeficienteVisual() != null ? usuario.getUsuDeficienteVisual() : "";
                    usu_permite_validacao_totp = usuario.getUsuPermiteValidacaoTotp() != null ? usuario.getUsuPermiteValidacaoTotp() : "";
                    usu_qtd_consultas_margem = usuario.getUsuQtdConsultasMargem();

                    final PermiteValidacaoTotpEnum permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(usu_permite_validacao_totp)).orElse(PermiteValidacaoTotpEnum.DESABILITADO);
                    
                    if(!responsavel.isSup()){
                        podeEditarUsuEmail = !permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL);
                        podeEditarUsuTel = !permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS);
                    } else {
                        podeEditarUsuEmail = true;
                        podeEditarUsuTel = true;
                    }
                    
                    if (CodedValues.TPC_SIM.equals(usu_centralizador) && !responsavel.isSup()) {
                        session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.centralizador.edicao.somente.gestor", responsavel));
                        return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
                    }
                }

                // Recupera alterações do formulário para criação ou edição de usuário
                if (!"".equals(JspHelper.verificaVarQryStr(request, "USU_LOGIN"))) {
                    usu_login = JspHelper.verificaVarQryStr(request, "USU_LOGIN");
                    usu_nome = JspHelper.verificaVarQryStr(request, "USU_NOME");
                    usu_cpf = JspHelper.verificaVarQryStr(request, "USU_CPF");
                    usu_email = JspHelper.verificaVarQryStr(request, "USU_EMAIL");
                    usu_tel = JspHelper.verificaVarQryStr(request, "USU_TEL");
                    usu_dica_senha = JspHelper.verificaVarQryStr(request, "USU_DICA_SENHA");
                    usu_ip_acesso = JspHelper.verificaVarQryStr(request, "usu_ip_acesso");
                    usu_ddns_acesso = JspHelper.verificaVarQryStr(request, "usu_ddns_acesso");
                    usu_centralizador = JspHelper.verificaVarQryStr(request, "USU_CENTRALIZADOR");
                    usu_autentica_sso = JspHelper.verificaVarQryStr(request, "USU_AUTENTICA_SSO");
                    usu_exige_certificado = JspHelper.verificaVarQryStr(request, "USU_EXIGE_CERTIFICADO");
                    usu_matricula_inst = JspHelper.verificaVarQryStr(request, "USU_MATRICULA_INST");
                    perfil = JspHelper.verificaVarQryStr(request, "perfil");
                    usuFunCodigos = request.getParameterValues("funcao") != null ? Arrays.asList(request.getParameterValues("funcao")) : null;
                    usu_deficiente_visual = JspHelper.verificaVarQryStr(request, "USU_DEFICIENTE_VISUAL");
                    usu_permite_validacao_totp = JspHelper.verificaVarQryStr(request, "USU_PERMITE_VALIDACAO_TOTP");
                    usu_data_fim_vig = !TextHelper.isNull(JspHelper.verificaVarQryStr(request, "USU_DATA_FIM_VIG")) ? Date.valueOf(DateHelper.reformat(JspHelper.verificaVarQryStr(request, "USU_DATA_FIM_VIG"), LocaleHelper.getDatePattern(), "yyyy-MM-dd")) : null;
                    usu_qtd_consultas_margem = !TextHelper.isNull(JspHelper.verificaVarQryStr(request, "usuQtdConsultasMargem")) ? Integer.parseInt(JspHelper.verificaVarQryStr(request, "usuQtdConsultasMargem")) : null;
                }

                funcoes = usuarioController.lstFuncoesPermitidasUsuario(tipo, codigo, responsavel);
                perfis = usuarioController.lstPerfilSemBloqueioRepasse(tipo, codigo, usuCodigo, responsavel);

            } catch (final Exception ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                perfis = funcoes = new ArrayList<>();
            }

            List<String> perFunCodigos = null;
            int cont;
            String arrPerfis = "", arrFuncoes = "";

            for (final TransferObject next : perfis) {
                final String per_codigo = next.getAttribute(Columns.PER_CODIGO).toString();
                //String per_descricao = next.getAttribute(Columns.PER_DESCRICAO).toString();

                perFunCodigos = usuarioController.getFuncaoPerfil(tipo, codigo, per_codigo, responsavel);
                cont = 0;
                while (cont < perFunCodigos.size()) {
                    arrPerfis += "'" + per_codigo + "',";
                    arrFuncoes += "'" + perFunCodigos.get(cont) + "',";
                    cont++;
                }
            }

            if (arrPerfis.endsWith(",")) {
                arrPerfis = arrPerfis.substring(0, arrPerfis.length() - 1);
            }

            if (arrFuncoes.endsWith(",")) {
                arrFuncoes = arrFuncoes.substring(0, arrFuncoes.length() - 1);
            }

            String icnBloquearFuncoes = "desbloqueado.gif";
            List<TransferObject> bloqueadas = new ArrayList<>();
            if (!TextHelper.isNull(usuCodigo)) {
                bloqueadas = usuarioController.selectFuncoesBloqueadas(usuCodigo, responsavel);
            }

            if (bloqueadas.size() > 0) {
                icnBloquearFuncoes = "pdesbloqueado.gif";
            }

            // Se usuário está excluído não pode ser editado
            boolean readOnly = false;
            if (CodedValues.STU_EXCLUIDO.equals(stu_codigo)) {
                readOnly = true;
            }

            // Se o usuário não tem permissão para editar usuários
            if (!podeEditarUsuario(responsavel)) {
                readOnly = true;
            }

            // Cadastro de TOTP só pode ser realizado por usuário de suporte para usuário que não seja ele próprio
            // e só pode ser desabilitado, para casos onde o usuário não tenha como validar pela antiga chave
            boolean podeEditarValidacaoTotp = false;
            if (responsavel.isSup() && !responsavel.getUsuCodigo().equals(usuCodigo)) {
                podeEditarValidacaoTotp = true;
            }

            String msgAlertaCriacaoUsuarioGestor = "";
            if (AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo)) {
                msgAlertaCriacaoUsuarioGestor = ApplicationResourcesHelper.getMessage("mensagem.alerta.criacao.usuario.gestor", responsavel);
            }

            // Exibe Botao que leva ao rodapé
            final boolean exibeBotaoRodape = ParamSist.paramEquals(CodedValues.TPC_EXIBE_BOTAO_RESPONSAVEL_PELO_RODAPE_DA_PAGINA, CodedValues.TPC_SIM, responsavel);
            model.addAttribute("exibeBotaoRodape", exibeBotaoRodape);
            
            boolean exibeCampoUsuAutenticaSso = false;
            try {
    			String pcsVlr = parametroController.getParamCsa(codigo, CodedValues.TPA_USUARIO_AUTENTICA_SSO, responsavel);
    			final boolean tpaUsuAutenticaSso = !TextHelper.isNull(pcsVlr) && "S".equalsIgnoreCase(pcsVlr);
    			exibeCampoUsuAutenticaSso = responsavel.isCsa() && tpaUsuAutenticaSso && (!TextHelper.isNull(responsavel.getUsuAutenticaSso()) && responsavel.getUsuAutenticaSso().equals("S"));
    		} catch (ParametroControllerException e) {
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());                
    		}            

            // Dados do usuário
            model.addAttribute("stu_codigo", stu_codigo);
            model.addAttribute("usu_dica_senha", usu_dica_senha);
            model.addAttribute("usu_email", usu_email);
            model.addAttribute("usu_tel", usu_tel);
            model.addAttribute("usu_login", usu_login);
            model.addAttribute("usu_nome", usu_nome);
            model.addAttribute("usu_ip_acesso", usu_ip_acesso);
            model.addAttribute("usu_ddns_acesso", usu_ddns_acesso);
            model.addAttribute("usu_cpf", usu_cpf);
            model.addAttribute("usu_centralizador", usu_centralizador);
            model.addAttribute("usu_autentica_sso", usu_autentica_sso);
            model.addAttribute("usu_visivel", usu_visivel);
            model.addAttribute("usu_exige_certificado", usu_exige_certificado);
            model.addAttribute("usu_matricula_inst", usu_matricula_inst);
            model.addAttribute("usu_deficiente_visual", usu_deficiente_visual);
            model.addAttribute("perfil", perfil);
            model.addAttribute("usu_permite_validacao_totp", usu_permite_validacao_totp);
            model.addAttribute("usu_data_fim_vig", usu_data_fim_vig);

            model.addAttribute("cpfObrigatorio", cpfObrigatorio);
            model.addAttribute("exigeMotivoOperacaoUsu", exigeMotivoOperacaoUsu);
            model.addAttribute("exibeMotivoOperacao", exibeMotivoOperacao);
            model.addAttribute("podeEditarUsuDeficienteVisual", podeEditarUsuDeficienteVisual);
            model.addAttribute("bloqueiaEdicaoEmail", bloqueiaEdicaoEmail);
            model.addAttribute("codigo", codigo);
            model.addAttribute("tipo", tipo);
            model.addAttribute("titulo", titulo);
            model.addAttribute("usu_codigo", usuCodigo);
            model.addAttribute("arr_p", arr_p);
            model.addAttribute("usuFunCodigos", usuFunCodigos);
            model.addAttribute("funcoes", funcoes);
            model.addAttribute("perfis", perfis);
            model.addAttribute("arrPerfis", arrPerfis);
            model.addAttribute("arrFuncoes", arrFuncoes);
            model.addAttribute("icnBloquearFuncoes", icnBloquearFuncoes);
            model.addAttribute("podeEditarUsuExigeCertificado", podeEditarUsuExigeCertificado);
            model.addAttribute("podeEditarValidacaoTotp", podeEditarValidacaoTotp);
            model.addAttribute("podeEditarUsuEmail", podeEditarUsuEmail);
            model.addAttribute("podeEditarUsuTel", podeEditarUsuTel);
            model.addAttribute("msgAlertaCriacaoUsuarioGestor", msgAlertaCriacaoUsuarioGestor);
            model.addAttribute("usuQtdConsultasMargem", usu_qtd_consultas_margem);
            model.addAttribute("readOnly", readOnly);
            model.addAttribute("exibeCampoUsuAutenticaSso", exibeCampoUsuAutenticaSso);

            return viewRedirect("jsp/manterUsuario/editarUsuarioPapel", request, session, model, responsavel);

        } catch (final UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=inserir" })
    public String inserir(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final String tipo = getTipoEntidade();
            String codigo = getCodigoEntidade(request);
            final String perCodigo = JspHelper.verificaVarQryStr(request, "perfil");
            final String usu_ip_acesso = JspHelper.verificaVarQryStr(request, "usu_ip_acesso");
            final Object usu_ddns_acesso = JspHelper.verificaVarQryStr(request, "usu_ddns_acesso");

            // Valida o tipo de entidade, com a entidade do usuário que está criando novo usuário
            try {
                validaTipoEntidade(request, responsavel);
            } catch (final ZetraException e) {
                // Redireciona para página de erro
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            // Caso não permita inclusão de usuário sem perfil associado
            if ((TextHelper.isNull(perCodigo) || "0".equals(perCodigo)) && ParamSist.paramEquals(CodedValues.TPC_PERMITE_PERFIL_PERSONALIZADO, CodedValues.TPC_NAO, responsavel)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.informe.perfil.usuario", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            String link = getLinkInserirUsuario() + "?acao=iniciar&codigo=" + codigo + "&titulo=" + getTituloPaginaBase64(request, responsavel) + "&back=1";

            if (TextHelper.isNull(codigo)) {
                codigo = responsavel.getCodigoEntidade();
            }

            // Validar ip de acesso
            String msgErro = validaIpAcesso(request, session, tipo, codigo, usu_ip_acesso, usu_ddns_acesso);

            //Exige tipo de motivo da operacao
            final boolean exigeMotivoOperacaoUsu = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_TIPO_MOTIVO_OPERACAO_USUARIO, responsavel);
            final boolean exibeMotivoOperacao = (exigeMotivoOperacaoUsu && FuncaoExigeMotivo.getInstance().exists(responsavel.getFunCodigo(), responsavel));

            if (exigeMotivoOperacaoUsu && exibeMotivoOperacao && "".equals(JspHelper.verificaVarQryStr(request, "TMO_CODIGO"))) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.motivo.operacao.obrigatorio", responsavel);
            }
            
            final String usuCpf = JspHelper.verificaVarQryStr(request, "USU_CPF");
            final String usuLogin = JspHelper.verificaVarQryStr(request, "USU_LOGIN");
            
            // Usuário não-SUP não pode incluir usuário não-servidor bloqueado por segurança
            final boolean bloqueiaInclusaoPorSeguranca = usuarioController.bloquearInclusaoPorSeguranca(usuCpf, tipo, responsavel);
            if(bloqueiaInclusaoPorSeguranca) {            	
            	msgErro = ApplicationResourcesHelper.getMessage("mensagem.erro.nao.possivel.incluir.usuario.arg0.pois.foi.bloqueado.por.seguranca", responsavel, usuLogin);
            }

            if (msgErro.length() > 0) {
                session.setAttribute(CodedValues.MSG_ERRO, msgErro);
                request.setAttribute("url64", TextHelper.encode64(SynchronizerToken.updateTokenInURL(link, request)));
                return "jsp/redirecionador/redirecionar";
            }

            // Define o tamanho da senha ser gerada, deve respeitar o parâmetro de sistema caso cadastrado
            int tamanhoSenha = 8;
            try {
                final Object tamMinSenhaUsuario = ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_USUARIOS, responsavel);
                tamanhoSenha = (!TextHelper.isNull(tamMinSenhaUsuario)) ? Integer.parseInt(tamMinSenhaUsuario.toString()) : 8;
            } catch (final Exception ex) {
                LOG.error(ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.tamanho.senha", responsavel) + ": " + ex.getMessage());
            }

            final String usuSenha = GeradorSenhaUtil.getPassword(tamanhoSenha, tipo, responsavel);

            try {
                String usuCodigo = "";
                final UsuarioTransferObject usuario = new UsuarioTransferObject();
                usuario.setUsuDicaSenha(JspHelper.verificaVarQryStr(request, "USU_DICA_SENHA"));
                usuario.setUsuEmail(JspHelper.verificaVarQryStr(request, "USU_EMAIL"));
                usuario.setUsuTel(JspHelper.verificaVarQryStr(request, "USU_TEL"));
                usuario.setUsuLogin(JspHelper.verificaVarQryStr(request, "USU_LOGIN"));
                usuario.setUsuNome(JspHelper.verificaVarQryStr(request, "USU_NOME"));
                usuario.setUsuIpAcesso(!TextHelper.isNull(usu_ip_acesso) ? usu_ip_acesso : null);
                usuario.setUsuDDNSAcesso(!"".equals(JspHelper.verificaVarQryStr(request, "usu_ddns_acesso")) ? JspHelper.verificaVarQryStr(request, "usu_ddns_acesso") : null);
                usuario.setUsuCPF(JspHelper.verificaVarQryStr(request, "USU_CPF"));
                usuario.setUsuSenha(SenhaHelper.criptografarSenha(usuario.getUsuLogin(), usuSenha, false, responsavel));
                usuario.setStuCodigo(CodedValues.STU_ATIVO);
                if (responsavel.isSup() && !"".equals(JspHelper.verificaVarQryStr(request, "USU_CENTRALIZADOR"))) {
                    usuario.setUsuCentralizador(JspHelper.verificaVarQryStr(request, "USU_CENTRALIZADOR").toString());
                }
                if (responsavel.isSup() && !"".equals(JspHelper.verificaVarQryStr(request, "USU_VISIVEL"))) {
                    usuario.setUsuVisivel(JspHelper.verificaVarQryStr(request, "USU_VISIVEL").toString());
                }                

                boolean podeEditarUsuExigeCertificado = false;
                try {
                    podeEditarUsuExigeCertificado = (UsuarioHelper.isUsuarioCertificadoDigital(usuLogin, "S", tipo, codigo, responsavel) != UsuarioHelper.isUsuarioCertificadoDigital(usuLogin, "N", tipo, codigo, responsavel));
                } catch (final ViewHelperException ex) {
                    session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                }
                if (!TextHelper.isNull(JspHelper.verificaVarQryStr(request, "USU_EXIGE_CERTIFICADO")) && podeEditarUsuExigeCertificado) {
                    usuario.setUsuExigeCertificado(JspHelper.verificaVarQryStr(request, "USU_EXIGE_CERTIFICADO").toString());
                }
                if ((JspHelper.verificaVarQryStr(request, "USU_DEFICIENTE_VISUAL") != null) && !"".equals(JspHelper.verificaVarQryStr(request, "USU_DEFICIENTE_VISUAL"))) {
                    usuario.setUsuDeficienteVisual(JspHelper.verificaVarQryStr(request, "USU_DEFICIENTE_VISUAL").toString());
                }
                if (JspHelper.verificaVarQryStr(request, "USU_PERMITE_VALIDACAO_TOTP").equals(PermiteValidacaoTotpEnum.DESABILITADO.getCodigo()) && responsavel.isSup() && !responsavel.getUsuCodigo().equals(usuCodigo)) {
                    // Cadastro de TOTP só pode ser realizado por usuário de suporte para usuário que não seja ele próprio
                    // e só pode ser desabilitado, para casos onde o usuário não tenha como validar pela antiga chave
                    usuario.setUsuPermiteValidacaoTotp(JspHelper.verificaVarQryStr(request, "USU_PERMITE_VALIDACAO_TOTP").toString());
                }
                if (responsavel.isSup() && !TextHelper.isNull(request.getParameter("usuQtdConsultasMargem"))) {
                    usuario.setUsuQtdConsultasMargem(Integer.parseInt(request.getParameter("usuQtdConsultasMargem")));
                }

                usuario.setUsuMatriculaInst(JspHelper.verificaVarQryStr(request, "USU_MATRICULA_INST"));

                usuario.setUsuDataFimVig(!TextHelper.isNull(JspHelper.verificaVarQryStr(request, "USU_DATA_FIM_VIG")) ? Date.valueOf(DateHelper.reformat(JspHelper.verificaVarQryStr(request, "USU_DATA_FIM_VIG"), LocaleHelper.getDatePattern(), "yyyy-MM-dd")) : null);

                boolean exibeCampoUsuAutenticaSso = false;
                try {
        			String pcsVlr = parametroController.getParamCsa(codigo, CodedValues.TPA_USUARIO_AUTENTICA_SSO, responsavel);
        			final boolean tpaUsuAutenticaSso = !TextHelper.isNull(pcsVlr) && "S".equalsIgnoreCase(pcsVlr);
        			exibeCampoUsuAutenticaSso = responsavel.isCsa() && tpaUsuAutenticaSso && (!TextHelper.isNull(responsavel.getUsuAutenticaSso()) && responsavel.getUsuAutenticaSso().equals("S"));
        		} catch (ParametroControllerException e) {
        			session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());    
        		}
                if (exibeCampoUsuAutenticaSso && !"".equals(JspHelper.verificaVarQryStr(request, "USU_AUTENTICA_SSO"))) {
                    usuario.setUsuAutentiaSso(JspHelper.verificaVarQryStr(request, "USU_AUTENTICA_SSO").toString());
                }
                
                // informa o motivo da operação para ser gravado junto com a ocorrência de usuário
                CustomTransferObject tmo = null;
                if (request.getParameter("TMO_CODIGO") != null) {
                    tmo = new CustomTransferObject();
                    tmo.setAttribute(Columns.USU_CODIGO, usuCodigo);
                    tmo.setAttribute(Columns.TMO_CODIGO, JspHelper.verificaVarQryStr(request, "TMO_CODIGO"));
                    tmo.setAttribute(Columns.OUS_OBS, JspHelper.verificaVarQryStr(request, "ADE_OBS"));
                }

                //DESENV-10463: Verifica se sistema envia e-mail de inicialização de senha na criação do usuário do tipo em questão
                final boolean enviaEmailInicializacaoSenha = (((AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo)) &&
                                                        ParamSist.paramEquals(CodedValues.TPC_ENVIA_EMAIL_CRIACAO_SENHA_NOVO_USU_CSE_ORG, CodedValues.TPC_SIM, responsavel))
                                                        || ((AcessoSistema.ENTIDADE_CSA.equals(tipo) || AcessoSistema.ENTIDADE_COR.equals(tipo)) &&
                                                            ParamSist.paramEquals(CodedValues.TPC_ENVIA_EMAIL_CRIACAO_SENHA_NOVO_USU_CSA_COR, CodedValues.TPC_SIM, responsavel))
                                                        || ((AcessoSistema.ENTIDADE_SUP.equals(tipo)) &&
                                                            ParamSist.paramEquals(CodedValues.TPC_ENVIA_EMAIL_CRIACAO_SENHA_NOVO_USU_SUP, CodedValues.TPC_SIM, responsavel)));

                String msgSenha = "";

                if (enviaEmailInicializacaoSenha) {
                    String linkReinicializacao = request.getRequestURL().substring(0, request.getRequestURL().indexOf("/v3")).toString() + "/v3/recuperarSenhaUsuario";

                    linkReinicializacao += "?acao=iniciarUsuario&enti=" + getTipoEntidade();
                    linkReinicializacao = SynchronizerToken.updateTokenInURL(linkReinicializacao, request);
                    usuario.setLinkRecuperarSenha(linkReinicializacao);

                    msgSenha = "<br><font class=\"novaSenha\"> " + ApplicationResourcesHelper.getMessage("mensagem.info.novo.usuario.acessar.email.iniciar.senha", responsavel);
                } else if (ParamSist.getBoolParamSist(CodedValues.TPC_ENVIA_SENHA_EMAIL_CRIACAO_SENHA_NOVO_USU, responsavel)) {
                    msgSenha = "<br><font class=\"novaSenha\"> " + ApplicationResourcesHelper.getMessage("mensagem.usuario.senha.usuario", responsavel) + ": " + usuSenha + "</font>";
                    final String emailUsuario = JspHelper.verificaVarQryStr(request, "USU_EMAIL");

                    if (!TextHelper.isNull(emailUsuario)) {
                        EnviaEmailHelper.enviarEmailSenhaNovoUsuario(usuario, usuSenha, responsavel);
                        session.setAttribute(CodedValues.MSG_ALERT, ApplicationResourcesHelper.getMessage("mensagem.usuario.senha.usuario.enviada.email", responsavel));
                    } else {
                        session.setAttribute(CodedValues.MSG_ALERT, ApplicationResourcesHelper.getMessage("mensagem.usuario.senha.usuario.nao.enviada.email", responsavel));
                    }
                } else {
                    msgSenha = "<br><font class=\"novaSenha\"> " + ApplicationResourcesHelper.getMessage("mensagem.usuario.senha.usuario", responsavel) + ": " + usuSenha + "</font>";
                }

                if ("0".equals(perCodigo) && !ParamSist.paramEquals(CodedValues.TPC_PERMITE_PERFIL_PERSONALIZADO, CodedValues.TPC_NAO, responsavel)) {
                    final String[] funcao = request.getParameterValues("funcao");
                    final List<String> funcoes = funcao != null ? Arrays.asList(funcao) : new ArrayList<>();
                    usuCodigo = usuarioController.createUsuario(usuario, funcoes, codigo, tipo, tmo, true, usuSenha, responsavel);
                } else {
                    usuCodigo = usuarioController.createUsuario(usuario, perCodigo, codigo, tipo, tmo, true, usuSenha, true,responsavel);
                }
                
                if (podeEditarUsuario(responsavel)) {
                    // Se tem permissão de edição, redireciona para página para editar o usuário criado
                    link = getLinkEditarUsuario() + "?acao=iniciar&codigo=" + codigo + "&titulo=" + getTituloPaginaBase64(request, responsavel) + "&usu_codigo=" + usuCodigo + "&back=1";
                } else {
                    // Se não tem permissão de edição, redireciona para página para consultar o usuário criado
                    link = getLinkConsultarUsuario() + "?acao=iniciar&codigo=" + codigo + "&titulo=" + getTituloPaginaBase64(request, responsavel) + "&usu_codigo=" + usuCodigo + "&back=1";
                }

                final String emailAlertaCriacaoUsuCseOrg = (String) ParamSist.getInstance().getParam(CodedValues.TPC_EMAIL_ALERTA_CRIACAO_NOVO_USUARIO_CSE_ORG, responsavel);
                if ((AcessoSistema.ENTIDADE_CSE.equals(tipo) || AcessoSistema.ENTIDADE_ORG.equals(tipo)) && !TextHelper.isNull(emailAlertaCriacaoUsuCseOrg)) {
                    //DESENV-16952: Notificação por e-mail ao ocorrer a criação de um usuário do papel Consignante
                    EnviaEmailHelper.enviarEmailAlertaCriaNovoUsuCse(usuCodigo, responsavel);
                }
               
                session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.inserir.usuario.sucesso", responsavel) + msgSenha);

            } catch (final Exception ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                LOG.error(ex.getMessage(), ex);
            }

            request.setAttribute("url64", TextHelper.encode64(SynchronizerToken.updateTokenInURL(link, request)));
            return "jsp/redirecionador/redirecionar";

        } catch (InstantiationException | IllegalAccessException | UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=editar" })
    public String editar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final ParamSession paramSession = ParamSession.getParamSession(session);

            final String usu_codigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");
            final UsuarioTransferObject usuario = new UsuarioTransferObject(usu_codigo);
            String msg = "";
            final String novoLogin = JspHelper.verificaVarQryStr(request, "USU_LOGIN");
            final UsuarioTransferObject usuOld = usuarioController.findUsuario(usu_codigo, responsavel);

            //String operacao = JspHelper.verificaVarQryStr(request, "operacao");
            final String tipo = getTipoEntidade();
            final String vrfTipo = JspHelper.verificaVarQryStr(request, "vrfTipo");
            String codigo = getCodigoEntidade(request);
            String perCodigo = JspHelper.verificaVarQryStr(request, "perfil");
            final String usu_ip_acesso = JspHelper.verificaVarQryStr(request, "usu_ip_acesso");
            final Object usu_ddns_acesso = JspHelper.verificaVarQryStr(request, "usu_ddns_acesso");

            final String perCodigoOld = request.getParameter("perCodigoOld");

            // Valida o tipo de entidade, com a entidade do usuário que está criando novo usuário
            try {
                validaTipoEntidade(request, responsavel);
            } catch (final ZetraException e) {
                // Redireciona para página de erro
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
           
            final String link = TextHelper.encode64(SynchronizerToken.updateTokenInURL(paramSession.getLastHistory(), request));

            if (TextHelper.isNull(codigo)) {
                codigo = responsavel.getCodigoEntidade();
            }

            // Validar ip de acesso
            String msgErro = validaIpAcesso(request, session, tipo, codigo, usu_ip_acesso, usu_ddns_acesso);

            if (TextHelper.isNull(usu_codigo)) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.inexistente", responsavel);
            }
            
	        // Usuário não-SUP não pode alterar usuário não-servidor bloqueado por segurança
	        final boolean bloqueiaAlteracaoPorSeguranca = usuarioController.bloquearAlteracaoExclusaoPorSeguranca(usuOld.getStuCodigo(), tipo, responsavel);
            if(bloqueiaAlteracaoPorSeguranca) {            	
            	msgErro = ApplicationResourcesHelper.getMessage("mensagem.erro.nao.possivel.alterar.usuario.arg0.pois.foi.bloqueado.por.seguranca", responsavel, usuOld.getUsuLogin());
            }

            //Exige tipo de motivo da operacao
            final boolean exigeMotivoOperacaoUsu = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_TIPO_MOTIVO_OPERACAO_USUARIO, responsavel);
            final boolean exibeMotivoOperacao = (exigeMotivoOperacaoUsu && FuncaoExigeMotivo.getInstance().exists(responsavel.getFunCodigo(), responsavel));

            if (exigeMotivoOperacaoUsu && exibeMotivoOperacao && "".equals(JspHelper.verificaVarQryStr(request, "TMO_CODIGO"))) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.motivo.operacao.obrigatorio", responsavel);
            }

            if (msgErro.length() > 0) {
                session.setAttribute(CodedValues.MSG_ERRO, msgErro);
                request.setAttribute("url64", link);
                return "jsp/redirecionador/redirecionar";
            }

            final String usuCentralizador = (usuOld.getUsuCentralizador() != null ? (String) usuOld.getUsuCentralizador() : "");

            // verifica se usuário a ser editado é de origem do centralizador.
            // Caso sim, só pode ser editado por gestor ou via centralizador.
            if (CodedValues.TPC_SIM.equals(usuCentralizador) && !responsavel.isSup()) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.centralizador.edicao.somente.gestor", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            try {
                if (!usuOld.getUsuLogin().equals(novoLogin)) {
                    // Define o tamanho da senha ser gerada, deve respeitar o parâmetro de sistema caso cadastrado
                    int tamanhoSenha = 8;
                    try {
                        final Object tamMaxSenhaUsuario = ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_USUARIOS, responsavel);
                        tamanhoSenha = (!TextHelper.isNull(tamMaxSenhaUsuario)) ? Integer.parseInt(tamMaxSenhaUsuario.toString()) : 8;
                    } catch (final Exception ex) {
                        LOG.error(ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.tamanho.senha", responsavel) + ": " + ex.getMessage());
                    }

                    final String usuSenha = GeradorSenhaUtil.getPassword(tamanhoSenha, tipo, responsavel);
                    usuario.setUsuDataExpSenha(new java.sql.Date(Calendar.getInstance().getTimeInMillis()));
                    usuario.setUsuSenha(SenhaHelper.criptografarSenha(usuario.getUsuLogin(), usuSenha, false, responsavel));
                    msg = "<BR><font class=\"novaSenha\">" + ApplicationResourcesHelper.getMessage("mensagem.usuario.nova.senha.novo.usuario", responsavel) + ": " + usuSenha + "</font>";
                }
                usuario.setUsuDicaSenha(JspHelper.verificaVarQryStr(request, "USU_DICA_SENHA"));

                // Verifica se pode editar email e telefone
                final PermiteValidacaoTotpEnum permiteValidacaoTotp = Optional.ofNullable(PermiteValidacaoTotpEnum.get(usuOld.getUsuPermiteValidacaoTotp())).orElse(PermiteValidacaoTotpEnum.DESABILITADO);

                if(!responsavel.isSup()){
                    if (!permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL)) {
                        usuario.setUsuEmail(JspHelper.verificaVarQryStr(request, "USU_EMAIL"));
                    }
                    if (!permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS)) {
                        usuario.setUsuTel(JspHelper.verificaVarQryStr(request, "USU_TEL"));
                    }
                } else {
                    usuario.setUsuEmail(JspHelper.verificaVarQryStr(request, "USU_EMAIL"));
                    usuario.setUsuTel(JspHelper.verificaVarQryStr(request, "USU_TEL"));

                    if (permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) || permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS)) {
                     
                        String chaveOtp;

                        if(permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL)){
                            chaveOtp = TextHelper.md5(JspHelper.verificaVarQryStr(request, "USU_EMAIL"));
                        } else {
                            chaveOtp = TextHelper.md5(JspHelper.verificaVarQryStr(request, "USU_TEL"));
                        }
                        
                        usuario.setUsuChaveValidacaoTotp(chaveOtp);

                        final String otp = GeradorSenhaUtil.getPasswordNumber(CodedValues.TAM_OTP, responsavel);

                        // Criptografa OTP antes de salvar no usuário
                        final String otpCrypt = SenhaHelper.criptografarSenha(usuario.getUsuLogin(), otp, true, responsavel);

                        // Salva OTP gerado no campo provisório USU_OTP_CODIGO
                        usuario.setUsuOtpCodigo(otpCrypt);
                        usuario.setUsuOtpDataCadastro(DateHelper.getSystemDatetime());
                    }
                }


                usuario.setUsuLogin(JspHelper.verificaVarQryStr(request, "USU_LOGIN"));
                usuario.setUsuNome(JspHelper.verificaVarQryStr(request, "USU_NOME"));
                usuario.setUsuCPF(JspHelper.verificaVarQryStr(request, "USU_CPF"));

                if (request.getParameter("usu_ip_acesso") != null) {
                    usuario.setUsuIpAcesso(!TextHelper.isNull(usu_ip_acesso) ? usu_ip_acesso : null);
                }
                if (request.getParameter("usu_ddns_acesso") != null) {
                    usuario.setUsuDDNSAcesso(!"".equals(JspHelper.verificaVarQryStr(request, "usu_ddns_acesso")) ? JspHelper.verificaVarQryStr(request, "usu_ddns_acesso") : null);
                }
                if (responsavel.isSup() && !"".equals(JspHelper.verificaVarQryStr(request, "USU_CENTRALIZADOR"))) {
                    usuario.setUsuCentralizador(JspHelper.verificaVarQryStr(request, "USU_CENTRALIZADOR").toString());
                }
                if (responsavel.isSup() && !"".equals(JspHelper.verificaVarQryStr(request, "USU_VISIVEL"))) {
                    usuario.setUsuVisivel(JspHelper.verificaVarQryStr(request, "USU_VISIVEL").toString());
                }
                
                boolean exibeCampoUsuAutenticaSso = false;
                try {
        			String pcsVlr = parametroController.getParamCsa(codigo, CodedValues.TPA_USUARIO_AUTENTICA_SSO, responsavel);
        			final boolean tpaUsuAutenticaSso = !TextHelper.isNull(pcsVlr) && "S".equalsIgnoreCase(pcsVlr);
        			exibeCampoUsuAutenticaSso = responsavel.isCsa() && tpaUsuAutenticaSso && (!TextHelper.isNull(responsavel.getUsuAutenticaSso()) && responsavel.getUsuAutenticaSso().equals("S"));
        		} catch (ParametroControllerException e) {
        			session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());    
        		}
                if (exibeCampoUsuAutenticaSso && !"".equals(JspHelper.verificaVarQryStr(request, "USU_AUTENTICA_SSO"))) {
                    usuario.setUsuAutentiaSso(JspHelper.verificaVarQryStr(request, "USU_AUTENTICA_SSO").toString());
                }

                boolean podeEditarUsuExigeCertificado = false;
                try {
                    podeEditarUsuExigeCertificado = (UsuarioHelper.isUsuarioCertificadoDigital(usuario.getUsuLogin(), "S", tipo, codigo, responsavel) != UsuarioHelper.isUsuarioCertificadoDigital(usuario.getUsuLogin(), "N", tipo, codigo, responsavel));
                } catch (final ViewHelperException ex) {
                    session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                }

                final String usu_exige_certificado_old = JspHelper.verificaVarQryStr(request, "USU_EXIGE_CERTIFICADO_OLD");
                final String usu_exige_certificado = JspHelper.verificaVarQryStr(request, "USU_EXIGE_CERTIFICADO");
                if (!TextHelper.isNull(usu_exige_certificado_old) && !TextHelper.isNull(usu_exige_certificado) && !usu_exige_certificado_old.equals(usu_exige_certificado) && podeEditarUsuExigeCertificado) {
                    usuario.setUsuExigeCertificado(JspHelper.verificaVarQryStr(request, "USU_EXIGE_CERTIFICADO").toString());
                }
                usuario.setUsuMatriculaInst(JspHelper.verificaVarQryStr(request, "USU_MATRICULA_INST"));
                usuario.setUsuDataFimVig(!TextHelper.isNull(JspHelper.verificaVarQryStr(request, "USU_DATA_FIM_VIG")) ? Date.valueOf(DateHelper.reformat(JspHelper.verificaVarQryStr(request, "USU_DATA_FIM_VIG"), LocaleHelper.getDatePattern(), "yyyy-MM-dd")) : null);
                if ((JspHelper.verificaVarQryStr(request, "USU_DEFICIENTE_VISUAL") != null) && !"".equals(JspHelper.verificaVarQryStr(request, "USU_DEFICIENTE_VISUAL"))) {
                    usuario.setUsuDeficienteVisual(JspHelper.verificaVarQryStr(request, "USU_DEFICIENTE_VISUAL").toString());
                }

                if (JspHelper.verificaVarQryStr(request, "USU_PERMITE_VALIDACAO_TOTP").equals(PermiteValidacaoTotpEnum.DESABILITADO.getCodigo()) && responsavel.isSup()) {
                    // Cadastro de TOTP só pode ser realizado por usuário de suporte para usuário que não seja ele próprio
                    // e só pode ser desabilitado, para casos onde o usuário não tenha como validar pela antiga chave
                    usuario.setUsuPermiteValidacaoTotp(JspHelper.verificaVarQryStr(request, "USU_PERMITE_VALIDACAO_TOTP").toString());
                    usuario.setUsuChaveValidacaoTotp(null);
                    usuario.setUsuOtpCodigo(null);
                    usuario.setUsuOtpDataCadastro(null);
                    usuario.setUsuOperacoesValidacaoTotp(null);
                }

                if (responsavel.isSup()) {
                    usuario.setUsuQtdConsultasMargem((!TextHelper.isNull(request.getParameter("usuQtdConsultasMargem")) ? Integer.parseInt(request.getParameter("usuQtdConsultasMargem")) : null));
                }

                List<String> funcoes = null;
                if (!TextHelper.isNull(perCodigoOld) && !perCodigoOld.equals(perCodigo)) {
                    final Map<String, EnderecoFuncaoTransferObject> funcMap = usuarioController.selectFuncoes(usu_codigo, codigo, tipo, responsavel);
                    final Set<String> funSet = funcMap.keySet();
                    final String[] funcao = request.getParameterValues("funcao");
                    funcoes = (funcao != null) && (funcao.length > 0) ? Arrays.asList(funcao) : usuarioController.getFuncaoPerfil(tipo, codigo, perCodigo, responsavel);

                    if ((funSet.contains(CodedValues.FUN_USUARIO_AUDITOR) && !funcoes.contains(CodedValues.FUN_USUARIO_AUDITOR)) && !usuarioController.podeRemoverFuncAuditoria(usu_codigo, codigo, tipo, responsavel)) {
                        session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.permissao.auditoria.nao.pode.remover", responsavel));
                        return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
                    }
                }

                // informa o motivo da operação para ser gravado junto com a ocorrência de usuário
                CustomTransferObject tmo = null;
                if (request.getParameter("TMO_CODIGO") != null) {
                    tmo = new CustomTransferObject();
                    tmo.setAttribute(Columns.USU_CODIGO, usu_codigo);
                    tmo.setAttribute(Columns.TMO_CODIGO, JspHelper.verificaVarQryStr(request, "TMO_CODIGO"));
                    tmo.setAttribute(Columns.OUS_OBS, JspHelper.verificaVarQryStr(request, "ADE_OBS"));
                }

                if (TextHelper.isNull(vrfTipo) && !"".equals(tipo)) {
                    if ("0".equals(perCodigo)) {
                        perCodigo = null;
                        final String[] funcao = request.getParameterValues("funcao");
                        funcoes = funcao != null ? Arrays.asList(funcao) : new ArrayList<>();
                    } else {
                        funcoes = null;
                    }
                }

                usuarioController.updateUsuario(usuario, null, funcoes, perCodigo, tipo, codigo, tmo, responsavel);

                session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.alterar.usuario.sucesso", responsavel) + msg);
            } catch (final ParseException ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                LOG.error(ex.getMessage(), ex);
            }

            request.setAttribute("url64", link);
            return "jsp/redirecionador/redirecionar";

        } catch (InstantiationException | IllegalAccessException | UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=excluir" })
    public String excluir(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final ParamSession paramSession = ParamSession.getParamSession(session);

            final String link = TextHelper.encode64(SynchronizerToken.updateTokenInURL(paramSession.getLastHistory(), request));

            // Valida o tipo de entidade, com a entidade do usuário que está criando novo usuário
            try {
                validaTipoEntidade(request, responsavel);
            } catch (final ZetraException e) {
                // Redireciona para página de erro
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            final String usu_codigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");
            final String codigoEntidade = getCodigoEntidade(request);
            final String tipo = getTipoEntidade();

            final UsuarioTransferObject criterio = new UsuarioTransferObject(usu_codigo);
            criterio.setAttribute(getColunaCodigoEntidade(), codigoEntidade);

            //Exige tipo de motivo da operacao
            final boolean exigeMotivoOperacaoUsu = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_TIPO_MOTIVO_OPERACAO_USUARIO, responsavel);
            final boolean exibeMotivoOperacao = (exigeMotivoOperacaoUsu && FuncaoExigeMotivo.getInstance().exists(responsavel.getFunCodigo(), responsavel));

            String msgErro = "";
            if (exigeMotivoOperacaoUsu && exibeMotivoOperacao && "".equals(JspHelper.verificaVarQryStr(request, "TMO_CODIGO"))) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.motivo.operacao.obrigatorio", responsavel);
            }            

            if (msgErro.length() > 0) {
                session.setAttribute(CodedValues.MSG_ERRO, msgErro);
                request.setAttribute("url64", link);
                return "jsp/redirecionador/redirecionar";
            }

            // informa o motivo da operação para ser gravado junto com a ocorrência de usuário
            CustomTransferObject tmo = null;
            if (request.getParameter("TMO_CODIGO") != null) {
                tmo = new CustomTransferObject();
                tmo.setAttribute(Columns.USU_CODIGO, usu_codigo);
                tmo.setAttribute(Columns.TMO_CODIGO, JspHelper.verificaVarQryStr(request, "TMO_CODIGO"));
                tmo.setAttribute(Columns.OUS_OBS, JspHelper.verificaVarQryStr(request, "ADE_OBS"));
            }

            //testa se usuário centralizador. Se sim, só poderá ser removido por usuário
            //gestor do eConsig ou via centralizador
            final UsuarioTransferObject usuTrans = usuarioController.findUsuario(usu_codigo, responsavel);
            final String usuCentralizador = usuTrans.getUsuCentralizador();
            
            // Usuário não-SUP não pode excluir usuário não-servidor bloqueado por segurança
            final boolean bloqueiaExclusaoPorSeguranca = usuarioController.bloquearAlteracaoExclusaoPorSeguranca(usuTrans.getStuCodigo(), tipo, responsavel);
            
            if (((usuTrans != null) && (CodedValues.TPC_SIM.equals(usuCentralizador))) && !responsavel.isSup()) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.centralizador.exclusao.somente.gestor", responsavel));
            } else if(bloqueiaExclusaoPorSeguranca) {    
            	session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.nao.possivel.excluir.usuario.arg0.pois.foi.bloqueado.por.seguranca", responsavel, usuTrans.getUsuLogin()));
            } else {
                usuarioController.removeUsuario(criterio, tipo, tmo, responsavel);
                session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.remover.usuario.sucesso", responsavel));
            }

            request.setAttribute("url64", link);
            return "jsp/redirecionador/redirecionar";

        } catch (final UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=bloquear" })
    public String bloquear(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final ParamSession paramSession = ParamSession.getParamSession(session);

            String link = TextHelper.encode64(SynchronizerToken.updateTokenInURL(paramSession.getLastHistory(), request));

            // Valida o tipo de entidade, com a entidade do usuário que está criando novo usuário
            try {
                validaTipoEntidade(request, responsavel);
            } catch (final ZetraException e) {
                // Redireciona para página de erro
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            //Exige tipo de motivo da operacao
            final boolean exigeMotivoOperacaoUsu = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_TIPO_MOTIVO_OPERACAO_USUARIO, responsavel);
            final boolean exibeMotivoOperacao = (exigeMotivoOperacaoUsu && FuncaoExigeMotivo.getInstance().exists(responsavel.getFunCodigo(), responsavel));

            String msgErro = "";
            if (exigeMotivoOperacaoUsu && exibeMotivoOperacao && "".equals(JspHelper.verificaVarQryStr(request, "TMO_CODIGO"))) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.motivo.operacao.obrigatorio", responsavel);
            }

            if (msgErro.length() > 0) {
                session.setAttribute(CodedValues.MSG_ERRO, msgErro);
                request.setAttribute("url64", link);
                return "jsp/redirecionador/redirecionar";
            }

            final String usu_codigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");
            final String tipo = getTipoEntidade();
            String status = JspHelper.verificaVarQryStr(request, "STATUS");
            final String tmoCodigo = JspHelper.verificaVarQryStr(request, "TMO_CODIGO");
            final String ousObs = JspHelper.verificaVarQryStr(request, "ADE_OBS");

            final String msgRet = (CodedValues.STU_ATIVO.equals(status) ? ApplicationResourcesHelper.getMessage("mensagem.usuario.bloqueado.sucesso", responsavel) : ApplicationResourcesHelper.getMessage("mensagem.usuario.desbloqueado.sucesso", responsavel));
            status = (CodedValues.STU_ATIVO.equals(status) ? CodedValues.STU_BLOQUEADO : CodedValues.STU_ATIVO);

            usuarioController.bloquearDesbloquearUsuario(usu_codigo, status, tipo, tmoCodigo, ousObs, responsavel);
            session.setAttribute(CodedValues.MSG_INFO, msgRet);

            // Redireciona para a página de listagem de usuários criados pelo usuário bloqueado
            if (!CodedValues.STU_ATIVO.equals(status) && ("CSE".equalsIgnoreCase(tipo) || "ORG".equalsIgnoreCase(tipo) || "SUP".equalsIgnoreCase(tipo))) {
                link = getLinkBloquearUsuario() + "?acao=listarBloqueioUsuarioRecursivo&USU_CODIGO=" + usu_codigo + "&STATUS=" + status + "&tipo=" + tipo + "&TMO_CODIGO=" + tmoCodigo + "&ADE_OBS=" + ousObs + "&_skip_history_=true";
                link = TextHelper.encode64(SynchronizerToken.updateTokenInURL(link, request));
            }

            request.setAttribute("url64", link);
            return "jsp/redirecionador/redirecionar";

        } catch (final UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=reinicializar" })
    public String reinicializar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final ParamSession paramSession = ParamSession.getParamSession(session);
            final String link = TextHelper.encode64(SynchronizerToken.updateTokenInURL(paramSession.getLastHistory(), request));
            final String usuCodigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");

            // Valida o tipo de entidade, com a entidade do usuário que está criando novo usuário
            try {
                validaTipoEntidade(request, responsavel);
            } catch (final ZetraException e) {
                // Redireciona para página de erro
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            // Exige tipo de motivo da operacao
            final boolean exigeMotivoOperacaoUsu = ParamSist.getBoolParamSist(CodedValues.TPC_EXIGE_TIPO_MOTIVO_OPERACAO_USUARIO, responsavel) && FuncaoExigeMotivo.getInstance().exists(responsavel.getFunCodigo(), responsavel);
            final String tmoCodigo = JspHelper.verificaVarQryStr(request, "TMO_CODIGO");
            if (exigeMotivoOperacaoUsu && TextHelper.isNull(tmoCodigo)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.motivo.operacao.obrigatorio", responsavel));
                request.setAttribute("url64", link);
                return "jsp/redirecionador/redirecionar";
            }

            // informa o motivo da operação para ser gravado junto com a ocorrência de usuário
            CustomTransferObject tmo = null;
            if (!TextHelper.isNull(tmoCodigo)) {
                tmo = new CustomTransferObject();
                tmo.setAttribute(Columns.USU_CODIGO, usuCodigo);
                tmo.setAttribute(Columns.TMO_CODIGO, tmoCodigo);
                tmo.setAttribute(Columns.OUS_OBS, JspHelper.verificaVarQryStr(request, "ADE_OBS"));
            }

            // Define o tamanho da senha ser gerada, deve respeitar o parâmetro de sistema caso cadastrado
            int tamanhoSenha = 8;
            try {
                final Object tamMaxSenhaUsuario = ParamSist.getInstance().getParam(CodedValues.TPC_TAMANHO_MAX_SENHA_USUARIOS, responsavel);
                tamanhoSenha = (!TextHelper.isNull(tamMaxSenhaUsuario)) ? Integer.parseInt(tamMaxSenhaUsuario.toString()) : 8;
            } catch (final Exception ex) {
                LOG.error(ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.tamanho.senha", responsavel) + ": " + ex.getMessage());
            }

            final TransferObject usuario = usuarioController.findTipoUsuarioByCodigo(usuCodigo, responsavel);
            final String tipoEntidade = UsuarioHelper.obterTipoEntidade(usuario);

            if (!ParamSist.paramEquals(CodedValues.TPC_EMAIL_REINICIALIZACAO_SENHA, CodedValues.TPC_SIM, responsavel)) {
                final String usuSenha = GeradorSenhaUtil.getPassword(tamanhoSenha, tipoEntidade, responsavel);
                usuarioController.alterarSenha(usuCodigo, usuSenha, null, true, true, false, tmo, null, responsavel);

                final String msgSucesso = ApplicationResourcesHelper.getMessage("mensagem.senha.usuario.reinicializada", responsavel);
                final String msgSenha = "<br><font class=\"novaSenha\"> " + ApplicationResourcesHelper.getMessage("rotulo.usuario.nova.senha", responsavel) + ": " + usuSenha + "</font>";
                session.setAttribute(CodedValues.MSG_INFO, msgSucesso + msgSenha);

            } else {
                final UsuarioTransferObject dadosUsuario = usuarioController.findUsuario(usuCodigo, responsavel);

                final String stuCodigo = (String) dadosUsuario.getAttribute(Columns.USU_STU_CODIGO);

                // Usuário deve estar na situação ativo
                if (!CodedValues.STU_ATIVO.equals(stuCodigo)) {
                    session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.usuario.bloqueado", responsavel));
                } else {
                    // Encontrou usuário, verifica se possui e-mail cadastrado
                    final String usuCpf = dadosUsuario.getUsuCPF();
                    final String usuLogin = dadosUsuario.getUsuLogin();
                    final String usuEmail = dadosUsuario.getUsuEmail();
                    final boolean cpfObrigatorio = ParamSist.paramEquals(CodedValues.TPC_CADASTRO_CPF_OBRIGATORIO_USUARIO, CodedValues.TPC_SIM, responsavel);

                    if (TextHelper.isNull(usuEmail)) {
                        session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.email.nao.cadastrado", responsavel));
                    } else if (cpfObrigatorio && TextHelper.isNull(usuCpf)) {
                        session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.cpf.nao.cadastrado", responsavel));
                    } else {
                        if (!TextHelper.isNull(tipoEntidade) && !AcessoSistema.ENTIDADE_SUP.equals(tipoEntidade) && !AcessoSistema.ENTIDADE_SER.equals(tipoEntidade)) {
                            final boolean usuEmailRepeat = usuarioController.findEmailExistenteCsaCseOrgCor(usuEmail, dadosUsuario.getUsuCodigo(), responsavel);
                            if (usuEmailRepeat) {
                                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.email.usuario.csa.cse.org.cor.repetido", responsavel));
                                request.setAttribute("url64", link);
                                return "jsp/redirecionador/redirecionar";
                            }
                        }
                        try {
                            // O usuario possui e-mail, então envia email com link para alterar senha
                            String linkReinicializacao = request.getRequestURL().toString();
                            linkReinicializacao = linkReinicializacao.replace(getLinkReinicializarSenhaUsuario().replace(".", ""), "/v3/recuperarSenhaUsuario");
                            linkReinicializacao += "?acao=iniciarUsuario" + "&enti=" + getTipoEntidade();
                            linkReinicializacao = SynchronizerToken.updateTokenInURL(linkReinicializacao, request);
                            // Gera uma nova codigo de recuparação de senha
                            final String cod_Senha = SynchronizerToken.generateToken();
                            // Atualiza o codigo de recuperação de senha do usuário
                            usuarioController.alteraChaveRecupSenha(usuCodigo, cod_Senha, responsavel);
                            // Envia e-mail com link para recuperação de senha
                            usuarioController.enviaLinkReinicializarSenhaUsu(usuCodigo, usuLogin, linkReinicializacao, cod_Senha, responsavel);
                            // Inválida senha do usuário
                            usuarioController.alterarSenha(usuCodigo, GeradorSenhaUtil.getPassword(tamanhoSenha, tipoEntidade, responsavel), null, false, true, true, tmo, null, responsavel);
                            // Retorna mensagem de sucesso para o usuário
                            session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.reinicializar.senha.usuario.sucesso", responsavel, TextHelper.escondeEmail(dadosUsuario.getUsuEmail())));
                        } catch (final UsuarioControllerException ex) {
                            LOG.error(ex.getMessage(), ex);
                            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                        }
                    }
                }
            }

            request.setAttribute("url64", link);
            return "jsp/redirecionador/redirecionar";

        } catch (final UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=iniciarBloqueioUsuarioFuncaoServico" })
    public String iniciarBloqueioUsuarioFuncaoServico(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final String titulo = getTituloPagina(request, responsavel);
            final String usu_codigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");

            if (TextHelper.isNull(usu_codigo)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            final UsuarioTransferObject usu = usuarioController.findUsuario(usu_codigo, responsavel);
            final String usu_nome = usu.getUsuNome();
            final String usu_login = usu.getUsuLogin();

            final CustomTransferObject usuario = usuarioController.findTipoUsuarioByLogin(usu_login, responsavel);

            if (TextHelper.isNull(usuario)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            final String tipo = getTipoEntidade();
            final String codigo = getCodigoEntidade(request);
            final String funBloqUsuFunSvc = getFuncaoEdicaoBloqueioFuncaoServidor();

            List<TransferObject> funcoes;
            List<TransferObject> servicos;
            Map<String, List<String>> bloqueios;

            try {
                funcoes = usuarioController.lstFuncoesBloqueaveis(tipo, responsavel);

                if ((tipo == AcessoSistema.ENTIDADE_CSE) || (tipo == AcessoSistema.ENTIDADE_SUP)) {
                    final CustomTransferObject criterio = new CustomTransferObject();
                    criterio.setAttribute(Columns.SVC_ATIVO, CodedValues.STS_ATIVO);
                    servicos = convenioController.lstServicos(criterio, responsavel);
                } else if (tipo == AcessoSistema.ENTIDADE_CSA) {
                    servicos = servicoController.selectServicosCsa(codigo, responsavel);
                } else if (tipo == AcessoSistema.ENTIDADE_COR) {
                    servicos = servicoController.selectServicosCorrespondente(codigo, responsavel);
                } else if (tipo == AcessoSistema.ENTIDADE_ORG) {
                    servicos = servicoController.selectServicosOrgao(codigo, responsavel);
                } else {
                    servicos = new ArrayList<>();
                }

                final List<TransferObject> bloqueadas = usuarioController.selectFuncoesBloqueadas(usu_codigo, getTipoEntidade(), responsavel);

                // Monta HashMap dos bloqueios existentes, tendo serviço como chave e List de funções como valor.
                bloqueios = new HashMap<>();

                for (final TransferObject bloq : bloqueadas) {
                    if (!bloqueios.containsKey(bloq.getAttribute(Columns.BUF_FUN_CODIGO).toString())) {
                        bloqueios.put(bloq.getAttribute(Columns.BUF_FUN_CODIGO).toString(), new ArrayList<>());
                    }
                    bloqueios.get(bloq.getAttribute(Columns.BUF_FUN_CODIGO).toString()).add(bloq.getAttribute(Columns.BUF_SVC_CODIGO).toString());
                }

            } catch (final Exception ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                funcoes = new ArrayList<>();
                servicos = new ArrayList<>();
                bloqueios = new HashMap<>();
            }

            String msgErro = "";
            if ((funcoes.size() == 0) && (servicos.size() == 0)) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.erro.nenhuma.fun.nenhum.svc.pode.ser.bloqueado", responsavel);
            } else if (funcoes.size() == 0) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.erro.nenhuma.fun.pode.ser.bloqueada", responsavel);
            } else if (servicos.size() == 0) {
                msgErro = ApplicationResourcesHelper.getMessage("mensagem.erro.nenhum.svc.pode.ser.bloqueado", responsavel);
            }

            boolean readOnly = false;
            if (!responsavel.temPermissao(funBloqUsuFunSvc)) {
                readOnly = true;
            }

            model.addAttribute("titulo", titulo);
            model.addAttribute("codigo", codigo);
            model.addAttribute("usu_codigo", usu_codigo);
            model.addAttribute("usu_nome", usu_nome);
            model.addAttribute("msgErro", msgErro);
            model.addAttribute("funcoes", funcoes);
            model.addAttribute("servicos", servicos);
            model.addAttribute("bloqueios", bloqueios);
            model.addAttribute("readOnly", readOnly);

            return viewRedirect("jsp/manterUsuario/editarBloqueioUsuarioFuncaoServico", request, session, model, responsavel);

        } catch (final UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=editarBloqueioUsuarioFuncaoServico" })
    public String editarBloqueioUsuarioFuncaoServico(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

        try {
            // Valida o token
            if (!SynchronizerToken.isTokenValid(request)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
            SynchronizerToken.saveToken(request);

            final String usu_codigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");

            if (TextHelper.isNull(usu_codigo)) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            final UsuarioTransferObject usu = usuarioController.findUsuario(usu_codigo, responsavel);
            if (usu == null) {
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }

            final String[] selecao = request.getParameterValues("funcao_servico");
            final List<String> selecionados = selecao != null ? Arrays.asList(selecao) : new ArrayList<>();

            // List de CustomTransferObjects a serem inseridos.
            final List<TransferObject> bloquear = new ArrayList<>();

            for (final String selecionado : selecionados) {
                final String fun_codigo = selecionado.split("_")[0];
                final String svc_codigo = selecionado.split("_")[1];

                final CustomTransferObject cto = new CustomTransferObject();

                cto.setAttribute(Columns.BUF_FUN_CODIGO, fun_codigo);
                cto.setAttribute(Columns.BUF_SVC_CODIGO, svc_codigo);

                bloquear.add(cto);
            }

            // Insere os bloqueios selecionados.
            usuarioController.insereBloqueiosFuncoes(usu_codigo, bloquear, responsavel);
            session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.bloquear.funcao.usuario.sucesso", responsavel));

            // Repassa o token salvo, pois o método irá revalidar o token
            request.setAttribute(SynchronizerToken.TRANSACTION_TOKEN_KEY, SynchronizerToken.getSessionToken(request));

            return iniciarBloqueioUsuarioFuncaoServico(request, response, session, model);

        } catch (final UsuarioControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(params = { "acao=listarBloqueioUsuarioRecursivo" })
    public String listarBloqueioUsuarioRecursivo(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

        // Valida o token
        if (!SynchronizerToken.isTokenValid(request)) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
        SynchronizerToken.saveToken(request);

        final ParamSession paramSession = ParamSession.getParamSession(session);

        final String usuCodigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");
        final String tipo = getTipoEntidade();
        final String status = JspHelper.verificaVarQryStr(request, "STATUS");
        final String tmoCodigo = JspHelper.verificaVarQryStr(request, "TMO_CODIGO");
        final String ousObs = JspHelper.verificaVarQryStr(request, "ADE_OBS");
        final String link = SynchronizerToken.updateTokenInURL(paramSession.getLastHistory(), request);
        final boolean lst_tudo = "listar_tudo".equals(JspHelper.verificaVarQryStr(request, "LISTAR_TODOS"));

        if (TextHelper.isNull(usuCodigo)) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        final String mensagem = ApplicationResourcesHelper.getMessage("mensagem.informacao.usuario.bloqueado.cadastro.outros.usuarios", responsavel);

        List<TransferObject> usuarios = null;
        if (AcessoSistema.ENTIDADE_CSE.equalsIgnoreCase(tipo) || AcessoSistema.ENTIDADE_ORG.equalsIgnoreCase(tipo) || AcessoSistema.ENTIDADE_SUP.equalsIgnoreCase(tipo)) {
            try {
                final List<String> usuCodigos = new ArrayList<>();
                usuCodigos.add(usuCodigo);
                if (lst_tudo) {
                    usuarios = usuarioController.lstUsuarioCriadoRecursivoPorResponsavel(usuCodigos, responsavel);
                } else {
                    usuarios = usuarioController.lstUsuarioCriadoPorResponsavel(usuCodigos, responsavel);
                }
            } catch (final Exception ex) {
                session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            }
        }

        if ((usuarios == null) || usuarios.isEmpty()) {
            // Se não existe usuário criado pelo usuário passado redireciona para a ultima tela válida
            request.setAttribute("url64", TextHelper.encode64(link));
            return "jsp/redirecionador/redirecionar";
        }

        model.addAttribute("usuCodigo", usuCodigo);
        model.addAttribute("tipo", tipo);
        model.addAttribute("status", status);
        model.addAttribute("tmoCodigo", tmoCodigo);
        model.addAttribute("ousObs", ousObs);
        model.addAttribute("link", link);
        model.addAttribute("lst_tudo", lst_tudo);
        model.addAttribute("mensagem", mensagem);
        model.addAttribute("usuarios", usuarios);

        return viewRedirect("jsp/manterUsuario/listarBloqueioUsuarioRecursivo", request, session, model, responsavel);
    }

    @RequestMapping(params = { "acao=bloquearUsuarioRecursivo" })
    public String bloquearUsuarioRecursivo(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

        // Valida o token
        if (!SynchronizerToken.isTokenValid(request)) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
        SynchronizerToken.saveToken(request);

        final String usuCodigo = JspHelper.verificaVarQryStr(request, "USU_CODIGO");
        final String tmoCodigo = JspHelper.verificaVarQryStr(request, "TMO_CODIGO");
        final String ousObs = JspHelper.verificaVarQryStr(request, "ADE_OBS");

        if (TextHelper.isNull(usuCodigo)) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        try {
            final String[] codigos = request.getParameterValues("USUARIO");
            final List<String> usuarios = codigos != null ? Arrays.asList(codigos) : new ArrayList<>();

            final List<TransferObject> usuCodigos = new ArrayList<>();
            TransferObject to = null;

            final Iterator<String> iteUsuarios = usuarios.iterator();
            while (iteUsuarios.hasNext()) {
                final String[] valores = iteUsuarios.next().toString().split(";");
                to = new CustomTransferObject();
                to.setAttribute(Columns.USU_CODIGO, valores[0]);
                to.setAttribute("TIPO", valores[1]);
                usuCodigos.add(to);
            }

            usuarioController.bloquearDesbloquearUsuario(usuCodigos, CodedValues.STU_BLOQUEADO, tmoCodigo, ousObs, responsavel);
            session.setAttribute(CodedValues.MSG_INFO, ApplicationResourcesHelper.getMessage("mensagem.usuario.bloqueado.sucesso", responsavel));

        } catch (final Exception ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            LOG.error(ex.getMessage(), ex);
        }

        // Repassa o token salvo, pois o método irá revalidar o token
        request.setAttribute(SynchronizerToken.TRANSACTION_TOKEN_KEY, SynchronizerToken.getSessionToken(request));

        return listarBloqueioUsuarioRecursivo(request, response, session, model);
    }

    protected String validaIpAcesso(HttpServletRequest request, HttpSession session, String tipo, String codigo, String usu_ip_acesso, Object usu_ddns_acesso) throws InstantiationException, IllegalAccessException {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        String msgErro = "";
        if ("".equals(JspHelper.verificaVarQryStr(request, "USU_NOME"))) {
            msgErro = ApplicationResourcesHelper.getMessage("mensagem.informe.usu.nome", responsavel);
        }
        if ("".equals(JspHelper.verificaVarQryStr(request, "USU_LOGIN"))) {
            msgErro = ApplicationResourcesHelper.getMessage("mensagem.informe.usu.login", responsavel);
        } else if (JspHelper.verificaVarQryStr(request, "USU_LOGIN").length() < 2) {
            msgErro = ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.login.minimo", responsavel);
        }

        final String usuLogin = JspHelper.verificaVarQryStr(request, "USU_LOGIN");

        try {
            //Confere se cadastro de IPs (ou DDNS) de acesso é obrigatório de acordo com o tipo da entidade
            usuarioController.validaIpAcessoResponsavel(tipo, usuLogin, codigo, usu_ip_acesso, (String) usu_ddns_acesso, responsavel);
        } catch (final UsuarioControllerException uex) {
            msgErro = uex.getMessage();
        }
        return msgErro;
    }

    protected abstract String getColunaCodigoEntidade();

    protected abstract boolean podeEditarUsuario(AcessoSistema responsavel);

    protected abstract String getFuncaoEdicaoBloqueioFuncaoServidor();
}


package com.zetra.econsig.web.controller.usuario;

import java.io.File;
import java.security.KeyPair;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import java.util.stream.Collectors;

import javax.crypto.BadPaddingException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import com.zetra.econsig.delegate.LogDelegate;
import com.zetra.econsig.dto.CustomTransferObject;
import com.zetra.econsig.dto.TransferObject;
import com.zetra.econsig.dto.entidade.ConsignanteTransferObject;
import com.zetra.econsig.dto.entidade.ConsignatariaTransferObject;
import com.zetra.econsig.dto.entidade.CorrespondenteTransferObject;
import com.zetra.econsig.dto.entidade.EstabelecimentoTransferObject;
import com.zetra.econsig.dto.entidade.MenuTO;
import com.zetra.econsig.dto.entidade.OrgaoTransferObject;
import com.zetra.econsig.dto.entidade.UsuarioTransferObject;
import com.zetra.econsig.dto.web.SSOToken;
import com.zetra.econsig.dto.web.TipoEntidadeVO;
import com.zetra.econsig.exception.ConsignanteControllerException;
import com.zetra.econsig.exception.ConsignatariaControllerException;
import com.zetra.econsig.exception.CorrespondenteControllerException;
import com.zetra.econsig.exception.FindException;
import com.zetra.econsig.exception.LogControllerException;
import com.zetra.econsig.exception.MensagemControllerException;
import com.zetra.econsig.exception.MenuControllerException;
import com.zetra.econsig.exception.ParametroControllerException;
import com.zetra.econsig.exception.SSOException;
import com.zetra.econsig.exception.UsuarioControllerException;
import com.zetra.econsig.exception.ViewHelperException;
import com.zetra.econsig.helper.arquivo.FileHelper;
import com.zetra.econsig.helper.criptografia.RSA;
import com.zetra.econsig.helper.log.Log;
import com.zetra.econsig.helper.parametro.ParamSist;
import com.zetra.econsig.helper.seguranca.AcessoSistema;
import com.zetra.econsig.helper.seguranca.CryptoUtil;
import com.zetra.econsig.helper.seguranca.SynchronizerToken;
import com.zetra.econsig.helper.texto.ApplicationResourcesHelper;
import com.zetra.econsig.helper.texto.DateHelper;
import com.zetra.econsig.helper.texto.TextHelper;
import com.zetra.econsig.helper.usuario.LoginHelper;
import com.zetra.econsig.helper.usuario.UsuarioHelper;
import com.zetra.econsig.helper.web.JspHelper;
import com.zetra.econsig.persistence.entity.Correspondente;
import com.zetra.econsig.persistence.entity.Perfil;
import com.zetra.econsig.persistence.entity.TipoEntidade;
import com.zetra.econsig.service.consignante.ConsignanteController;
import com.zetra.econsig.service.consignataria.ConsignatariaController;
import com.zetra.econsig.service.correspondente.CorrespondenteController;
import com.zetra.econsig.service.mensagem.MensagemController;
import com.zetra.econsig.service.menu.MenuController;
import com.zetra.econsig.service.parametro.ParametroController;
import com.zetra.econsig.service.sistema.SistemaController;
import com.zetra.econsig.service.usuario.UsuarioController;
import com.zetra.econsig.values.CodedNames;
import com.zetra.econsig.values.CodedValues;
import com.zetra.econsig.values.Columns;
import com.zetra.econsig.values.OperacaoValidacaoTotpEnum;
import com.zetra.econsig.values.PermiteValidacaoTotpEnum;
import com.zetra.econsig.web.ApplicationContextProvider;
import com.zetra.econsig.web.controller.AbstractWebController;
import com.zetra.econsig.web.controller.ajuda.ChatbotRestController;
import com.zetra.econsig.web.listener.SessionCounterListener;
import com.zetra.econsig.web.servlet.AudioCaptchaServlet;
import com.zetra.econsig.web.servlet.ImageCaptchaServlet;
import com.zetra.econsig.webclient.sso.SSOClient;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * <p>Title: AutenticarUsuarioWebController</p>
 * <p>Description: Controlador Web para o caso de uso Autenticar Usuários de papeis não servidor.</p>
 * <p>Copyright: Copyright (c) 2002-2017</p>
 * <p>Company: ZetraSoft</p>
 * $Author$
 * $Revision$
 */
@Controller
public class AutenticarUsuarioWebController extends AbstractWebController {

	private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(AutenticarUsuarioWebController.class);

	private static final String USERNAME_PARAM = "username";
	private static final String ACCESS_TOKEN_PARAM = "sso_token";
	private static final String USU_CENTRALIZADOR_PARAM = "usuCentralizador";
	private static final String URL_CENTRALIZADOR_ACESSO_PARAM = "urlCentralizadorAcesso";

    @Autowired
    private MenuController menuController;

    @Autowired
    private ConsignanteController consignanteController;

    @Autowired
    private UsuarioController usuarioController;

    @Autowired
    private ConsignatariaController consignatariaController;

    @Autowired
    private MensagemController mensagemController;

    @Autowired
    private SistemaController sistemaController;

    @Autowired
    private ParametroController parametroController;

    @Autowired
    private CorrespondenteController correspondenteController;

    @Autowired
    private CryptoUtil cryptoUtil;

    @Autowired
    private SessionCounterListener sessionManagment;

    @Override
    protected void configurarPagina(HttpServletRequest request, HttpSession session, Model model, AcessoSistema responsavel) {
        model.addAttribute("tituloPagina", JspHelper.getNomeSistema(responsavel));
    }

    @RequestMapping(value = { "/" })
    public String index(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = AcessoSistema.getAcessoUsuarioSistema();

        try {
            final Short status = sistemaController.verificaBloqueioSistema(CodedValues.CSE_CODIGO_SISTEMA, responsavel);
            final boolean indisponivel = status.equals(CodedValues.STS_INDISP);
            final boolean boasVindasHabilitada = ParamSist.paramEquals(CodedValues.TPC_HABILITA_PAGINA_BOAS_VINDAS, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
            if (indisponivel) {
                session.setAttribute(CodedValues.MSG_ERRO, LoginHelper.getMensagemSistemaIndisponivel());
                return "redirect:/v3/exibirMensagem?acao=exibirMsgSessao&tipo=indisponivel";
            } else if(boasVindasHabilitada) {
            	return "redirect:/v3/boasVindas?acao=iniciar";
            } else {
            	return redirecionarPaginaLogin();
            }
        } catch (final ConsignanteControllerException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
    }

    @RequestMapping(value = { "/v3/autenticarUsuario" })
    public String iniciar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        AcessoSistema responsavel = JspHelper.getAcessoSistema(request);
        final String telaValidacao = (model.containsAttribute("telaValidacao")) ? (String) model.asMap().get("telaValidacao") : (String) request.getAttribute("telaValidacao");
        final String usuCentralizador = JspHelper.verificaVarQryStr(request, USU_CENTRALIZADOR_PARAM);

        try {
            if (responsavel.isSessaoValida() && TextHelper.isNull(telaValidacao) && usuCentralizador.isEmpty()) {
                //recupera se o login veio do fluxo da DESENV-13252
                final Boolean termoUso = (Boolean) session.getAttribute("termo_usu");

                // Invalida a sessão do usuário, caso exista
                session.invalidate();
                session = request.getSession(true);

                if (termoUso != null) {
                    session.setAttribute("termo_usu", Boolean.TRUE);
                }

                // Obtém novamente o responsável
                responsavel = JspHelper.getAcessoSistema(request);
            }
        } catch (final IllegalStateException ex) {
            // Trata erro caso a sessão já esteja invalidada
        }

        if (ParamSist.paramEquals(CodedValues.TPC_EXIBE_MENSAGEM_TELA_LOGIN_USUARIO, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema())) {
            try {
                final String mensagemTelaLoginUsuario = getTextoAutenticacaoUsuario(responsavel);
                if (!TextHelper.isNull(mensagemTelaLoginUsuario)) {
                    model.addAttribute("mensagemTelaLoginUsuario", mensagemTelaLoginUsuario);
                }
            } catch (final ViewHelperException e) {
                session.setAttribute(CodedValues.MSG_ERRO, e.getMessage());
                return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
            }
        }

        if(!TextHelper.isNull(request.getAttribute("urlCentralizador"))) {
            final String urlCentral = (String) request.getAttribute("urlCentralizador");
            session.setAttribute("urlCentralizador", urlCentral);
        }
        //com as novas interfaces do spring os cookies são gravados com domínios diferentes, logo
        //invalida ambos
        JspHelper.setaCookieLogin(response, request.getContextPath());

        model.addAttribute("nomeCse", LoginHelper.getCseNome(responsavel));
        model.addAttribute("nomeSistema", JspHelper.getNomeSistema(responsavel));
        model.addAttribute("usuBloqueado", (model.containsAttribute("usuBloqueado")) ?
                (String) model.asMap().get("usuBloqueado") : !TextHelper.isNull(request.getAttribute("usuBloqueado")) ?
                        (String) request.getAttribute("usuBloqueado") : "false");
        model.addAttribute("msgUsuBloqueado", LoginHelper.getMsgUsuarioBloq(request, responsavel));
        boolean exibeCaptcha = ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
        boolean exibeCaptchaAvancado = exibeCaptcha ? false : ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_AVANCADO_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
        boolean exibeCaptchaDeficiente = false;
        // parâmetro para definir se o login é realizado em duas etapas
        final boolean validacaoSeguranca = ParamSist.paramEquals(CodedValues.TPC_VALIDACAO_SEGURANCA_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
        final String tipoCaptchaAvancado = (String) ParamSist.getInstance().getParam(CodedValues.TPC_TIPO_CAPTCHA_AVANCADO_LOGIN, AcessoSistema.getAcessoUsuarioSistema());
        model.addAttribute("mascaraNomeLogin", ParamSist.getInstance().getParam(CodedValues.TPC_MASCARA_NOME_LOGIN, responsavel));
        model.addAttribute("mensagemMascaraNomeLogin", LoginHelper.getMensagemMascaraNomeLogin(responsavel));
        model.addAttribute("telaLogin", LoginHelper.getPaginaLogin());
        String usuLogin = null;
        String usuNome = null;
        String loginDefVisual = null;
        boolean exibeHcaptcha = false;
        boolean exibeRecaptcha = false;
        model.addAttribute("internetExplorer", false);
        if (validacaoSeguranca) {
            if (TextHelper.isNull(telaValidacao)) {
                model.addAttribute("telaValidacao", "1");
            } else {
                model.addAttribute("telaValidacao", telaValidacao);
            }
            usuLogin = (model.containsAttribute("usuLogin")) ? (String) model.asMap().get("usuLogin") : (String) request.getAttribute("usuLogin");
            usuNome = (model.containsAttribute("usuNome")) ? (String) model.asMap().get("usuNome") : (String) request.getAttribute("usuNome");
            loginDefVisual = (model.containsAttribute("usuDeficienteVisual")) ? (String) model.asMap().get("usuDeficienteVisual") : !TextHelper.isNull(request.getAttribute("usuDeficienteVisual")) ? (String) request.getAttribute("usuDeficienteVisual") : "N";
            if ("S".equals(loginDefVisual)) {
                exibeCaptcha = false;
                exibeCaptchaAvancado = false;
                exibeHcaptcha = false;
                exibeRecaptcha = false;
                exibeCaptchaDeficiente = ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_DEFICIENTE_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
            }
        }

        if (exibeCaptchaAvancado && CodedValues.TPC_H.equals(tipoCaptchaAvancado)) {
        	exibeHcaptcha = true;
        } else if (exibeCaptchaAvancado && CodedValues.TPC_R.equals(tipoCaptchaAvancado)) {
        	exibeRecaptcha = true;
        }

        model.addAttribute("validacaoSeguranca", validacaoSeguranca);
        model.addAttribute("usuLogin", usuLogin);
        model.addAttribute("usuNome", usuNome);
        model.addAttribute("exibeCaptcha", exibeCaptcha);
        model.addAttribute("exibeCaptchaAvancado", exibeCaptchaAvancado);
        model.addAttribute("exibeHcaptcha", exibeHcaptcha);
        model.addAttribute("exibeRecaptcha", exibeRecaptcha);
        model.addAttribute("exibeCaptchaDeficiente", exibeCaptchaDeficiente);
        model.addAttribute("ajudaCampoCaptcha", ApplicationResourcesHelper.getMessage("ajuda.campo.captcha", responsavel));
        model.addAttribute("tituloPaginaLoginCsa", ApplicationResourcesHelper.getMessage("rotulo.titulo.pagina.login.csa", responsavel));
        model.addAttribute("ajudaSenha", ApplicationResourcesHelper.getMessage("mensagem.informacao.digite.senha", responsavel));

        // Habilita o chatbot na página de login caso o parâmetro esteja habilitado
        if (!TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_ID_CHATBOT_PAGINA_LOGIN_USU, responsavel)) ||
                !TextHelper.isNull(ParamSist.getInstance().getParam(CodedValues.TPC_ID_CHATBOT_PAGINA_LOGIN_SER, responsavel))) {
            session.setAttribute(ChatbotRestController.CHATBOT_ORIGEM_LOGIN_SERVIDOR, Boolean.FALSE);
        }

        return viewRedirect("jsp/autenticarUsuario/autenticarUsuario", request, session, model, responsavel);

    }

    @RequestMapping(value = { "/v3/autenticarUsuario" }, params = { "acao=autenticar" })
    public String autenticar(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = AcessoSistema.getAcessoUsuarioSistema();

        String usuId = JspHelper.verificaVarQryStr(request, USERNAME_PARAM);
        String ssoToken = request.getParameter(ACCESS_TOKEN_PARAM);

		final String params = request.getParameter("p");

		if (!TextHelper.isNull(params)) {
			try {
				final String urlDecoded = cryptoUtil.decrypt(TextHelper.decode64(params));

				final String[] parametros = urlDecoded.split("&");

				final String userName = parametros[0].substring(parametros[0].indexOf(USERNAME_PARAM) + USERNAME_PARAM.length() + 1, parametros[0].length());
				final String token = parametros[1].substring(parametros[1].indexOf(ACCESS_TOKEN_PARAM) + ACCESS_TOKEN_PARAM.length() + 1, parametros[1].length());
				final String urlCentralizador = parametros[2].substring(parametros[2].indexOf(USU_CENTRALIZADOR_PARAM) + USU_CENTRALIZADOR_PARAM.length() + 1, parametros[2].length());
				final String urlCentralizadorAcesso = parametros[3].substring(parametros[3].indexOf(URL_CENTRALIZADOR_ACESSO_PARAM) + URL_CENTRALIZADOR_ACESSO_PARAM.length() + 1, parametros[3].length());

				usuId = userName;
				ssoToken = token;
				request.setAttribute(USU_CENTRALIZADOR_PARAM, urlCentralizador);
				request.setAttribute(URL_CENTRALIZADOR_ACESSO_PARAM, urlCentralizadorAcesso);

			} catch (final Exception ex) {
                LOG.error(ex.getMessage(), ex);
	            return iniciar(request, response, session, model);
			}
		}

        if (TextHelper.isNull(usuId)) {
            return iniciar(request, response, session, model);
        }

        final String senhaCriptografada = JspHelper.verificaVarQryStr(request, JspHelper.verificaVarQryStr(request, "cryptedPasswordFieldName"));

        final String msgErroLoginInvalido = LoginHelper.getMensagemErroLogin();
        // verifica se o login é realizado em duas etapas
        final boolean validacaoSeguranca = ParamSist.paramEquals(CodedValues.TPC_VALIDACAO_SEGURANCA_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
        final String telaValidacao = (!TextHelper.isNull(request.getParameter("telaValidacao"))) ? request.getParameter("telaValidacao") : "";
        String loginDefVisual = "N";

        try {
            // Pesquisa o usuário pelo login ou email informado
            List<TransferObject> usuarioList = null;

            if (!TextHelper.isNull(usuId)) {
                usuarioList = UsuarioHelper.localizarUsuario(usuId, responsavel);
            }

            // Usuário só é considerado deficiente visual quando existe login em duas etapas
            if (((usuarioList != null) && !usuarioList.isEmpty()) && validacaoSeguranca) {
                loginDefVisual = (usuarioList.get(0).getAttribute(Columns.USU_DEFICIENTE_VISUAL) != null ? usuarioList.get(0).getAttribute(Columns.USU_DEFICIENTE_VISUAL).toString() : "N");
            }

            // Se for centralizador de acesso, não deve validar captcha
            if (!TextHelper.isNull(request.getParameter(URL_CENTRALIZADOR_ACESSO_PARAM)) || !TextHelper.isNull(request.getAttribute(URL_CENTRALIZADOR_ACESSO_PARAM))) {
                session.setAttribute(com.zetra.econsig.values.CodedNames.ATTR_SESSION_CENTRALIZADOR, Boolean.TRUE);
            }

            // verifica se o login é feito em duas etapas e volta para a tela anterior para solicitar os outros dados
            if (validacaoSeguranca && (!TextHelper.isNull(telaValidacao) && "1".equals(telaValidacao)) && (session.getAttribute(CodedNames.ATTR_SESSION_CENTRALIZADOR) == null)) {
                if ((usuarioList != null) && !usuarioList.isEmpty()) {
                    // recupera informações do usuário
                    model.addAttribute("usuNome", TextHelper.formataNomeUsuario(usuarioList.get(0).getAttribute(Columns.USU_NOME).toString().toUpperCase(), responsavel));
                    model.addAttribute("usuLogin", usuId);
                    model.addAttribute("usuDeficienteVisual", loginDefVisual);
                } else {
                    // retorna um nome aleatório para dificultar ação de "robôs"
                    final int total = usuarioController.countNomeUsuario(responsavel);
                    // gera o número aleatório usando um seed para garantir que a consulta retornará sempre o mesmo nome para o login informado (para login incorreto)
                    final int seed = usuId.hashCode();
                    final Random aleatorio = new Random(seed);
                    final int offset = aleatorio.nextInt(total);
                    final CustomTransferObject usuarioRand = (CustomTransferObject) usuarioController.obtemNomeUsuario(null, null, offset, responsavel);
                    final String usuarioRandNome = usuarioRand.getAttribute(Columns.USU_NOME).toString();
                    model.addAttribute("usuNome", TextHelper.formataNomeUsuario(usuarioRandNome.toUpperCase(), responsavel));
                    model.addAttribute("usuLogin", usuId);
                    model.addAttribute("usuDeficienteVisual", "N");
                }

                boolean usuarioPodeAutoDesbloquear = verificarUsuarioPodeAutoDesbloquear (usuarioList, responsavel);

                model.addAttribute("usuarioPodeAutoDesbloquear", usuarioPodeAutoDesbloquear);
                model.addAttribute("telaValidacao", "2");

                iniciar(request, response, session, model);
                return viewRedirect("jsp/autenticarUsuario/autenticarUsuarioPasso2",  request, session, model, responsavel);
            }

            if (!"S".equals(loginDefVisual)) {
                if (ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_TELA_LOGIN, CodedValues.TPC_SIM, responsavel) &&
                        (session.getAttribute(CodedNames.ATTR_SESSION_CENTRALIZADOR) == null)) {
                    if (ImageCaptchaServlet.armazenaCaptcha(session.getId(), (String) session.getAttribute(ImageCaptchaServlet.IMAGE_CAPTCHA_SESSION_KEY))
                        && !ImageCaptchaServlet.validaCaptcha(session.getId(), request.getParameter("captcha"))) {
                        throw new UsuarioControllerException("mensagem.erro.captcha.invalido", responsavel);
                    }
                    session.removeAttribute(ImageCaptchaServlet.IMAGE_CAPTCHA_SESSION_KEY);
                } else if (ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_AVANCADO_TELA_LOGIN, CodedValues.TPC_SIM, responsavel) && ParamSist.paramEquals(CodedValues.TPC_TIPO_CAPTCHA_AVANCADO_LOGIN, CodedValues.TPC_R, responsavel) &&
                        (session.getAttribute(CodedNames.ATTR_SESSION_CENTRALIZADOR) == null)) {
                    final String remoteAddr = request.getRemoteAddr();

                    if (!isValidCaptcha(request.getParameter("g-recaptcha-response"), remoteAddr, responsavel)) {
                        throw new UsuarioControllerException("mensagem.erro.captcha.invalido", responsavel);
                    }
                } else if (ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_AVANCADO_TELA_LOGIN, CodedValues.TPC_SIM, responsavel) && ParamSist.paramEquals(CodedValues.TPC_TIPO_CAPTCHA_AVANCADO_LOGIN, CodedValues.TPC_H, responsavel) &&
                        (session.getAttribute(CodedNames.ATTR_SESSION_CENTRALIZADOR) == null)) {
                    final String remoteAddr = request.getRemoteAddr();

                    if (!isValidHcaptcha(request.getParameter("g-recaptcha-response"), remoteAddr, responsavel)) {
                        throw new UsuarioControllerException("mensagem.erro.captcha.invalido", responsavel);
                    }
                }
            } else{
                final boolean exigeCaptchaDeficiente = ParamSist.paramEquals(CodedValues.TPC_EXIBE_CAPTCHA_DEFICIENTE_TELA_LOGIN, CodedValues.TPC_SIM, AcessoSistema.getAcessoUsuarioSistema());
                if (exigeCaptchaDeficiente) {
                    final String captchaAnswer = request.getParameter("captcha");
                    final String captchaCode   = (String) session.getAttribute(AudioCaptchaServlet.AUDIO_CAPTCHA_SESSION_KEY);
                    if ((captchaCode == null) || !captchaCode.equalsIgnoreCase(captchaAnswer)) {
                        throw new UsuarioControllerException("mensagem.erro.captcha.invalido", responsavel);
                    }
                    session.removeAttribute(AudioCaptchaServlet.AUDIO_CAPTCHA_SESSION_KEY);
                }
            }

            if ((usuarioList == null) || usuarioList.isEmpty()) {
                //DESENV-7733: Por causa de sistemas em que a mensagem de login inválido está configurado como mensagem direta em parâmetro de sistema
                //             não há como criar exceção com construtor passando chave do ApplicationResources
                throw UsuarioControllerException.byMessage(msgErroLoginInvalido);
            }

            // Verifica a licença do eConsig
            final String licenca = (String) usuarioList.get(0).getAttribute(Columns.CSE_LICENCA);
            final String publicKeyCentralizador = (String) usuarioList.get(0).getAttribute(Columns.CSE_RSA_PUBLIC_KEY_CENTRALIZADOR);
            final String modulusCentralizador = (String) usuarioList.get(0).getAttribute(Columns.CSE_RSA_MODULUS_CENTRALIZADOR);
            if (UsuarioHelper.isLicencaExpirada(licenca, publicKeyCentralizador, modulusCentralizador)) {
                // Dá mensagem de erro genérica, com código de erro.
                throw new UsuarioControllerException("mensagem.licencaSistemaInvalida", responsavel);
            }
            // Fim da verificação da licença

            final AcessoSistema usuAcesso = new AcessoSistema(null, JspHelper.getRemoteAddr(request), JspHelper.getRemotePort(request));

            // remove os usuários excluídos. Se não sobrar nenhum usuário, retornar usuário ou senha inválidos.
            // Implementa stu_codigo = usuario.getAttribute(Columns.USU_STU_CODIGO) != null ? usuario.getAttribute(Columns.USU_STU_CODIGO).toString() : CodedValues.STU_ATIVO;
            usuarioList = usuarioList.stream().filter(usuario -> (TextHelper.isNull(usuario.getAttribute(Columns.USU_STU_CODIGO)) ||
                    !CodedValues.STU_EXCLUIDO.equals(usuario.getAttribute(Columns.USU_STU_CODIGO)))).collect(Collectors.toList());
            if ((usuarioList == null) || usuarioList.isEmpty()) {
                throw UsuarioControllerException.byMessage(msgErroLoginInvalido);
            }

            // Decriptografa a senha informada
            final KeyPair keyPair = LoginHelper.getRSAKeyPair(request);
            String senhaAberta = null;
            if (!TextHelper.isNull(senhaCriptografada) || TextHelper.isNull(ssoToken)) {
                try {
                    senhaAberta = RSA.decrypt(senhaCriptografada, keyPair.getPrivate());
                    if (senhaAberta == null) {
                        throw UsuarioControllerException.byMessage(msgErroLoginInvalido);
                    }
                } catch (final BadPaddingException e) {
                    // Corresponde a tentativa de decriptografia com chave errada. A sessão pode ter expirado. Tentar novamente.
                    throw UsuarioControllerException.byMessage(msgErroLoginInvalido);
                }
            }

            final List<UsuarioTransferObject> usuTransFerList = usuarioList.stream().map(usu -> {final UsuarioTransferObject tmp = new UsuarioTransferObject();
            tmp.setAtributos(usu.getAtributos());
            return tmp;
            }).collect(Collectors.toList());


            List<TransferObject> usuariosAutenticados = null;
            try {
                usuariosAutenticados = UsuarioHelper.autenticarUsuarios(senhaAberta, usuTransFerList, ssoToken, usuAcesso);

                if ((usuariosAutenticados == null) || usuariosAutenticados.isEmpty()) {
                    throw UsuarioControllerException.byMessage(msgErroLoginInvalido);
                }
                if (!TextHelper.isNull(ssoToken) && TextHelper.isNull(usuAcesso.getSsoToken())) {
                    usuAcesso.setSsoToken(new SSOToken(ssoToken));
                }
            } catch (final ViewHelperException vex) {
                if ("mensagem.usuarioSenhaInvalidos".equals(vex.getMessageKey())) {
                    throw UsuarioControllerException.byMessage(msgErroLoginInvalido);
                } else {
                    throw new UsuarioControllerException(vex);
                }
            }

            for (final TransferObject usu: usuarioList) {
                JspHelper.limpaCacheTentativasLogin(usu.getAttribute(Columns.USU_CODIGO).toString());
            }

            if (usuariosAutenticados.size() > 1) {
                // Armazena na sessão o objeto AcessoSistema para este usuário parcial. Será completado ao ser escolhido o exato usuáro
                // com o qual se quer logar na próxima página
                session.setAttribute(AcessoSistema.SESSION_ATTR_NAME, usuAcesso);
                model.addAttribute("usuarioList", usuariosAutenticados);
                model.addAttribute("papeis", usuarioController.listarPapeis(usuAcesso));

                SynchronizerToken.saveToken(request);
                return viewRedirect("jsp/autenticarUsuario/selecionarUsuarioAutenticado",  request, session, model, responsavel);
            } else {
                final TransferObject usuario = !usuariosAutenticados.isEmpty() ? usuariosAutenticados.get(0) : usuarioList.get(0);

                return finalizarAutenticacao(request, response, session, model, usuAcesso, usuario);
            }
        } catch (final Exception ex) {
            return trataExcecao(request, response, session, model, responsavel, usuId, ex);
        }
    }

    private boolean verificarUsuarioPodeAutoDesbloquear(List<TransferObject> usuarioList, AcessoSistema responsavel) {

        boolean usuarioPodeAutoDesbloquear = false;
        
        for (TransferObject usuario : usuarioList) {
            
            TipoEntidadeVO resultadoTipoEntidadeVO = determinarTipoEntidade(usuario);
            if (usuarioController.usuarioPossuiPermissaoAutoDesbloqueio(usuario, resultadoTipoEntidadeVO.getTipoEntidade(), responsavel)) {
                usuarioPodeAutoDesbloquear = true;
            } 
        }

        return usuarioPodeAutoDesbloquear;
        
    }

    @RequestMapping(value = { "/v3/autenticarUsuario" }, params = { "acao=finalizarAutenticacao" })
    public String finalizarAutenticacao(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = AcessoSistema.getAcessoUsuarioSistema();
        // Valida o token de sessão para evitar a chamada direta à operação
        if (!SynchronizerToken.isTokenValid(request)) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }
        SynchronizerToken.saveToken(request);

        final String usuCodigo = JspHelper.verificaVarQryStr(request, "usuCodigo");
        final AcessoSistema usuAcesso = (AcessoSistema) session.getAttribute(AcessoSistema.SESSION_ATTR_NAME);

        final List<TransferObject> usuarioList = (List<TransferObject>) session.getAttribute("usuarioList");
        final List<TransferObject> usuSelecionadoList = usuarioList.stream().filter(usu -> usu.getAttribute(Columns.USU_CODIGO).equals(usuCodigo)).collect(Collectors.toList());
        session.removeAttribute("usuarioList");

        if ((usuSelecionadoList == null) || usuSelecionadoList.isEmpty()) {
            session.setAttribute(CodedValues.MSG_ERRO, LoginHelper.getMensagemErroLogin());
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        try {
            return finalizarAutenticacao(request, response, session, model, usuAcesso, usuSelecionadoList.get(0));
        } catch (final Exception e) {
            return trataExcecao(request, response, session, model, responsavel, (String) usuSelecionadoList.get(0).getAttribute(Columns.USU_LOGIN), e);
        }
    }

    private String finalizarAutenticacao(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model, AcessoSistema usuAcesso, TransferObject usuario) throws ConsignanteControllerException, UsuarioControllerException, ConsignatariaControllerException, ViewHelperException, MenuControllerException, LogControllerException, MensagemControllerException, ParametroControllerException, FindException, CorrespondenteControllerException {
                
        final AcessoSistema responsavel = AcessoSistema.getAcessoUsuarioSistema();
        // DESENV-20890 : seta no responsavel pois é esta variável que chega até o método de validação de ip.
        responsavel.setNavegadorExclusivo(JspHelper.getNavegadorExclusivo(request));
        final String msgErroLoginInvalido = LoginHelper.getMensagemErroLogin();
        // Obtém os dados do usuário
        final String usu_codigo = usuario.getAttribute(Columns.USU_CODIGO).toString();
        final String stu_codigo = usuario.getAttribute(Columns.USU_STU_CODIGO) != null ? usuario.getAttribute(Columns.USU_STU_CODIGO).toString() : CodedValues.STU_ATIVO;
        final String usu_ip_acesso = (usuario.getAttribute(Columns.USU_IP_ACESSO) != null ? usuario.getAttribute(Columns.USU_IP_ACESSO).toString() : "");
        final String usu_ddns_acesso = (usuario.getAttribute(Columns.USU_DDNS_ACESSO) != null ? usuario.getAttribute(Columns.USU_DDNS_ACESSO).toString() : "");
        final String usu_cpf = (usuario.getAttribute(Columns.USU_CPF) != null ? usuario.getAttribute(Columns.USU_CPF).toString() : "");
        final String usu_email = (usuario.getAttribute(Columns.USU_EMAIL) != null ? usuario.getAttribute(Columns.USU_EMAIL).toString() : "");
        final String usu_chave_validacao_totp = !TextHelper.isNull(usuario.getAttribute(Columns.USU_CHAVE_VALIDACAO_TOTP)) ? usuario.getAttribute(Columns.USU_CHAVE_VALIDACAO_TOTP).toString() : null;
        final String usu_permite_validacao_totp = !TextHelper.isNull(usuario.getAttribute(Columns.USU_PERMITE_VALIDACAO_TOTP)) ? usuario.getAttribute(Columns.USU_PERMITE_VALIDACAO_TOTP).toString() : null;
        final String usu_operacoes_validacao_totp = usuario.getAttribute(Columns.USU_OPERACOES_VALIDACAO_TOTP).toString();
        final String usu_data_valicacao_email = !TextHelper.isNull(usuario.getAttribute(Columns.USU_DATA_VALIDACAO_EMAIL)) ? usuario.getAttribute(Columns.USU_DATA_VALIDACAO_EMAIL).toString() : "";
        final String usu_per_descricao = usuario.getAttribute(Columns.PER_DESCRICAO) != null ? usuario.getAttribute(Columns.PER_DESCRICAO).toString() : ApplicationResourcesHelper.getMessage("rotulo.usuario.perfil.personalizado", responsavel);

        // Verifica se o sistema não está bloqueado
        final Short status = sistemaController.verificaBloqueioSistema(CodedValues.CSE_CODIGO_SISTEMA, responsavel);
        final boolean indisponivel = status.equals(CodedValues.STS_INDISP);
        if (indisponivel && !usuarioController.usuarioTemPermissao(usu_codigo, CodedValues.FUN_EFETUAR_LOGIN_SISTEMA_BLOQUEADO, null, responsavel)) {
            session.setAttribute(CodedValues.MSG_ERRO, LoginHelper.getMensagemSistemaIndisponivel());
            model.addAttribute("tipo", "indisponivel");
            return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
        }

        TipoEntidadeVO resultadoTipoEntidadeVO = determinarTipoEntidade(usuario);
        String tipoEntidade = resultadoTipoEntidadeVO.getTipoEntidade();
        String codigoEntidade = resultadoTipoEntidadeVO.getCodigoEntidade();

        // se sistema está configurado para bloquear automaticamente usuário na sua próxima autenticação, faz a verficação de bloqueio.
        boolean bloqueadoPorInatividade = false;
        if (ParamSist.getBoolParamSist(CodedValues.TPC_BLOQUEIA_USU_INATIVIDADE_PROXIMA_AUTENTICACAO, responsavel)) {
            bloqueadoPorInatividade = UsuarioHelper.bloqueioAutomaticoPorInatividade(usu_codigo, responsavel);
        }

        if (bloqueadoPorInatividade || CodedValues.STU_CODIGOS_INATIVOS.contains(stu_codigo)) {
            model.addAttribute("usuarioBloqueado", "true");

            if (CodedValues.STU_BLOQUEADO_AUTOMATICAMENTE.equals(stu_codigo)) {
                
                boolean redirectAutoDesbloqueio = usuarioController.usuarioPossuiPermissaoAutoDesbloqueio(usuario, tipoEntidade, responsavel);

                if (redirectAutoDesbloqueio) {
                    model.addAttribute("redirectAutoDesbloqueio", true);
                    return iniciar(request, response, session, model);
                }

            }

            throw new UsuarioControllerException("mensagem.usuarioBloqueado", responsavel);
        }

        usuAcesso.setUsuCodigo(usu_codigo);
        usuAcesso.setUsuChaveValidacaoTotp(usu_chave_validacao_totp);
        usuAcesso.setUsuPermiteValidacaoTotp(Optional.ofNullable(PermiteValidacaoTotpEnum.get(usu_permite_validacao_totp)).orElse(PermiteValidacaoTotpEnum.DESABILITADO));
        usuAcesso.setUsuOperacoesValidacaoTotp(OperacaoValidacaoTotpEnum.get(usu_operacoes_validacao_totp));

        String cor_codigo = resultadoTipoEntidadeVO.getCorCodigo();
        String cse_codigo = resultadoTipoEntidadeVO.getCseCodigo();
        String csa_codigo = resultadoTipoEntidadeVO.getCsaCodigo();
        String org_codigo = resultadoTipoEntidadeVO.getOrgCodigo();
        
        // Seta as informações sobre a entidade do usuário no AcessoSistema
        usuAcesso.setTipoEntidade(tipoEntidade);
        usuAcesso.setCodigoEntidade(codigoEntidade);

        //Seta as informações sobre o perfil do usuário no AcessoSistema.
        usuAcesso.setPerDescricao(usu_per_descricao);
        
        if (usuAcesso.isSer()) {
            throw UsuarioControllerException.byMessage(msgErroLoginInvalido);
        }

        // Verifica se o sistema permite o login de usuário correspondente vinculado a uma entidade bloqueada
        final boolean permiteLoginUsuCorEntidadeBloq = ParamSist.getBoolParamSist(CodedValues.TPC_PERMITE_LOGIN_USU_COR_ENTIDADE_BLOQ, responsavel);
        // Verifica se a consignatária do correspondente não está bloqueada
        if (!permiteLoginUsuCorEntidadeBloq && usuAcesso.isCor()) {
            final CorrespondenteTransferObject cor = consignatariaController.findCorrespondente(cor_codigo, responsavel);
            final ConsignatariaTransferObject csa = consignatariaController.findConsignataria(cor.getCsaCodigo(), responsavel);
            if (!csa.getCsaAtivo().equals(CodedValues.STS_ATIVO)) {
                throw new UsuarioControllerException("mensagem.informacao.consignataria.bloqueada", responsavel);
            }
            if (!cor.getCorAtivo().equals(CodedValues.STS_ATIVO)) {
                throw new UsuarioControllerException("mensagem.informacao.correspondente.bloqueado", responsavel);
            }
        }

        // Verifica se o perfil do usuário não está bloqueado
        final String perCodigo = (String) usuario.getAttribute(Columns.UPE_PER_CODIGO);
        if ((perCodigo != null) && !"".equals(perCodigo)) {
            final Short upeStatus = usuarioController.getStatusPerfil(tipoEntidade, codigoEntidade, perCodigo, responsavel);
            if ((upeStatus == null) || !upeStatus.equals(CodedValues.STS_ATIVO)) {
                model.addAttribute("usuarioBloqueado", "true");
                throw new UsuarioControllerException("mensagem.usuarioBloqueado", responsavel);
            }
        }

        // Verifica obrigatoriedade e validade do IP/DDNS de acesso
        UsuarioHelper.verificarIpDDNSAcesso(tipoEntidade, codigoEntidade, JspHelper.getRemoteAddr(request), usu_ip_acesso, usu_ddns_acesso, usu_codigo, responsavel);

        // Verifica se o usuário é obrigado a usar o centralizador para fazer login
        if ((usuario.getAttribute(Columns.USU_CENTRALIZADOR) != null)
                && CodedValues.TPC_SIM.equals(usuario.getAttribute(Columns.USU_CENTRALIZADOR).toString())
                && (session.getAttribute(CodedNames.ATTR_SESSION_CENTRALIZADOR) == null)) {
            throw new UsuarioControllerException("mensagem.informacao.usuario.deve.acessar.via.centralizador", responsavel);
        }

        // Verifica obrigatoriedade de CPF para acesso ao sistema
        UsuarioHelper.verificarCpfUsuario(tipoEntidade, usu_cpf, responsavel);

        // Verifica obrigatoriedade de email para acesso ao sistema
        UsuarioHelper.verificarEmailUsuario(tipoEntidade, usu_email, responsavel);

        // Verifica obrigatoriedade de validação de email para acesso ao sistema
        final boolean emailJaValidado = UsuarioHelper.usuarioValidouEmail(tipoEntidade, usu_data_valicacao_email, responsavel);

        if (!emailJaValidado) {
            session.setAttribute(AcessoSistema.SESSION_ATTR_NAME, usuAcesso);

            final boolean editarEmail = (ParamSist.paramEquals(CodedValues.TPC_BLOQUEIA_EDICAO_EMAIL, CodedValues.TPC_SIM, responsavel) && !TextHelper.isNull(usu_email));

            model.addAttribute("usuCodigo", usu_codigo);
            model.addAttribute("usuEmail", usu_email);
            model.addAttribute("editarEmail", editarEmail);
            model.addAttribute("msgValidacao", ApplicationResourcesHelper.getMessage("mensagem.erro.usuario.validacao.email", responsavel));
            model.addAttribute("retornoErro", Boolean.FALSE);
            return viewRedirect("jsp/validarEmailUsuario/validarEmailUsuario", request, session, model, responsavel);
        }

        //recupera se o login veio do fluxo da DESENV-13252
        final Boolean termoUso = (Boolean) session.getAttribute("termo_usu");

        // Cria a sessão do usuário
        session.removeAttribute("msg");

        // Invalida e cria nova sessão para mudar o sessionId evitando ataque
        // de session fixation.
        session.invalidate();
        session = request.getSession(true);

        if (termoUso != null) {
            session.setAttribute("termo_usu", Boolean.TRUE);
        }

        if (!TextHelper.isNull(request.getParameter("urlCentralizador"))) {
            final String urlCentral = request.getParameter("urlCentralizador");
            final String attrSessionAcessoUrl = request.getParameter("attrSessionAcessoUrl");
            final String parametrosCentral = request.getParameter("parametrosCentral");

            session.setAttribute("attrSessionAcessoUrl", attrSessionAcessoUrl);
            session.setAttribute("urlCentralizador", urlCentral);
            session.setAttribute("parametrosCentral", parametrosCentral);
        }

        if (!TextHelper.isNull(request.getParameter(URL_CENTRALIZADOR_ACESSO_PARAM)) || !TextHelper.isNull(request.getAttribute(URL_CENTRALIZADOR_ACESSO_PARAM))) {
            final String urlCentralizadorAcesso = !TextHelper.isNull(request.getParameter(URL_CENTRALIZADOR_ACESSO_PARAM)) ? request.getParameter(URL_CENTRALIZADOR_ACESSO_PARAM) : (String) request.getAttribute(URL_CENTRALIZADOR_ACESSO_PARAM);

            session.setAttribute(URL_CENTRALIZADOR_ACESSO_PARAM, urlCentralizadorAcesso);
            final Cookie cookie = new Cookie(URL_CENTRALIZADOR_ACESSO_PARAM, urlCentralizadorAcesso);
            cookie.setHttpOnly(true);
            cookie.setPath("/");
            response.addCookie(cookie);
        } else {
            final Cookie[] cookies = request.getCookies();
            if (cookies != null) {
                for (final Cookie cookie : cookies) {
                    if (URL_CENTRALIZADOR_ACESSO_PARAM.equals(cookie.getName())) {
                        // Remove o cookie caso ele tenha sobrado de uma sessão anterior
                        cookie.setMaxAge(0);
                        cookie.setPath("/");
                        response.addCookie(cookie);
                    }
                }
            }
        }

        if (ParamSist.paramEquals(CodedValues.TPC_HABILITA_TUTORIAL_PRIMEIRO_ACESSO, CodedValues.TPC_SIM, responsavel)) {
            final List<String> tutorialList = FileHelper.getFilesInDir(ParamSist.getDiretorioRaizArquivos() + "/imagem/tutorial");
            if (!tutorialList.isEmpty()) {
                Collections.sort(tutorialList);
                session.setAttribute("tutorialList", tutorialList);

                if (TextHelper.isNull(usuario.getAttribute(Columns.USU_DATA_ULT_ACESSO))) {
                    session.setAttribute("tutorialPrimeiroAcesso", Boolean.TRUE);
                }
            }
        }

        // Busca parametro de timeout dependendo do tipo do usuario
        int timeout = CodedValues.TEMPO_DEFAULT_EXPIRACAO_SESSAO;
        final ParamSist paramSist = ParamSist.getInstance();

        try {
            if (usuAcesso.isCseSupOrg()) {
                final Object objTimeout = paramSist.getParam(CodedValues.TPC_TEMPO_EXPIRACAO_SESSAO_CSE_ORG_SUP, responsavel);
                timeout = objTimeout != null ? Integer.parseInt(objTimeout.toString()) : CodedValues.TEMPO_DEFAULT_EXPIRACAO_SESSAO;
            } else if (usuAcesso.isCsaCor()) {
                final Object objTimeout = paramSist.getParam(CodedValues.TPC_TEMPO_EXPIRACAO_SESSAO_CSA_COR, responsavel);
                timeout = objTimeout != null ? Integer.parseInt(objTimeout.toString()) : CodedValues.TEMPO_DEFAULT_EXPIRACAO_SESSAO;
            }
        } catch (final NumberFormatException ex) {
            // Caso o parametro esta preenchido errado usa o valor default
            timeout = CodedValues.TEMPO_DEFAULT_EXPIRACAO_SESSAO;
        }

        // Qualquer valor igual ou menor que zero será considerado 20 minutos
        // Tempo máximo de timeout é de 20 minutos
        if ((timeout < 1) || (timeout > CodedValues.TEMPO_MAXIMO_EXPIRACAO_SESSAO)) {
            timeout = CodedValues.TEMPO_DEFAULT_EXPIRACAO_SESSAO;
        }

        // Tempo máximo inativo é em segundos
        session.setMaxInactiveInterval(timeout * 60);

        usuAcesso.setUsuNome(usuario.getAttribute(Columns.USU_NOME).toString());
        usuAcesso.setUsuLogin(usuario.getAttribute(Columns.USU_LOGIN).toString());
        usuAcesso.setUsuEmail((String) usuario.getAttribute(Columns.USU_EMAIL));

        // Verifica se acesso é via centralizador
        final String usuCentralizador = !TextHelper.isNull(request.getParameter(USU_CENTRALIZADOR_PARAM)) ? request.getParameter(USU_CENTRALIZADOR_PARAM) : (String) request.getAttribute(USU_CENTRALIZADOR_PARAM);
        if ("S".equals(usuCentralizador)) {
            usuAcesso.setUsuCentralizador(usuCentralizador);
        }
        
        // Verifica se acesso é via sso
        final String usuAutenticaSso = !TextHelper.isNull(usuario.getAttribute(Columns.USU_AUTENTICA_SSO)) ? (String) usuario.getAttribute(Columns.USU_AUTENTICA_SSO) : "";
        if ("S".equals(usuAutenticaSso)) {
            usuAcesso.setUsuAutenticaSso(usuAutenticaSso);
        }

        // Seta se é deficiente visual
        final String loginDefVisual = (usuario.getAttribute(Columns.USU_DEFICIENTE_VISUAL) != null ? usuario.getAttribute(Columns.USU_DEFICIENTE_VISUAL).toString() : "N");
        usuAcesso.setDeficienteVisual("S".equals(loginDefVisual));

        session.removeAttribute("AlterarSenha");
        final String expirou = usuario.getAttribute("EXPIROU") != null ? usuario.getAttribute("EXPIROU").toString() : "1";

        if ("1".equals(expirou)) {
            session.setAttribute("AlterarSenha", "1");
        }

        // Verifica se o usuário precisa aceitar o termo de uso.
        session.removeAttribute("AceitarTermoDeUso");
        String chaveAceitacaoTermoDeUso = CodedValues.TPC_DATA_TERMO_DE_USO_CSE;
        if (usuAcesso.isOrg()) {
            chaveAceitacaoTermoDeUso = CodedValues.TPC_DATA_TERMO_DE_USO_ORG;
        } else if (usuAcesso.isSer()) {
            chaveAceitacaoTermoDeUso = CodedValues.TPC_DATA_TERMO_DE_USO_SER;
        } else if (usuAcesso.isCsa()) {
            chaveAceitacaoTermoDeUso = CodedValues.TPC_DATA_TERMO_DE_USO_CSA;
        } else if (usuAcesso.isCor()) {
            chaveAceitacaoTermoDeUso = CodedValues.TPC_DATA_TERMO_DE_USO_COR;
        } else if (usuAcesso.isSup()) {
            chaveAceitacaoTermoDeUso = CodedValues.TPC_DATA_TERMO_DE_USO_SUP;
        }
        final Object paramAceitacaoTermoDeUso = ParamSist.getInstance().getParam(chaveAceitacaoTermoDeUso, usuAcesso);
        if (!TextHelper.isNull(paramAceitacaoTermoDeUso)) {
            try {
                final java.util.Date dataTermoDeUso = DateHelper.parse(paramAceitacaoTermoDeUso.toString(), "yyyy-MM-dd");
                final List<String> tocCodigos = new ArrayList<>();
                tocCodigos.add(CodedValues.TOC_ACEITACAO_TERMO_DE_USO);
                final CustomTransferObject filtro = new CustomTransferObject();
                filtro.setAttribute(Columns.OUS_USU_CODIGO, usuAcesso.getUsuCodigo());
                filtro.setAttribute("tocCodigos", tocCodigos);
                final List<TransferObject> ocorrencias = usuarioController.lstOcorrenciaUsuario(filtro, -1, -1, usuAcesso);
                if (ocorrencias.size() == 0) {
                    session.setAttribute("AceitarTermoDeUso", "1");
                } else {
                    final java.util.Date dataUltimaAceitacao = (java.util.Date) ocorrencias.get(0).getAttribute(Columns.OUS_DATA);
                    if ((dataUltimaAceitacao.compareTo(dataTermoDeUso) <= 0) || ((session.getAttribute("termo_usu") != null) && (Boolean) session.getAttribute("termo_usu"))) {
                        session.setAttribute("AceitarTermoDeUso", "1");
                    }
                }
            } catch (final java.text.ParseException e) {
                // Formato do parâmetro inválido
                LOG.error(e.getMessage(), e);
            }
        }

        // Verifica se o usuário precisa aceitar a política de privacidade.
        session.removeAttribute("AceitarPoliticaPrivacidade");
        String chaveAceitacaoPoliticaPrivacidade = CodedValues.TPC_DATA_POLITICA_PRIVACIDADE_CSE;
        if (usuAcesso.isOrg()) {
            chaveAceitacaoPoliticaPrivacidade = CodedValues.TPC_DATA_POLITICA_PRIVACIDADE_ORG;
        } else if (usuAcesso.isSer()) {
            chaveAceitacaoPoliticaPrivacidade = CodedValues.TPC_DATA_POLITICA_PRIVACIDADE_SER;
        } else if (usuAcesso.isCsa()) {
            chaveAceitacaoPoliticaPrivacidade = CodedValues.TPC_DATA_POLITICA_PRIVACIDADE_CSA;
        } else if (usuAcesso.isCor()) {
            chaveAceitacaoPoliticaPrivacidade = CodedValues.TPC_DATA_POLITICA_PRIVACIDADE_COR;
        } else if (usuAcesso.isSup()) {
            chaveAceitacaoPoliticaPrivacidade = CodedValues.TPC_DATA_POLITICA_PRIVACIDADE_SUP;
        }
        final Object paramAceitacaoPoliticaPrivacidade = ParamSist.getInstance().getParam(chaveAceitacaoPoliticaPrivacidade, usuAcesso);
        if (!TextHelper.isNull(paramAceitacaoPoliticaPrivacidade)) {
            try {
                final java.util.Date dataPoliticaPrivacidade = DateHelper.parse(paramAceitacaoPoliticaPrivacidade.toString(), "yyyy-MM-dd");
                final List<String> tocCodigos = new ArrayList<>();
                tocCodigos.add(CodedValues.TOC_ACEITACAO_POLITICA_PRIVACIDADE_SISTEMA);
                final CustomTransferObject filtro = new CustomTransferObject();
                filtro.setAttribute(Columns.OUS_USU_CODIGO, usuAcesso.getUsuCodigo());
                filtro.setAttribute("tocCodigos", tocCodigos);
                final List<TransferObject> ocorrencias = usuarioController.lstOcorrenciaUsuario(filtro, -1, -1, usuAcesso);
                if (ocorrencias.size() == 0) {
                    session.setAttribute("AceitarPoliticaPrivacidade", "1");
                } else {
                    final java.util.Date dataUltimaAceitacao = (java.util.Date) ocorrencias.get(0).getAttribute(Columns.OUS_DATA);
                    if (dataUltimaAceitacao.compareTo(dataPoliticaPrivacidade) <= 0) {
                        session.setAttribute("AceitarPoliticaPrivacidade", "1");
                    }
                }
            } catch (final java.text.ParseException e) {
                // Formato do parâmetro inválido
                LOG.error(e.getMessage(), e);
            }
        }

        usuAcesso.setQtdConsultasMargem((Integer) usuario.getAttribute(Columns.USU_QTD_CONSULTAS_MARGEM));
        if (usuAcesso.isCseSup()) {
            final ConsignanteTransferObject cse = consignanteController.findConsignante(cse_codigo, usuAcesso);

            usuAcesso.setNomeEntidade(cse.getCseNome());
            usuAcesso.setIdEntidade(cse.getCseIdentificador());

        } else if (usuAcesso.isCsa()) {
            final ConsignatariaTransferObject csa = consignatariaController.findConsignataria(csa_codigo, usuAcesso);

            String csa_nome = csa.getCsaNomeAbreviado();
            if ((csa_nome == null) || csa_nome.isBlank()) {
                csa_nome = csa.getCsaNome();
            }
            usuAcesso.setNomeEntidade(csa_nome);
            usuAcesso.setIdEntidade(csa.getCsaIdentificador());
            usuAcesso.setNcaCodigo(csa.getCsaNcaNatureza());
        } else if (usuAcesso.isCor()) {
            final CorrespondenteTransferObject cor = consignatariaController.findCorrespondente(cor_codigo, usuAcesso);
            final ConsignatariaTransferObject csa = consignatariaController.findConsignataria(cor.getCsaCodigo(), usuAcesso);

            String csa_nome = csa.getCsaNomeAbreviado();
            if ((csa_nome == null) || csa_nome.isBlank()) {
                csa_nome = csa.getCsaNome();
            }

            usuAcesso.setNomeEntidade(cor.getCorNome());
            usuAcesso.setIdEntidade(cor.getCorIdentificador());
            usuAcesso.setNomeEntidadePai(csa_nome);
            usuAcesso.setCodigoEntidadePai(csa.getCsaCodigo());
            usuAcesso.setNcaCodigo(csa.getCsaNcaNatureza());
        } else if (usuAcesso.isOrg()) {

            final OrgaoTransferObject org = consignanteController.findOrgao(org_codigo, usuAcesso);
            final EstabelecimentoTransferObject est = consignanteController.findEstabelecimento(org.getEstCodigo(), usuAcesso);

            usuAcesso.setNomeEntidade(org.getOrgNome());
            usuAcesso.setIdEntidade(org.getOrgIdentificador());
            usuAcesso.setNomeEntidadePai(est.getEstNome());
            usuAcesso.setCodigoEntidadePai(est.getEstCodigo());

        } else {
            return trataExcecao(request, response, session, model, responsavel, (String) usuario.getAttribute(Columns.USU_LOGIN), UsuarioControllerException.byMessage(msgErroLoginInvalido));
        }
        // Busca as permissões do usuário
        usuAcesso.setPermissoes(usuarioController.selectFuncoes(usu_codigo, codigoEntidade, tipoEntidade, usuAcesso));
        usuAcesso.setPermissaoUnidadesEdt(usuarioController.unidadesPermissaoEdtUsuario(usu_codigo, responsavel));

        // Verifica a necessidade de atualização cadastral para o papel CSE ou CSA
        session.removeAttribute("exigeAtualizacaoCadastral");
        boolean exigeAtualizacaoCadastral = false;
        final boolean exigeAtualizacaoCadastralCsaCnpj = ParamSist.paramEquals(CodedValues.TPC_EXIGE_ATUALIZACAO_CADASTRAL_CSA_CNPJ, CodedValues.TPC_SIM, responsavel);

       if (!TextHelper.isNull(tipoEntidade) && AcessoSistema.ENTIDADE_CSE.equals(tipoEntidade) && usuAcesso.temPermissao(CodedValues.FUN_EDT_CONSIGNANTE) && TextHelper.isNum(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_ATUALIZACAO_CADASTRAL_CSE, responsavel))) {
           final ConsignanteTransferObject cse = consignanteController.findConsignante(codigoEntidade, responsavel);
           final Date dataAtualizacaoCadatral = cse.getCseDataAtualizacaoCadastral();
           final int cicloDiasAtualizacao = Integer.parseInt(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_ATUALIZACAO_CADASTRAL_CSE, responsavel).toString());

            if ((cicloDiasAtualizacao > 0) && (TextHelper.isNull(dataAtualizacaoCadatral) || (DateHelper.dayDiff(dataAtualizacaoCadatral) > cicloDiasAtualizacao))) {
                exigeAtualizacaoCadastral = true;
            }
        }

        if (!TextHelper.isNull(tipoEntidade) && AcessoSistema.ENTIDADE_CSA.equals(tipoEntidade)
                && usuAcesso.temPermissao(CodedValues.FUN_EDT_CONSIGNATARIA)
                && (TextHelper.isNum(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_ATUALIZACAO_CADASTRAL_CSA, responsavel))
                || exigeAtualizacaoCadastralCsaCnpj)) {

           final ConsignatariaTransferObject csa = consignatariaController.findConsignataria(codigoEntidade, responsavel);
           final Date dataAtualizacaoCadatral = csa.getCsaDataAtualizacaoCadastral();

            if (exigeAtualizacaoCadastralCsaCnpj && !TextHelper.isNum(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_ATUALIZACAO_CADASTRAL_CSA, responsavel))) {
                session.setAttribute(AcessoSistema.SESSION_ATTR_NAME, usuAcesso);
                session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.atualizar.cadastro.erro.configuracao", responsavel));
                model.addAttribute("retornoErro", Boolean.TRUE);
                model.addAttribute("exigeAtualizacaoCadastralCsaCnpj", Boolean.FALSE);
                return viewRedirect("jsp/atualizarCadastro/atualizarCadastro", request, session, model, responsavel);
            }

            final int cicloDiasAtualizacao = Integer.parseInt(ParamSist.getInstance().getParam(CodedValues.TPC_QTDE_DIAS_ATUALIZACAO_CADASTRAL_CSA, responsavel).toString());

            if ((cicloDiasAtualizacao > 0) && (TextHelper.isNull(dataAtualizacaoCadatral) || (DateHelper.dayDiff(dataAtualizacaoCadatral) > cicloDiasAtualizacao))) {
                exigeAtualizacaoCadastral = true;
            }
        }

       if (exigeAtualizacaoCadastral) {
           session.setAttribute("exigeAtualizacaoCadastral", "1");
       }
       if (usuAcesso.isValidaTotp(false)) {
           session.setAttribute("exigeValidacaoTotp", "1");
       }

        final List<MenuTO> mnuLst = menuController.obterMenu(usuAcesso);
        verificarAcessoMenuDropDown(session, usuAcesso, mnuLst);

        usuAcesso.setMenu(mnuLst);

        // Seta data de última data de acesso ao sistema
        usuarioController.alteraDataUltimoAcessoSistema(usuAcesso);

        // Valida acesso simultâneo
        sessionManagment.validateNewSession(usu_codigo, session.getId());

        // Grava log de login sucesso
        final LogDelegate log = new LogDelegate(usuAcesso, Log.SISTEMA, Log.LOGIN, Log.LOG_LOGIN_SUCESSO);
        log.add("USER-AGENT: " + request.getHeader("user-agent"));
        log.write();

        // Armazena na sessão o objeto AcessoSistema para este usuário
        // com as informações sobre o usuário (usu_codigo, ip, tipo, entidade)
        session.setAttribute(AcessoSistema.SESSION_ATTR_NAME, usuAcesso);

        // Verifica se usuario deve confirmar leitura de alguma mensagem
        session.removeAttribute("mensagem_sem_leitura");
        final CustomTransferObject criterio = new CustomTransferObject();
        criterio.setAttribute(Columns.USU_DATA_CAD, usuario.getAttribute(Columns.USU_DATA_CAD));
        session.setAttribute("usu_data_cad", usuario.getAttribute(Columns.USU_DATA_CAD));

        final Integer semLeitura = mensagemController.countMensagemUsuarioSemLeitura(criterio, usuAcesso);
        if (semLeitura.intValue() > 0) {
            session.setAttribute("mensagem_sem_leitura", semLeitura);
        }

        // Verifica se usuario utiliza certificado digital
        session.removeAttribute("valida_certificado_digital");
        if (UsuarioHelper.isUsuarioCertificadoDigital((String) usuario.getAttribute(Columns.USU_LOGIN), (String) usuario.getAttribute(Columns.USU_EXIGE_CERTIFICADO), usuAcesso.getTipoEntidade(), usuAcesso.getCodigoEntidade(), usuAcesso)) {
            session.setAttribute("valida_certificado_digital", "true");
        }

        //Para validar se não houve tentativa de copiar o id da sessão e logar em outro navegador, previsamos armazenar na sessão o User-Agent
        session.setAttribute("userAgentLogin", request.getHeader("user-agent"));

        // seta cookie indicando que sessão inválida deve direcionar para tela de login não servidor
        response.addCookie(new Cookie("LOGIN", ""));

        int tpcDias = 0;
        if (usuAcesso.isCseOrg()) {
            tpcDias = ParamSist.getIntParamSist(CodedValues.TPC_QUANTIDADE_DIAS_NOTIFICACAO_EXPIRACAO_SENHA_CSE_ORG, 0, usuAcesso);
        } else if (usuAcesso.isCsaCor()) {
            tpcDias = ParamSist.getIntParamSist(CodedValues.TPC_QUANTIDADE_DIAS_NOTIFICACAO_EXPIRACAO_SENHA_CSA_COR, 0, usuAcesso);
        }

        if (tpcDias > 0) {
            final TransferObject usuarioAutenticaSso = usuAutenticaSso(usuAcesso);
            if (usuarioAutenticaSso.getAttribute(Columns.USU_AUTENTICA_SSO) != null && "S".equals(usuarioAutenticaSso.getAttribute(Columns.USU_AUTENTICA_SSO))) {
                final String data = getDataExpiracao(usuAcesso.getSsoToken());
                final int diff = DateHelper.dateDiff(DateHelper.format(DateHelper.getSystemDate(), "yyyy-MM-dd"), data, "yyyy-MM-dd", null, "DIAS");
                if (diff <= tpcDias) {
                    session.setAttribute(CodedValues.MSG_EXPIRACAO_SENHA, ApplicationResourcesHelper.getMessage("alerta.expiracao.senha.tela", usuAcesso, String.valueOf(diff)));
                }
            } else {
                final int diff = DateHelper.dateDiff(DateHelper.format(DateHelper.getSystemDate(), "yyyy-MM-dd"), usuarioAutenticaSso.getAttribute(Columns.USU_DATA_EXP_SENHA).toString(), "yyyy-MM-dd", null, "DIAS");
                if (diff <= tpcDias) {
                    session.setAttribute(CodedValues.MSG_EXPIRACAO_SENHA, ApplicationResourcesHelper.getMessage("alerta.expiracao.senha.tela", usuAcesso, String.valueOf(diff)));
                }
            }
        }

        // Redireciona para a principal
        return redirecionarPaginaPrincipal();
    }

    @RequestMapping(value = { "/v3/autenticarUsuario" }, params = { "acao=validarTotp" })
    public String validarTotp(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model) {
        final AcessoSistema responsavel = JspHelper.getAcessoSistema(request);

        // Se não exige validação de TOTP então volta para interface de login
        if (session.getAttribute("exigeValidacaoTotp") == null
                || !"1".equals(session.getAttribute("exigeValidacaoTotp"))
                || !responsavel.isValidaTotp(false)) {
            return redirecionarPaginaLogin();
        }

        final PermiteValidacaoTotpEnum permiteValidacaoTotp = responsavel.getUsuPermiteValidacaoTotp();
        final String codigoTotp = JspHelper.verificaVarQryStr(request, "otp");

        if (TextHelper.isNull(codigoTotp)) {
            if (PermiteValidacaoTotpEnum.EMAIL.equals(permiteValidacaoTotp) || PermiteValidacaoTotpEnum.SMS.equals(permiteValidacaoTotp)) {
                // Se o TOTP é por e-mail ou SMS, dispara a notificação com o código
                try {
                    usuarioController.enviarOtpUsuarioPorEmailOuCelular(responsavel.getUsuCodigo(), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL), permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.SMS), responsavel);
                    session.setAttribute(CodedValues.MSG_ALERT, ApplicationResourcesHelper.getMessage(permiteValidacaoTotp.equals(PermiteValidacaoTotpEnum.EMAIL) ? "mensagem.totp.enviado.email.codigo" : "mensagem.totp.enviado.sms.codigo", responsavel));
                } catch (Exception ex) {
                    session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
                    return viewRedirect("jsp/visualizarPaginaErro/visualizarMensagem", request, session, model, responsavel);
                }
            }

            // Se o código ainda não foi informado, redireciona à página para informação
            SynchronizerToken.saveToken(request);
            return viewRedirect("jsp/autenticarUsuario/validarTotp", request, session, model, responsavel);
        }

        if (!SynchronizerToken.isTokenValid(request)) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erro.interno.contate.administrador", responsavel));
            return redirecionarPaginaLogin();
        }
        SynchronizerToken.saveToken(request);

        Integer qtdTentativasTotp = session.getAttribute("qtdTentativasTotp") != null ? (Integer) session.getAttribute("qtdTentativasTotp") : 1;
        if (qtdTentativasTotp >= 3) {
            // Invalida a sessão do usuário e recomeça o processo
            session.invalidate();
            session = request.getSession(true);
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.totp.codigo.invalido.recomecar", responsavel));

            try {
                // Gerar log de erro de segurança
                final com.zetra.econsig.delegate.LogDelegate log = new com.zetra.econsig.delegate.LogDelegate(responsavel, Log.USUARIO, Log.LOGIN, Log.LOG_ERRO_SEGURANCA);
                log.add(ApplicationResourcesHelper.getMessage("mensagem.erro.tentativa.validacao.totp.excedida", responsavel).toUpperCase());
                log.write();
            } catch (final LogControllerException ex) {
                LOG.error(ex.getMessage(), ex);
            }

            // Redireciona para o login
            return redirecionarPaginaLogin();
        }
        session.setAttribute("qtdTentativasTotp", ++qtdTentativasTotp);

        try {
            final long timeInMilliseconds = Long.parseLong(JspHelper.verificaVarQryStr(request, "timeInMilliseconds"));

            if (UsuarioHelper.isTotpValidoUsuario(codigoTotp, permiteValidacaoTotp, null, timeInMilliseconds, responsavel)) {
                session.removeAttribute("qtdTentativasTotp");
                session.removeAttribute("exigeValidacaoTotp");
                return redirecionarPaginaPrincipal();
            }
    
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.totp.codigo.invalido", responsavel));
        } catch (ViewHelperException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ex.getMessage());
        } catch (NumberFormatException ex) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.usoIncorretoSistema", responsavel));
        }

        return viewRedirect("jsp/autenticarUsuario/validarTotp", request, session, model, responsavel);
    }

    private String redirecionarPaginaPrincipal() {
        return "redirect:/v3/carregarPrincipal?mostraMensagem=true&limitaMsg=true";
    }

    private String redirecionarPaginaLogin() {
        return "redirect:/v3/autenticarUsuario?t=" + DateHelper.format(DateHelper.getSystemDatetime(), "yyyyMMddHHmmss");
    }

    private String trataExcecao(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model, AcessoSistema responsavel, String usuLogin, Exception exc) {
        if (exc.getClass().equals(UsuarioControllerException.class)
                || exc.getClass().equals(ViewHelperException.class)) {
            session.setAttribute(CodedValues.MSG_ERRO, exc.getMessage());
        } else {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erroInternoSistema", responsavel));
            LOG.error(exc.getMessage(), exc);
        }

        AcessoSistema usuAcesso = JspHelper.getAcessoSistema(request);
        CustomTransferObject usuario = null;
        try {
            if (!TextHelper.isNull(usuLogin)) {
                usuario = usuarioController.findTipoUsuarioByLogin(usuLogin, responsavel);
            }
        } catch (final UsuarioControllerException e) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erroInternoSistema", responsavel));
            LOG.error(e.getMessage(), e);
        }
        if (usuario != null) {
            usuAcesso = new AcessoSistema(usuario.getAttribute(Columns.USU_CODIGO).toString(), JspHelper.getRemoteAddr(request), JspHelper.getRemotePort(request));
        }
        final LogDelegate log = new LogDelegate (usuAcesso, Log.SISTEMA, Log.LOGIN, Log.LOG_LOGIN_ERRO);
        try {
            log.add("LOGIN: " + usuLogin);
            log.add("ERRO: " + session.getAttribute(CodedValues.MSG_ERRO));
            log.add("USER-AGENT: " + request.getHeader("user-agent"));
            log.write();
        } catch (final LogControllerException e) {
            session.setAttribute(CodedValues.MSG_ERRO, ApplicationResourcesHelper.getMessage("mensagem.erroInternoSistema", responsavel));
            LOG.error(e.getMessage(), e);
        }

        session.removeAttribute(com.zetra.econsig.values.CodedNames.ATTR_SESSION_CENTRALIZADOR);

        return iniciar(request, response, session, model);
    }

    private String getTextoAutenticacaoUsuario(AcessoSistema responsavel) throws ViewHelperException {
        final String autenticacaoUsuario = "autenticacao_usuario.msg";

        String absolutePath = ParamSist.getDiretorioRaizArquivos();
        absolutePath += File.separatorChar + "autenticacao_usuario" + File.separatorChar + autenticacaoUsuario;

        final File arqMensagem = new File(absolutePath);
        if (!arqMensagem.exists()) {
            LOG.error(ApplicationResourcesHelper.getMessage("mensagem.log.texto.arquivo.autenticacao.usuario.nao.encontrado", responsavel, absolutePath));
            throw new ViewHelperException("mensagem.erro.interno.texto.arquivo.autenticacao.usuario.nao.encontrado", responsavel);
        }

        return FileHelper.readAll(absolutePath);
    }


    private TransferObject usuAutenticaSso(AcessoSistema responsavel) {
        try {
            return usuarioController.findTipoUsuarioByLogin(responsavel.getUsuLogin(), responsavel);
        } catch (final UsuarioControllerException e) {
            throw new RuntimeException(e);
        }
    }

    private String getDataExpiracao(SSOToken ssoToken) {
        try {
            final SSOClient ssoClient = ApplicationContextProvider.getApplicationContext().getBean(SSOClient.class);
            return ssoClient.getDataExpiracao(ssoToken);
        } catch (final SSOException e) {
            throw new RuntimeException(e);
        }
    }

    private TipoEntidadeVO determinarTipoEntidade (TransferObject usuario) {

        String tipo = "";
        String entidade = "";

        String cse_codigo = usuario.getAttribute(Columns.UCE_CSE_CODIGO) != null ? usuario.getAttribute(Columns.UCE_CSE_CODIGO).toString() : "";
        final String csa_codigo = usuario.getAttribute(Columns.UCA_CSA_CODIGO) != null ? usuario.getAttribute(Columns.UCA_CSA_CODIGO).toString() : "";
        final String cor_codigo = usuario.getAttribute(Columns.UCO_COR_CODIGO) != null ? usuario.getAttribute(Columns.UCO_COR_CODIGO).toString() : "";
        final String org_codigo = usuario.getAttribute(Columns.UOR_ORG_CODIGO) != null ? usuario.getAttribute(Columns.UOR_ORG_CODIGO).toString() : "";
        final String ser_codigo = usuario.getAttribute(Columns.USE_SER_CODIGO) != null ? usuario.getAttribute(Columns.USE_SER_CODIGO).toString() : "";
        final String usp_cse_codigo = usuario.getAttribute(Columns.USP_CSE_CODIGO) != null ? usuario.getAttribute(Columns.USP_CSE_CODIGO).toString() : "";

        // Determina o tipo da entidade do usuário
        if (!"".equals(cse_codigo)) {
            tipo = AcessoSistema.ENTIDADE_CSE;
            entidade = cse_codigo;
        } else if (!"".equals(csa_codigo)) {
            tipo = AcessoSistema.ENTIDADE_CSA;
            entidade = csa_codigo;
        } else if (!"".equals(cor_codigo)) {
            tipo = AcessoSistema.ENTIDADE_COR;
            entidade = cor_codigo;
        } else if (!"".equals(org_codigo)) {
            tipo = AcessoSistema.ENTIDADE_ORG;
            entidade = org_codigo;
        } else if (!"".equals(ser_codigo)) {
            tipo = AcessoSistema.ENTIDADE_SER;
            entidade = ser_codigo;
        } else if (!"".equals(usp_cse_codigo)) {
            tipo = AcessoSistema.ENTIDADE_SUP;
            entidade = usp_cse_codigo;
            cse_codigo = usp_cse_codigo;
        }

        TipoEntidadeVO result = new TipoEntidadeVO(tipo, entidade, cse_codigo, csa_codigo, cor_codigo, org_codigo, ser_codigo, usp_cse_codigo);

        return result;

    }

}

